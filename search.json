["","Atomic Kotlin Bruce Eckel and Svetlana Isakova This book is for sale at http://leanpub.com/AtomicKotlin This version was published on 2020-09-02 ISBN 978-0-9818725-4-4 This is a Leanpub book. Leanpub empowers authors and publishers with the Lean Publishing process. Lean Publishing is the act of publishing an in-progress ebook using lightweight tools and many iterations to get reader feedback, pivot until you have the right book and build traction once you do. © 2020 Mindview LLC ","CONTENTS Contents Copyright .......................................... 1 Section I: Programming Basics ............. 5 Introduction ........................................ 6 Why Kotlin? ........................................ 12 Hello, World! ........................................ 23 var & val .......................................... 26 Data Types ......................................... 29 Functions .......................................... 33 if Expressions ....................................... 37 String Templates ..................................... 42 Number Types ....................................... 44 Booleans .......................................... 50 Repetition with while .................................. 54 Looping & Ranges .................................... 58 The in Keyword ...................................... 64 Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","CONTENTS Expressions & Statements ............................... 68 Summary 1 ......................................... 72 Section II: Introduction to Objects ......... 85 Objects Everywhere ................................... 86 Creating Classes ..................................... 90 Properties .......................................... 94 Constructors ........................................ 99 Constraining Visibility ................................. 103 Packages ........................................... 109 Testing ............................................ 113 Exceptions ......................................... 119 Lists ............................................. 124 Variable Argument Lists ................................ 130 Sets .............................................. 136 Maps ............................................. 139 Property Accessors .................................... 143 Summary 2 ......................................... 148 Section III: Usability ......................... 173 Extension Functions ................................... 174 Named & Default Arguments ............................. 177 Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","CONTENTS Overloading ........................................ 182 when Expressions ..................................... 186 Enumerations ....................................... 192 Data Classes ........................................ 196 Destructuring Declarations .............................. 200 Nullable Types ....................................... 205 Safe Calls & the Elvis Operator ............................ 210 Non-null Assertions ................................... 214 Extensions for Nullable Types ............................. 217 Introduction to Generics ................................ 220 Extension Properties ................................... 225 break & continue .................................... 228 Section IV: Functional Programming ...... 233 Lambdas ........................................... 234 The Importance of Lambdas .............................. 239 Operations on Collections ............................... 244 Member References ................................... 250 Higher-Order Functions ................................ 256 Manipulating Lists .................................... 262 Building Maps ....................................... 268 Sequences .......................................... 278 Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","CONTENTS Local Functions ...................................... 286 Folding Lists ........................................ 292 Recursion .......................................... 295 Section V: Object-Oriented Programming . 303 Interfaces .......................................... 304 Complex Constructors .................................. 310 Secondary Constructors ................................. 312 Inheritance ......................................... 316 Base Class Initialization ................................. 322 Abstract Classes ...................................... 327 Upcasting .......................................... 334 Polymorphism ....................................... 339 Composition ........................................ 343 Inheritance & Extensions ................................ 349 Class Delegation ..................................... 361 Downcasting ........................................ 366 Sealed Classes ....................................... 374 Type Checking ....................................... 380 Nested Classes ....................................... 392 Objects ............................................ 400 Inner Classes ........................................ 404 Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","CONTENTS Companion Objects ................................... 413 Section VI: Preventing Failure .............. 422 Exception Handling ................................... 423 Check Instructions .................................... 434 The Nothing Type .................................... 443 Resource Cleanup ..................................... 447 Logging ........................................... 450 Unit Testing ........................................ 455 Section VII: Power Tools .................... 465 Scope Functions ...................................... 466 Extension Lambdas .................................... 474 Creating Generics .................................... 485 Operator Overloading .................................. 501 Using Operators ...................................... 509 Property Delegation ................................... 515 Property Delegation Tools ............................... 525 Lazy Initialization .................................... 531 Late Initialization ..................................... 535 Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","CONTENTS Appendices ................................... 539 Appendix A: AtomicTest ................................ 540 Appendix B: Java Interoperability .......................... 543 Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Copyright Atomic Kotlin By Bruce Eckel, President, MindView, LLC., and Svetlana Isakova, JetBrains sro. Copyright ©2020, MindView LLC. eBook ISBN 978-0-9818725-4-4 Print Book ISBN 978-0-9818725-5-1 The eBook ISBN covers the Stepik and Leanpub eBook distributions, both available through AtomicKotlin.com . Please purchase this book through www.AtomicKotlin.com, to support its continued maintenance and updates. All rights reserved. Printed in the United States of America. This publication is protected by copyright, and permission must be obtained from the publisher prior to any prohibited reproduction, storage in a retrieval system, or transmission in any form or by any means, electronic, mechanical, photocopying, recording, or likewise. For information regarding permissions, see AtomicKotlin.com. Created in Crested Butte, Colorado, USA, and Berlin, Germany. Text printed in the United States Ebook: Version 1.0, August 2020 First printing October 2020 ","Copyright 2 Cover design by Daniel Will-Harris, www.Will-Harris.com¹ Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this book, and the publisher was aware of a trademark claim, the designations are printed with initial capital letters or in all capitals. The Kotlin trademark belongs to the Kotlin Foundation² . Java is a trademark or registered trademark of Oracle, Inc. in the United States and other countries. Windows is a registered trademark of Microsoft Corporation in the United States and other countries. All other product names and company names mentioned herein are the property of their respective owners. The authors and publisher have taken care in the preparation of this book, but make no expressed or implied warranty of any kind and assume no responsibility for errors or omissions. No liability is assumed for incidental or consequential damages in connection with or arising out of the use of the information or programs contained herein. Visit us at www.AtomicKotlin.com. Source Code All the source code for this book is available as copyrighted freeware, distributed via Github³ . To ensure you have the most current version, this is the official code distribution site. You may use this code in classroom and other educational situations as long as you cite this book as the source. The primary goal of this copyright is to ensure that the source of the code is properly cited, and to prevent you from republishing the code without permission. (As long as this book is cited, using examples from the book in most media is generally not a problem.) In each source-code file you find a reference to the following copyright notice: ¹ http://www.Will-Harris.com ² https://kotlinlang.org/foundation/kotlin-foundation.html ³ https://github.com/BruceEckel/AtomicKotlinExamples Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Copyright 3 // Copyright.txt This computer source code is Copyright ©2020 MindView LLC. All Rights Reserved. Permission to use, copy, modify, and distribute this computer source code (Source Code) and its documentation without fee and without a written agreement for the purposes set forth below is hereby granted, provided that the above copyright notice, this paragraph and the following five numbered paragraphs appear in all copies. 1. Permission is granted to compile the Source Code and to include the compiled code, in executable format only, in personal and commercial software programs. 2. Permission is granted to use the Source Code without modification in classroom situations, including in presentation materials, provided that the book Atomic Kotlin is cited as the origin. 3. Permission to incorporate the Source Code into printed media may be obtained by contacting: MindView LLC, PO Box 969, Crested Butte, CO 81224 MindViewInc@gmail.com 4. The Source Code and documentation are copyrighted by MindView LLC. The Source code is provided without express or implied warranty of any kind, including any implied warranty of merchantability, fitness for a particular purpose or non-infringement. MindView LLC does not warrant that the operation of any program that includes the Source Code will be uninterrupted or error-free. MindView LLC makes no representation about the suitability of the Source Code or of any software that includes the Source Code for any purpose. The entire risk as to the quality and performance of any program that includes the Source Code is with the user of the Source Code. The user understands that the Source Code was developed for research and instructional purposes and is advised not to rely exclusively for any reason on the Source Code or any program that includes the Source Code. Should the Source Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Copyright 4 Code or any resulting software prove defective, the user assumes the cost of all necessary servicing, repair, or correction. 5. IN NO EVENT SHALL MINDVIEW LLC, OR ITS PUBLISHER BE LIABLE TO ANY PARTY UNDER ANY LEGAL THEORY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS, OR FOR PERSONAL INJURIES, ARISING OUT OF THE USE OF THIS SOURCE CODE AND ITS DOCUMENTATION, OR ARISING OUT OF THE INABILITY TO USE ANY RESULTING PROGRAM, EVEN IF MINDVIEW LLC, OR ITS PUBLISHER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. MINDVIEW LLC SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOURCE CODE AND DOCUMENTATION PROVIDED HEREUNDER IS ON AN AS IS BASIS, WITHOUT ANY ACCOMPANYING SERVICES FROM MINDVIEW LLC, AND MINDVIEW LLC HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. Please note that MindView LLC maintains a Web site which is the sole distribution point for electronic copies of the Source Code, where it is freely available under the terms stated above: https://github.com/BruceEckel/AtomicKotlinExamples If you think you've found an error in the Source Code, please submit a correction at: https://github.com/BruceEckel/AtomicKotlinExamples/issues You may use the code in your projects and in the classroom (including your presentation materials) as long as the copyright notice that appears in each source file is retained. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Section I: Programming Basics There was something amazingly enticing about programming — Vint Cerf This section is for readers who are learning to program. If you’re an experienced programmer, skip forward to Summary 1 and Summary 2 . ","Introduction This book is for dedicated novices and experienced programmers. You’re a novice if you don’t have prior programming knowledge, but “dedicated” because we give you just enough to figure it out on your own. When you’re finished, you’ll have a solid foundation in programming and in Kotlin. If you’re an experienced programmer, skip forward to Summary 1 and Summary 2 , then proceed from there. The “Atomic” part of the book title refers to atoms as the smallest indivisible units. In this book, we try to introduce only one concept per chapter, so the chapters cannot be further subdivided—thus we call them atoms . Concepts All programming languages consist of features. You apply these features to produce results. Kotlin is powerful—not only does it have a rich set of features, but you can usually express those features in numerous ways. If everything is dumped on you too quickly, you might come away thinking Kotlin is “too complicated.” This book attempts to prevent overwhelm. We teach you the language carefully and deliberately, using the following principles: 1. Baby steps and small wins . We cast off the tyranny of the chapter. Instead, we present each small step as an atomic concept or simply atom , which looks like a tiny chapter. We try to present only one new concept per atom. A typical atom contains one or more small, runnable pieces of code and the output it produces. 2. No forward references . As much as possible, we avoid saying, “These features are explained in a later atom.” ","Introduction 7 3. No references to other programming languages . We do so only when necessary. An analogy to a feature in a language you don’t understand isn’t helpful. 4. Show don’t tell . Instead of verbally describing a feature, we prefer examples and output. It’s better to see a feature in code. 5. Practice before theory . We try to show the mechanics of the language first, then tell why those features exist. This is backwards from “traditional” teaching, but it often seems to work better. If you know the features, you can work out the meaning. It’s usually easier to understand a single page of Kotlin than it is to understand the equivalent code in another language. Where Is the Index? This book is written in Markdown and produced with Leanpub. Unfortunately, neither Markdown nor Leanpub supports indexes. However, by creating the smallest-possible chapters (atoms) consisting of a single topic in each atom, the table of contents acts as a kind of index. In addition, the eBook versions allow for electronic searching across the book. Cross-References A reference to an atom in the book looks like this: Introduction , which in this case refers to the current atom. In the various eBook formats, this produces a hyperlink to that atom. Formatting In this book: • Italics introduce a new term or concept, and sometimes emphasize an idea. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Introduction 8 • Fixed-width font indicates program keywords, identifiers and file names. The code examples are also in this font, and are colorized in the eBook versions of the book. • In prose, we follow a function name with empty parentheses, as in func() . This reminds the reader they are looking at a function. • To make the eBook easy to read on all devices and allow the user to increase the font size, we limit our code listing width to 47 characters. At times this requires compromise, but we feel the results are worth it. To achieve these widths we may remove spaces that might otherwise be included in many formatting styles—in particular, we use two-space indents rather than the standard four spaces. Sample the Book We provide a free sample of the electronic book at AtomicKotlin.com⁴ . The sample includes the first two sections in their entirety, along with several subsequent atoms. This way you can try out the book and decide if it’s a good fit for you. The complete book is for sale, both as a print book and an eBook. If you like what we’ve done in the free sample, please support us and help us continue our work by paying for what you use. We hope the book helps, and we appreciate your sponsorship. In the age of the Internet, it doesn’t seem possible to control any piece of information. You’ll probably find the electronic version of this book in numerous places. If you are unable to pay for the book right now and you do download it from one of these sites, please “pay it forward.” For example, help someone else learn the language once you’ve learned it. Or help someone in any way they need. Perhaps in the future you’ll be better off, and then you can pay for the book. Exercises and Solutions Most atoms in Atomic Kotlin are accompanied by a handful of small exercises. To improve your understanding, we recommend solving the exercises immediately after ⁴ http://AtomicKotlin.com Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Introduction 9 reading the atom. All exercises are checked automatically by the JetBrains IntelliJ IDEA integrated development environment (IDE), so you can see your progress and get hints if you get stuck. You can find the following links at http://AtomicKotlin.com/exercises/⁵ . To solve the exercises, install IntelliJ IDEA with the Edu Tools plugin by following these tutorials: 1. Install IntelliJ IDEA and the EduTools Plugin⁶ . 2. Open the Atomic Kotlin course and solve the exercises⁷ . In the course, you’ll find solutions for all exercises. If you’re stuck on an exercise, check for hints or try peeking at the solution. We still recommend implementing it yourself. If you have any problems setting up and running the course, please read The Troubleshooting Guide⁸ . If that doesn’t solve your problem, please contact the support team as mentioned in the guide. If you find a mistake in the course content (for example, a test for a task produces the wrong result), please use our issue tracker to report the problem with this prefilled form⁹ . Note that you’ll need to log in into YouTrack. We appreciate your time in helping to improve the course! Seminars You can find information about live seminars and other learning tools at AtomicK-otlin.com¹⁰ . ⁵ http://AtomicKotlin.com/exercises/ ⁶ https://www.jetbrains.com/help/education/install-edutools-plugin.html ⁷ https://www.jetbrains.com/help/education/learner-start-guide.html?section=Atomic%20Kotlin ⁸ https://www.jetbrains.com/help/education/troubleshooting-guide.html ⁹ https://youtrack.jetbrains.com/newIssue?project=EDC&summary=AtomicKotlin%3A%20%3C%3C%20atom%20% 2B%20exercise%20%3E%3E&description=%3C%3C%20Describe%20the%20problem%20here%20%3E%3E&c=Subsystem% 20Kotlin&c=Assignee%20svtk ¹⁰ http://AtomicKotlin.com Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Introduction 10 Conferences Bruce creates Open-Spaces conferences such as the Winter Tech Forum¹¹ . Join the mailing list at AtomicKotlin.com¹² to stay informed about our activities and where we are speaking. Support Us This was a big project. It took time and effort to produce this book and accompanying support materials. If you enjoy this book and want to see more things like it, please support us: • Blog, tweet, etc. and tell your friends. This is a grassroots marketing effort so everything you do will help. • Purchase an eBook or print version of this book at AtomicKotlin.com¹³ . • Check AtomicKotlin.com¹⁴ for other support products or events. About Us Bruce Eckel is the author of the multi-award-winning Thinking in Java and Thinking in C++ , and a number of other books on computer programming including Atomic Scala¹⁵ . He’s given hundreds of presentations throughout the world and puts on alternative conferences and events like the Winter Tech Forum¹⁶ and developer retreats. Bruce has a BS in applied physics and an MS in computer engineering. His blog is at www.BruceEckel.com¹⁷ and his consulting, training and conference business is Mindview LLC¹⁸ . Svetlana Isakova began as a member of the Kotlin compiler team, and is now a developer advocate for JetBrains. She teaches Kotlin and speaks at conferences worldwide, and is coauthor of the book Kotlin in Action . ¹¹ http://www.WinterTechForum.com ¹² http://AtomicKotlin.com ¹³ http://AtomicKotlin.com ¹⁴ http://AtomicKotlin.com ¹⁵ http://www.atomicscala.com/ ¹⁶ http://www.WinterTechForum.com ¹⁷ http://www.BruceEckel.com ¹⁸ https://www.mindviewllc.com/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Introduction 11 Acknowledgements • The Kotlin Language Design Team and contributors. • The developers of Leanpub, which made publishing this book so much easier. Dedications For my beloved father, E. Wayne Eckel. April 1, 1924—November 23, 2016. You first taught me about machines, tools, and design. For my father, Sergey Lvovich Isakov, who passed away so early and who we will always miss. About the Cover Daniel Will-Harris¹⁹ designed the cover based on the Kotlin logo. ¹⁹ http://www.will-harris.com Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Why Kotlin? Programming language design is an evolutionary path from serving the needs of the machine to serving the needs of the programmer. We give an overview of the historical development of programming languages so you can understand where Kotlin fits and why you might want to learn it. This atom introduces some topics which, if you are a novice, might seem too complicated right now. Feel free to skip this atom and come back to it after you’ve read more of the book. A programming language is invented by a language designer and implemented as either an interpreter or a compiler , which are also programs. The implementer is usually the language designer, at least initially. Early languages focused on hardware limitations. As computers become more powerful, newer languages shift toward more sophisticated programming with an emphasis on reliability. These languages can also begin choosing features based on the psychology of programming. Every programming language is a collection of experiments. Historically, program-ming language design has been a succession of guesses and assumptions about what will make programmers more productive. Some of those experiments fail, some are mildly successful and some are very successful. We learn from the experiments in each new language. Some languages address issues that turn out to be incidental rather than essential, or the environment changes (faster processors, cheaper memory, new understanding of programming and languages) and that issue becomes less important or even inconsequential. If those ideas become obsolete and the language doesn’t evolve, it fades from use. The original programmers worked directly with numbers representing processor machine instructions. This approach produced numerous errors, and assembly language was created to replace the numbers with mnemonic opcodes —words that programmers could more easily remember and read, along with a number of ","Why Kotlin? 13 other helpful tools. However, there was still a one-to-one correspondence between assembly-language instructions and machine instructions, and programmers had to write each line of assembly code. In addition, each computer processor used its own distinct assembly language. Developing programs in assembly language is exceedingly expensive. Higher-level languages help solve that problem by providing a level of abstraction away from low-level assembly languages. Here we give a history of selected languages, chosen for their influence on those that followed them. All these languages ultimately inspired the design of Kotlin, sometimes by being an example of what not to do. FORTRAN: FORmula TRANslation (1957) Designed for use by scientists and engineers, Fortran’s goal was to make it easier to encode equations. Finely-tuned and tested Fortran libraries are still in use today, but they are typically “wrapped” to make them callable from other languages. LISP: LISt Processor (1958) Rather than being application-specific, LISP embodied essential programming con-cepts; it was the computer scientist’s language and the first functional programming language (You’ll learn about functional programming in this book). The tradeoff for its power and flexibility was efficiency: LISP was typically too expensive to run on early machines, and only in recent decades have machines become fast enough to produce a resurgence in the use of LISP. For example, the GNU Emacs editor is written entirely in LISP, and can be extended using LISP. ALGOL: ALGOrithmic Language (1958) Arguably the most influential of the 1950’s languages because it introduced syntax that persisted in many subsequent languages. For example, C and its derivatives are “ALGOL-like” languages. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Why Kotlin? 14 COBOL: COmmon Business-Oriented Language (1959) Designed for business, finance, and administrative data processing. It has an English-like syntax, and was intended to be self-documenting and highly readable. Although this intent generally failed—COBOL is famous for bugs introduced by a misplaced period—the US Department of Defense forced widespread adoption on mainframe computers, and systems are still running (and requiring maintenance) today. BASIC: Beginners’ All-purpose Symbolic Instruction Code (1964) This was one of the early attempts to make programming accessible. While very successful, its features and syntax were limited, so it was only partly helpful for people who needed to learn more sophisticated languages. It is predominantly an interpreted language, which means that to run it you need the original code for the program. Despite that, many useful programs were written in BASIC, in particular as a scripting language for Microsoft’s “Office” products. BASIC might even be thought of as the first “open” programming language, as people made numerous variations of it. Simula 67, the Original Object-Oriented Language (1967) A simulation typically involves many “objects” interacting with each other. Different objects have different characteristics and behaviors. Languages that existed at the time were awkward to use for simulations, so Simula (another “ALGOL-like” language) was developed to provide direct support for creating simulation objects. It turns out that these ideas are also useful for general-purpose programming, and this was the genesis of Object-Oriented (OO) languages. Pascal (1970) Pascal increased compilation speed by restricting the language so it could be implemented as a single-pass compiler . The language forced the programmer to Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Why Kotlin? 15 structure their code in a particular way and imposed somewhat awkward and less-readable constraints on program organization. As processors became faster, memory cheaper, and compiler technology better, the impact of these constraints became too costly. An implementation of Pascal, Turbo Pascal from Borland, initially worked on CP/M machines and then made the move to early MS-DOS (precursor to Windows), later evolving into the Delphi language for Windows. By putting everything in memory, Turbo Pascal compiled at lightning speeds on very underpowered machines, dramat-ically improving the programming experience. Its creator, Anders Hejlsberg, later went on to design both C# and TypeScript. Niklaus Wirth, the inventor of Pascal, created subsequent languages: Modula, Modula-2 and Oberon. As the name implies, Modula focused on dividing programs into modules, for better organization and faster compilation. Most modern languages support separate compilation and some form of module system. C (1972) Despite the increasing number of higher-level languages, programmers were still writing assembly language. This is often called systems programming , because it is done at the level of the operating system, but it also includes embedded programming for dedicated physical devices. This is not only arduous and expensive (Bruce began his career writing assembly language for embedded systems), but it isn’t portable— assembly language can only run on the processor it is written for. C was designed to be a “high-level assembly language” that is still close enough to the hardware that you rarely need to write assembly. More importantly, a C program runs on any processor with a C compiler. C decoupled the program from the processor, which solved a huge and expensive problem. As a result, former assembly-language programmers could be vastly more productive in C. C has been so effective that recent languages (notably Go and Rust) are still attempting to usurp it for systems programming. Smalltalk (1972) Designed from the beginning to be purely object-oriented, Smalltalk significantly moved OO and language theory forward by being a platform for experimentation Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Why Kotlin? 16 and demonstrating rapid application development. However, it was created when languages were still proprietary, and the entry price for a Smalltalk system could be in the thousands. It was interpreted, so you needed a Smalltalk environment to run programs. Open-source Smalltalk implementations did not appear until after the programming world had moved on. Smalltalk programmers have contributed great insights benefitting later OO languages like C++ and Java. C++: A Better C with Objects (1983) Bjarne Stroustrup created C++ because he wanted a better C and he wanted support for the object-oriented constructs he had experienced while using Simula-67. Bruce was a member of the C++ Standards Committee for its first eight years, and wrote three books on C++ including Thinking in C++ . Backwards-compatibility with C was a foundational principle of C++ design, so C code can be compiled in C++ with virtually no changes. This provided an easy migration path—programmers could continue to program in C, receive the benefits of C++, and slowly experiment with C++ features while still being productive. Most criticisms of C++ can be traced to the constraint of backwards compatibility with C. One of the problems with C was the issue of memory management . The programmer must first acquire memory, then run an operation using that memory, then release the memory. Forgetting to release memory is called a memory leak and can result in using up the available memory and crashing the process. The initial version of C++ made some innovations in this area, along with constructors to ensure proper initialization. Later versions of the language have made significant improvements in memory management. Python: Friendly and Flexible (1990) Python’s designer, Guido Van Rossum, created the language based on his inspiration of “programming for everyone.” His nurturing of the Python community has given it the reputation of being the friendliest and most supportive community in the programming world. Python was one of the first open-source languages, resulting in implementations on virtually every platform including embedded systems and machine learning. Its dynamism and ease-of-use makes it ideal for automating small, repetitive tasks but its features also support the creation of large, complex programs. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Why Kotlin? 17 Python is a true “grass-roots” language; it never had a company promoting it and the attitude of its fans was never to push the language, but simply to help anyone learn it who wants to. The language continues to steadily improve, and in recent years its popularity has skyrocketed. Python may have been the first mainstream language to combine functional and OO programming. It predated Java with automatic memory management using garbage collection (you typically never have to allocate or release memory yourself) and the ability to run programs on multiple platforms. Haskell: Pure Functional Programming (1990) Inspired by Miranda (1985), a proprietary language, Haskell was created as an open standard for pure functional programming research, although it has also been used for products. Syntax and ideas from Haskell have influenced a number of subsequent languages including Kotlin. Java: Virtual Machines and Garbage Collection (1995) James Gosling and his team were given the task of writing code for a TV set-top box. They decided they didn’t like C++ and instead of creating the box, created the Java language. The company, Sun Microsystems, put an enormous marketing push behind the free language (still a new idea at the time) to attempt domination of the emerging Internet landscape. This perceived time window for Internet domination put a lot of pressure on Java language design, resulting in a significant number of flaws (The book Thinking in Java illuminates these flaws so readers are prepared to cope with them). Although Java was remarkably successful, an important Kotlin design goal is to fix Java’s flaws so programmers can be more productive. Brian Goetz at Oracle, the current lead developer of Java, has made remarkable and surprising improvements in Java despite the constraints he inherited. Java’s success came from two innovative features: a virtual machine and garbage collection . These were available in other languages—for example, LISP, Smalltalk and Python have garbage collection and UCSD Pascal ran on a virtual machine—but they Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Why Kotlin? 18 were never considered practical for mainstream languages. Java changed that, and in doing so made programmers significantly more productive. A virtual machine is an intermediate layer between the language and the hardware, so the language doesn’t have to generate machine code for a particular processor; it only needs to generate an intermediate language that runs on the virtual machine. Virtual machines require processing power and, before Java, were believed to be impractical. The Java Virtual Machine (JVM) gave rise to Java’s slogan “write once, run everywhere.” In addition, other languages can be more easily developed by targeting the JVM; examples include Groovy, a Java-like scripting language, and Clojure, a version of LISP. Garbage collection solves the problem of forgetting to release memory. There are also times when it can be quite difficult to know when a piece of storage is no longer used. Projects have been significantly delayed or even cancelled because of memory leaks. Although garbage collection appears in some prior languages, it was believed to produce an unacceptable amount of overhead until Java showed that it could be practical. JavaScript: Java in Name Only (1995) The original Web browser simply copied and displayed pages from a Web server. Web browsers proliferated, becoming a new programming platform that needed language support. Java wanted to be this language but was too awkward for the job. JavaScript began as LiveScript and was built into NetScape Navigator, one of the first Web browsers. Renaming it to JavaScript was a marketing ploy by NetScape, as the language has only a vague similarity to Java. As the Web took off, JavaScript became tremendously important. However, the behavior of JavaScript was so unpredictable that Douglas Crockford wrote a book with the tongue-in-cheek title JavaScript, the Good Parts , where he demonstrated all the problems with the language so programmers could avoid them. Subsequent improvements by the ECMAScript committee changed JavaScript so thoroughly that it would be unrecognizeable by an original JavaScript programmer. It is now considered a stable and mature language. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Why Kotlin? 19 Scala: SCALAble (2003) Martin Odersky created Scala to run on the Java virtual machine: To piggyback on the work done on the JVM, to interact with Java programs, and possibly with the idea that it might displace Java. As a researcher, Odersky and his team used Scala as a platform to experiment with language features, notably those not included in Java. These experiments have been illuminating and a number of them found their way into Kotlin, usually in a modified form. For example, the ability to redefine operators like + for use in special cases is called operator overloading . This was included in C++ but not Java. Scala added operator overloading but also allows you to invent new operators by combining any sequence of characters. This often produces confusing code. A limited form of operator overloading is included in Kotlin, but you can only overload operators that already exist. Scala is also an object-functional hybrid, like Python but with a focus on pure functions and strict objects. This helped inspire Kotlin’s choice to also be an object-functional hybrid. Like Scala, Kotlin runs on the JVM but it interacts with Java far more easily than Scala does. In addition, Kotlin targets JavaScript, the Android OS, and it generates native code for other platforms. Atomic Kotlin evolved from the ideas and material in Atomic Scala²⁰ . Why Kotlin? (Introduced 2011, Version 1.0: 2016) Just as C++ was initially intended to be “a better C,” Kotlin was initially oriented towards being “a better Java.” It has since evolved significantly beyond that goal. Kotlin’s design philosophy sets it apart from virtually all its predecessors, because it explicitly avoids inventing new language features to solve perceived problems. Instead, it chooses the most successful and helpful features from other programming languages— after those features have been field-tested and proven to be especially valuable. ²⁰ http://www.AtomicScala.com Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Why Kotlin? 20 Thus, if you are coming from another language, you might recognize some features of that language in Kotlin. This is intentional: Kotlin maximizes productivity by leveraging tested concepts. This atom does not assume you are a programmer, which makes it hard to explain most of the benefits of Kotlin over the alternatives. There are, however, two topics which are very impactful and can also be explained at this early juncture: Java interoperability and the issue of indicating “no value.” Effortless Java Interoperability To be “a better C,” C++ must be backwards compatible with the syntax of C, but Kotlin does not have to be backwards compatible with the syntax of Java—it only needs to work with the JVM. This frees the Kotlin designers to create a much cleaner and more powerful syntax, without the visual noise and complication that clutters Java. For Kotlin to be “a better Java,” the experience of trying it must be pleasant and frictionless, so Kotlin enables effortless integration with existing Java projects. You can write a small piece of Kotlin functionality and slip it in amidst your existing Java code. The Java code doesn’t even know the Kotlin code is there—it just looks like more Java code. Companies often investigate a new language by building a standalone program with that language. Ideally, this program is beneficial but nonessential, so if the project fails it can be terminated with minimal damage. Not every company wants to spend the kind of resources necessary for this type of experimentation. Because Kotlin seamlessly integrates into an existing Java system (and benefits from that system’s tests), it becomes very cheap or even free to try Kotlin to see whether it’s a good fit. In addition, JetBrains, the company that creates Kotlin, provides IntelliJ IDEA in a “Community” (free) version, which includes support for both Java and Kotlin along with the ability to easily integrate the two. It even has a tool that takes Java code and (mostly) rewrites it to Kotlin. Appendix B covers Java interoperability. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Why Kotlin? 21 Representing Emptiness An especially beneficial Kotlin feature is its solution to a challenging programming problem. What do you do when someone hands you a dictionary and asks you to look up a word that doesn’t exist? You could guarantee results by making up definitions for unknown words. A more useful approach is just to say, “There’s no definition for that word.” This demonstrates a significant problem in programming: How do you indicate “no value” for a piece of storage that is uninitialized, or for the result of an operation? The null reference was invented in 1965 for ALGOL by Tony Hoare, who later called it “my billion-dollar mistake.” One problem was that it was too simple—sometimes being told a room is empty isn’t enough; you might need to know, for example, why it is empty. This leads to the second problem: the implementation. For efficiency’s sake, it was typically just a special value that could fit in a small amount of memory, and what better than the memory that had already been allocated for that information? The original C language did not automatically initialize storage, which caused numerous problems. C++ improved the situation by setting newly-allocated storage to all zeroes. Thus, if a numerical value isn’t initialized, it is simply a numerical zero. This didn’t seem so bad but it allowed uninitialized values to quietly slip through the cracks (newer C and C++ compilers often warn you about these). Worse, if a piece of storage was a pointer —used to indicate (“point to”) another piece of storage—a null pointer would point at location zero in memory, which is almost certainly not what you want. Java prevents accesses to uninitialized values by reporting the error when the program is running (that is, at runtime ). Although this discovers uninitialized values, it doesn’t solve the problem because the only way you can verify that your program won’t crash is by running it. There are swarms of these kinds of bugs in Java code, and programmers waste huge amounts of time finding them. Kotlin solves this problem by preventing operations that might cause null errors before the program can run . This is the single-most celebrated feature by Java programmers adopting Kotlin. This one feature can minimize or eliminate Java’s null errors. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Why Kotlin? 22 An Abundance of Benefits The two features we were able to explain here (without requiring more programming knowledge) make a huge difference whether or not you’re a Java programmer. If Kotlin is your first language and you end up on a project that needs more programmers, it is much easier to recruit one of the many existing Java programmers into Kotlin. Kotlin has many other benefits, which we cannot explain until you know more about programming. That’s what the rest of the book is for. Languages are often selected by passion, not reason…I’m trying to make Kotlin a language that is loved for a reason. —Andrey Breslav, Kotlin Lead Language Designer. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Hello, World! “Hello, world!” is a program commonly used to demonstrate the basic syntax of programming languages. We develop this program in several steps so you understand its parts. First, let’s examine an empty program that does nothing at all: // HelloWorld/EmptyProgram.kt fun main () { // Program code here ... } The example starts with a comment , which is illuminating text that is ignored by Kotlin. // (two forward slashes) begins a comment that goes to the end of the current line: // Single-line comment Kotlin ignores the // and everything after it until the end of the line. On the following line, it pays attention again. The first line of each example in this book is a comment starting with the name of the the subdirectory containing the source-code file (Here, HelloWorld ) followed by the name of the file: EmptyProgram.kt . The example subdirectory for each atom corresponds to the name of that atom. keywords are reserved by the language and given special meaning. The keyword fun is short for function . A function is a collection of code that can be executed using that function’s name (we spend a lot of time on functions throughout the book). The function’s name follows the fun keyword, so in this case it’s main() (in prose, we follow the function name with parentheses). main() is actually a special name for a function; it indicates the “entry point” for a Kotlin program. A Kotlin program can have many functions with many different ","Hello, World! 24 names, but main() is the one that’s automatically called when you execute the program. The parameter list follows the function name and is enclosed by parentheses. Here, we don’t pass anything into main() so the parameter list is empty. The function body appears after the parameter list. It begins with an opening brace ( { ) and ends with a closing brace ( } ). The function body contains statements and expressions . A statement produces an effect, and an expression yields a result. EmptyProgram.kt contains no statements or expressions in the body, just a com-ment. Let’s make the program display “Hello, world!” by adding a line in the main() body: // HelloWorld/HelloWorld.kt fun main () { println( Hello, world! ) } /* Output: Hello, world! */ The line that displays the greeting begins with println() . Like main() , println() is a function. This line calls the function, which executes its body. You give the function name, followed by parentheses containing one or more parameters. In this book, when referring to a function in the prose, we add parentheses after the name as a reminder that it is a function. Here, we say println() . println() takes a single parameter, which is a String . You define a String by putting characters inside quotes. println() moves the cursor to a new line after displaying its parameter, so subsequent output appears on the next line. You can use print() instead, which leaves the cursor on the same line. Unlike some languages, you don’t need a semicolon at the end of an expression in Kotlin. It’s only necessary if you put more than one expression on a single line (this is discouraged). For some examples in the book, we show the output at the end of the listing, inside a multiline comment . A multiline comment starts with a /* (a forward slash followed Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Hello, World! 25 by an asterisk) and continues—including line breaks (which we call newlines )—until a */ (an asterisk followed by a forward slash) ends the comment: /* A multiline comment Doesn't care about newlines */ It’s possible to add code on the same line after the closing */ of a comment, but it’s confusing, so people don’t usually do it. Comments add information that isn’t obvious from reading the code. If comments only repeat what the code says, they become annoying and people start ignoring them. When code changes, programmers often forget to update comments, so it’s good practice to use comments judiciously, mainly for highlighting tricky aspects of your code. Exercises and solutions for this atom can be found at AtomicKotlin.com ²¹ . ²¹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","var & val When an identifier holds data, you must decide whether it can be reas-signed. You create identifiers to refer to elements in your program. The most basic decision for a data identifier is whether it can change its contents during program execution, or if it can only be assigned once. This is controlled by two keywords: • var , short for variable , which means you can reassign its contents. • val , short for value , which means you can only initialize it; you cannot reassign it. You define a var like this: var identifier = initialization The var keyword is followed by the identifier, an equals sign and then the initializa-tion value. The identifier begins with a letter or an underscore, followed by letters, numbers and underscores. Upper and lower case are distinguished (so thisvalue and thisValue are different). Here are some var definitions: // VarAndVal/Vars.kt fun main () { var whole = 11 // [1] var fractional = 1.4 // [2] var words = Twas Brillig // [3] println(whole) println(fractional) println(words) } /* Output: 11 1.4 Twas Brillig */ ","var & val 27 In this book we mark lines with commented numbers in square brackets so we can refer to them in the text like this: • [1] Create a var named whole and store 11 in it. • [2] Store the “fractional number” 1.4 in the var fractional . • [3] Store some text (a String ) in the var words . Note that println() can take any single value as an argument. As the name variable implies, a var can vary. That is, you can change the data stored in a var . We say that a var is mutable : // VarAndVal/AVarIsMutable.kt fun main () { var sum = 1 sum = sum + 2 sum += 3 println(sum) } /* Output: 6 */ The assignment sum = sum + 2 takes the current value of sum , adds two, and assigns the result back into sum . The assignment sum += 3 means the same as sum = sum + 3 . The += operator takes the previous value stored in sum and increases it by 3 , then assigns that new result back to sum . Changing the value stored in a var is a useful way to express changes. However, when the complexity of a program increases, your code is clearer, safer and easier to understand if the values represented by your identifiers cannot change—that is, they cannot be reassigned. We specify an unchanging identifier using the val keyword instead of var .A val can only be assigned once, when it is created: val identifier = initialization The val keyword comes from value , indicating something that cannot change—it is immutable . Choose val instead of var whenever possible. The Vars.kt example at the beginning of this atom can be rewritten using val s: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","var & val 28 // VarAndVal/Vals.kt fun main () { val whole = 11 // whole = 15 // Error // [1] val fractional = 1.4 val words = Twas Brillig println(whole) println(fractional) println(words) } /* Output: 11 1.4 Twas Brillig */ • [1] Once you initialize a val , you can’t reassign it. If we try to reassign whole to a different number, Kotlin complains, saying “Val cannot be reassigned.” Choosing descriptive names for your identifiers makes your code easier to under-stand and often reduces the need for comments. In Vals.kt , you have no idea what whole represents. If your program is storing the number 11 to represent the time of day when you get coffee, it’s more obvious to others if you name it coffeetime and easier to read if it’s coffeeTime (following Kotlin style, we make the first letter lowercase). var s are useful when data must change as the program is running. This sounds like a common requirement, but turns out to be avoidable in practice. In general, your programs are easier to extend and maintain if you use val s. However, on rare occasions it’s too complex to solve a problem using only val s. For that reason, Kotlin gives you the flexibility of var s. However, as you spend more time with val s you’ll discover that you almost never need var s and that your programs are safer and more reliable without them. Exercises and solutions for this atom can be found at AtomicKotlin.com ²² . ²² https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Data Types Data can have different types . To solve a math problem, you write an expression: 5.9 + 6 You know that adding those numbers produces another number. Kotlin knows that too. You know that one is a fractional number ( 5.9 ), which Kotlin calls a Double , and the other is a whole number ( 6 ), which Kotlin calls an Int . You know the result is a fractional number. A type (also called data type ) tells Kotlin how you intend to use that data. A type provides a set of values from which an expression may take its values. A type defines the operations that can be performed on the data, the meaning of the data, and how values of that type can be stored. Kotlin uses types to verify that your expressions are correct. In the above expression, Kotlin creates a new value of type Double to hold the result. Kotlin tries to adapt to what you need. If you ask it to do something that violates type rules it produces an error message. For example, try adding a String and a number: // DataTypes/StringPlusNumber.kt fun main () { println( Sally + 5.9 ) } /* Output: Sally5.9 */ Types tell Kotlin how to use them correctly. In this case, the type rules tell Kotlin how to add a number to a String : by appending the two values and creating a String to hold the result. Now try multiplying a String and a Double by changing the + in StringPlusNum-ber.kt to a * : ","Data Types 30 Sally * 5.9 Combining types this way doesn’t make sense to Kotlin, so it gives you an error. In var & val , we stored several types. Kotlin figured out the types for us, based on how we used them. This is called type inference . We can be more verbose and specify the type: val identifier: Type = initialization You start with the val or var keyword, followed by the identifier, a colon, the type, an = , and the initialization value. So instead of saying: val n= 1 var p= 1.2 You can say: val n: Int = 1 var p: Double = 1.2 We’ve told Kotlin that n is an Int and p is a Double , rather than letting it infer the type. Here are some of Kotlin’s basic types: // DataTypes/Types.kt fun main () { val whole: Int = 11 // [1] val fractional: Double = 1.4 // [2] val trueOrFalse: Boolean = true // [3] val words: String = A value // [4] val character: Char = 'z' // [5] val lines: String = Triple quotes let you have many lines in your string  // [6] println(whole) println(fractional) println(trueOrFalse) println(words) println(character) Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Data Types 31 println(lines) } /* Output: 11 1.4 true A value z Triple quotes let you have many lines in your string */ • [1] The Int data type is an integer , which means it only holds whole numbers. • [2] To hold fractional numbers, use a Double . • [3] A Boolean data type only holds the two special values true and false . • [4] A String holds a sequence of characters. You assign a value using a double-quoted String . • [5] A Char holds one character. • [6] If you have many lines and/or special characters, surround them with triple-double-quotes (this is a triple-quoted String ). Kotlin uses type inference to determine the meaning of mixed types. When mixing Int s and Double s during addition, for example, Kotlin decides the type for the resulting value: // DataTypes/Inference.kt fun main () { val n= 1 + 1.2 println(n) } /* Output: 2.2 */ When you add an Int to a Double using type inference, Kotlin determines that the result n is a Double and ensures that it follows all the rules for Double s. Kotlin’s type inference is part of its strategy of doing work for the programmer. If you leave out the type declaration, Kotlin can usually infer it. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Data Types 32 Exercises and solutions for this atom can be found at AtomicKotlin.com ²³ . ²³ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Functions A function is like a small program that has its own name, and can be executed ( invoked ) by calling that name from another function. A function combines a group of activities, and is the most basic way to organize your programs and to re-use code. You pass information into a function, and the function uses that information to calculate and produce a result. The basic form of a function is: fun functionName (p1: Type1, p2: Type2, ...): ReturnType { lines of code return result } p1 and p2 are the parameters : the information you pass into the function. Each parameter has an identifier name ( p1 , p2 ) followed by a colon and the type of that parameter. The closing parenthesis of the parameter list is followed by a colon and the type of result produced by the function. The lines of code in the function body are enclosed in curly braces. The expression following the return keyword is the result the function produces when it’s finished. A parameter is how you define what is passed into a function—it’s the placeholder. An argument is the actual value that you pass into the function. The combination of name, parameters and return type is called the function signa-ture . Here’s a simple function called multiplyByTwo() : ","Functions 34 // Functions/MultiplyByTwo.kt fun multiplyByTwo (x: Int): Int { // [1] println( Inside multiplyByTwo ) // [2] return x* 2 } fun main () { val r = multiplyByTwo( 5 ) // [3] println(r) } /* Output: Inside multiplyByTwo 10 */ • [1] Notice the fun keyword, the function name, and the parameter list consist-ing of a single parameter. This function takes an Int parameter and returns an Int . • [2] These two lines are the body of the function. The final line returns the value of its calculation x*2 as the result of the function. • [3] This line calls the function with an appropriate argument, and captures the result into val r . A function call mimics the form of its declaration: the function name, followed by arguments inside parentheses. The function code is executed by calling the function, using the function name multiplyByTwo() as an abbreviation for that code. This is why functions are the most basic form of simplification and code reuse in programming. You can also think of a function as an expression with substitutable values (the parameters). println() is also a function call—it just happens to be provided by Kotlin. We refer to functions defined by Kotlin as library functions . If the function doesn’t provide a meaningful result, its return type is Unit . You can specify Unit explicitly if you want, but Kotlin lets you omit it: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Functions 35 // Functions/SayHello.kt fun sayHello () { println( Hallo! ) } fun sayGoodbye (): Unit { println( Auf Wiedersehen! ) } fun main () { sayHello() sayGoodbye() } /* Output: Hallo! Auf Wiedersehen! */ Both sayHello() and sayGoodbye() return Unit , but sayHello() leaves out the explicit declaration. The main() function also returns Unit . If a function is only a single expression, you can use the abbreviated syntax of an equals sign followed by the expression: fun functionName (arg1: Type1, arg2: Type2, ...): ReturnType = expression A function body surrounded by curly braces is called a block body . A function body using the equals syntax is called an expression body . Here, multiplyByThree() uses an expression body: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Functions 36 // Functions/MultiplyByThree.kt fun multiplyByThree (x: Int): Int = x * 3 fun main () { println(multiplyByThree( 5 )) } /* Output: 15 */ This is a short version of saying return x * 3 inside a block body. Kotlin infers the return type of a function that has an expression body: // Functions/MultiplyByFour.kt fun multiplyByFour (x: Int) = x * 4 fun main () { val result: Int = multiplyByFour( 5 ) println(result) } /* Output: 20 */ Kotlin infers that multiplyByFour() returns an Int . Kotlin can only infer return types for expression bodies. If a function has a block body and you omit its type, that function returns Unit . When writing functions, choose descriptive names. This makes the code easier to read, and can often reduce the need for code comments. We can’t always be as descriptive as we would prefer with the function names in this book because we’re constrained by line widths. Exercises and solutions for this atom can be found at AtomicKotlin.com ²⁴ . ²⁴ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","if Expressions An if expression makes a choice. The if keyword tests an expression to see whether it’s true or false and performs an action based on the result. A true-or-false expression is called a Boolean , after the mathematician George Boole who invented the logic behind these expressions. Here’s an example using the > (greater than) and < (less than) symbols: // IfExpressions/If1.kt fun main () { if ( 1 > 0 ) println( It's true! ) if ( 10 < 11 ){ println( 10 < 11 ) println( ten is less than eleven ) } } /* Output: It's true! 10 < 11 ten is less than eleven */ The expression inside the parentheses after the if must evaluate to true or false . If true , the following expression is executed. To execute multiple lines, place them within curly braces. We can create a Boolean expression in one place, and use it in another: ","if Expressions 38 // IfExpressions/If2.kt fun main () { val x: Boolean = 1 >= 1 if (x) println( It's true! ) } /* Output: It's true! */ Because x is Boolean , the if can test it directly by saying if(x) . The Boolean >= operator returns true if the expression on the left side of the operator is greater than or equal to that on the right. Likewise, <= returns true if the expression on the left side is less than or equal to that on the right. The else keyword allows you to handle both true and false paths: // IfExpressions/If3.kt fun main () { val n: Int = -11 if (n > 0 ) println( It's positive ) else println( It's negative or zero ) } /* Output: It's negative or zero */ The else keyword is only used in conjunction with if . You are not limited to a single check—you can test multiple combinations by combining else and if : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","if Expressions 39 // IfExpressions/If4.kt fun main () { val n: Int = -11 if (n > 0 ) println( It's positive ) else if (n == 0 ) println( It's zero ) else println( It's negative ) } /* Output: It's negative */ Here we use == to check two numbers for equality. != tests for inequality. The typical pattern is to start with if , followed by as many else if clauses as you need, ending with a final else for anything that doesn’t match all the previous tests. When an if expression reaches a certain size and complexity you’ll probably use a when expression instead. when is described later in the book, in when Expressions . The “not” operator ! tests for the opposite of a Boolean expression: // IfExpressions/If5.kt fun main () { val y: Boolean = false if (!y) println( !y is true ) } /* Output: !y is true */ To verbalize if(!y) , say “if not y.” The entire if is an expression, so it can produce a result: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","if Expressions 40 // IfExpressions/If6.kt fun main () { val num = 10 val result = if (num > 100 ) 4 else 42 println(result) } /* Output: 42 */ Here, we store the value produced by the entire if expression in an intermediate identifier called result . If the condition is satisfied, the first branch produces result . If not, the else value becomes result . Let’s practice creating functions. Here’s one that takes a Boolean parameter: // IfExpressions/TrueOrFalse.kt fun trueOrFalse (exp: Boolean): String { if (exp) return It's true! // [1] return It's false } fun main () { val b= 1 println(trueOrFalse(b < 3 )) println(trueOrFalse(b >= 3 )) } /* Output: It's true! It's false */ • [1] Notice that return is not restricted to the end of the function. It says, “Leave this function and return this value.” The Boolean parameter exp is passed to the function trueOrFalse() . If the argument is passed as an expression, such as b<3 , that expression is first evaluated and the result is passed to the function. Here, exp is tested and if it is true , the following line is executed. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","if Expressions 41 Rather than using return as in the previous example, you can use the else keyword to produce the result as an expression: // IfExpressions/OneOrTheOther.kt fun oneOrTheOther (exp: Boolean): String = if (exp) True! // No 'return' necessary else False fun main () { val x= 1 println(oneOrTheOther(x == 1 )) println(oneOrTheOther(x == 2 )) } /* Output: True! False */ Instead of two expressions in trueOrFalse() , oneOrTheOther() is a single expres-sion. The result of that expression is the result of the function, so the if expression becomes the function body. Exercises and solutions for this atom can be found at AtomicKotlin.com ²⁵ . ²⁵ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","String Templates A String template is a programmatic way of generating a String . If you put a $ before an identifier name, the String template will insert that identifier’s contents into the String : // StringTemplates/StringTemplates.kt fun main () { val answer = 42 println( Found $answer! ) // [1] println( printing a $1 ) // [2] } /* Output: Found 42! printing a $1 */ • [1] $answer substitutes the value of answer . • [2] If what follows the $ isn’t recognizable as a program identifier, nothing special happens. You can also insert values into a String using concatenation ( + ): // StringTemplates/StringConcatenation.kt fun main () { val s= hin // n is a newline character val n= 11 val d= 3.14 println( first:  +s+ second:  + n+ , third:  + d) } /* Output: first: hi second: 11, third: 3.14 */ ","String Templates 43 The println() arguments are on two lines to keep the code listing narrow. Placing an expression inside ${} evaluates it. The return value is converted to a String and inserted into the resulting String : // StringTemplates/ExpressionInTemplate.kt fun main () { val condition = true println( ${if (condition) 'a' else 'b'} ) // [1] val x= 11 println( $x + 4 = ${x + 4} ) } /* Output: a 11 + 4 = 15 */ • [1] if(condition) 'a' else 'b' is evaluated and the result is substituted for the entire ${} expression. When a String must include a special character, such as a quote, you can either escape that character with a  ( backslash ), or use a String literal in triple quotes: // StringTemplates/TripleQuotes.kt fun main () { val s= value println( s = $s. ) println( s =  $ s . ) } /* Output: s = value. s = value. */ With triple quotes, you insert a value of an expression the same way you do it for a single-quoted String . Exercises and solutions for this atom can be found at AtomicKotlin.com ²⁶ . ²⁶ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Number Types Different types of numbers are stored in different ways. If you create an identifier and assign an integer value to it, Kotlin infers the Int type: // NumberTypes/InferInt.kt fun main () { val million = 1 _000_000 // Infers Int println(million) } /* Output: 1000000 */ For readability, Kotlin allows underscores within numerical values. The basic mathematical operators for numbers are the ones available in most programming languages: addition ( + ), subtraction ( -), division ( / ), multiplication ( * ) and modulus ( % ), which produces the remainder from integer division: // NumberTypes/Modulus.kt fun main () { val numerator: Int = 19 val denominator: Int = 10 println(numerator % denominator) } /* Output: 9 */ Integer division truncates its result: ","Number Types 45 // NumberTypes/IntDivisionTruncates.kt fun main () { val numerator: Int = 19 val denominator: Int = 10 println(numerator / denominator) } /* Output: 1 */ If the operation had rounded the result, the output would be 2 . The order of operations follows basic arithmetic: // NumberTypes/OpOrder.kt fun main () { println( 45 + 5 * 6 ) } /* Output: 75 */ The multiplication operation 5*6 is performed first, followed by the addition 45 + 30 . If you want 45 + 5 to happen first, use parentheses: // NumberTypes/OpOrderParens.kt fun main () { println(( 45 + 5 )* 6 ) } /* Output: 300 */ Now let’s calculate body mass index (BMI), which is weight in kilograms divided by the square of the height in meters. If you have a BMI of less than 18.5 , you are underweight. Between 18.5 and 24.9 is normal weight. BMI of 25 and higher is overweight. This example also shows the preferred formatting style when you can’t fit the function’s parameters on a single line: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Number Types 46 // NumberTypes/BMIMetric.kt fun bmiMetric ( weight: Double, height: Double ): String { val bmi = weight / (height * height) // [1] return if (bmi < 18.5 ) Underweight else if (bmi < 25 ) Normal weight else Overweight } fun main () { val weight = 72.57 // 160 lbs val height = 1.727 // 68 inches val status = bmiMetric(weight, height) println(status) } /* Output: Normal weight */ • [1] If you remove the parentheses, you divide weight by height then multiply that result by height . That’s a much larger number, and the wrong answer. bmiMetric() uses Double s for the weight and height. A Double holds very large and very small floating-point numbers. Here’s a version using English units, represented by Int parameters: // NumberTypes/BMIEnglish.kt fun bmiEnglish ( weight: Int, height: Int ): String { val bmi = weight / (height * height) * 703.07 // [1] return if (bmi < 18.5 ) Underweight else if (bmi < 25 ) Normal weight else Overweight } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Number Types 47 fun main () { val weight = 160 val height = 68 val status = bmiEnglish(weight, height) println(status) } /* Output: Underweight */ Why does the result differ from bmiMetric() , which uses Double s? When you divide an integer by another integer, Kotlin produces an integer result. The standard way to deal with the remainder during integer division is truncation , meaning “chop it off and throw it away” (there’s no rounding). So if you divide 5 by 2 you get 2 , and 7/10 is zero. When Kotlin calculates bmi in expression [1] , it divides 160 by 68 * 68 and gets zero. It then multiplies zero by 703.07 to get zero. To avoid this problem, move 703.07 to the front of the calculation. The calculations are then forced to be Double : val bmi = 703.07 * weight / (height * height) The Double parameters in bmiMetric() prevent this problem. Convert computa-tions to the desired type as early as possible to preserve accuracy. All programming languages have limits to what they can store within an integer. Kotlin’s Int type can take values between -2³¹ and +2³¹-1, a constraint of the Int 32-bit representation. If you sum or multiply two Int s that are big enough, you’ll overflow the result: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Number Types 48 // NumberTypes/IntegerOverflow.kt fun main () { val i: Int = Int.MAX_VALUE println(i + i) } /* Output: -2 */ Int.MAX_VALUE is a predefined value which is the largest number an Int can hold. The overflow produces a result that is clearly incorrect, as it is both negative and much smaller than we expect. Kotlin issues a warning whenever it detects a potential overflow. Preventing overflow is your responsibility as a developer. Kotlin can’t always detect overflow during compilation, and it doesn’t prevent overflow because that would produce an unacceptable performance impact. If your program contains large numbers, you can use Long s, which accommodate values from -2⁶³ to +2⁶³-1. To define a val of type Long , you can specify the type explicitly or put L at the end of a numeric literal, which tells Kotlin to treat that value as a Long : // NumberTypes/LongConstants.kt fun main () { val i= 0 // Infers Int val l1 = 0L // L creates Long val l2: Long = 0 // Explicit type println( $l1 $l2 ) } /* Output: 00 */ By changing to Long s we prevent the overflow in IntegerOverflow.kt : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Number Types 49 // NumberTypes/UsingLongs.kt fun main () { val i = Int.MAX_VALUE println( 0L +i+i) // [1] println( 1 _000_000 * 1 _000_000L) // [2] } /* Output: 4294967294 1000000000000 */ Using a numeric literal in both [1] and [2] forces Long calculations, and also produces a result of type Long . The location where the L appears is unimportant. If one of the values is Long , the resulting expression is Long . Although they can hold much larger values than Int s, Long s still have size limita-tions: // NumberTypes/BiggestLong.kt fun main () { println(Long.MAX_VALUE) } /* Output: 9223372036854775807 */ Long.MAX_VALUE is the largest value a Long can hold. Exercises and solutions for this atom can be found at AtomicKotlin.com ²⁷ . ²⁷ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Booleans if Expressions demonstrated the “not” operator ! , which negates a Boolean value. This atom introduces more Boolean Algebra . We start with the operators “and” and “or”: • && (and): Produces true only if the Boolean expression on the left of the operator and the one on the right are both true . • || (or): Produces true if either the expression on the left or right of the operator is true , or if both are true . In this example, we determine whether a business is open or closed, based on the hour : // Booleans/Open1.kt fun isOpen1 (hour: Int) { val open = 9 val closed = 20 println( Operating hours: $open - $closed ) val status = if (hour >= open && hour <= closed) // [1] true else false println( Open: $status ) } fun main () = isOpen1( 6 ) /* Output: Operating hours: 9 - 20 Open: false */ ","Booleans 51 main() is a single function call, so we can use an expression body as described in Functions . The if expression in [1] Checks whether hour is between the opening time and closing time, so we combine the expressions with the Boolean && (and). The if expression can be simplified. The result of the expression if(cond) true else false is just cond : // Booleans/Open2.kt fun isOpen2 (hour: Int) { val open = 9 val closed = 20 println( Operating hours: $open - $closed ) val status = hour >= open && hour <= closed println( Open: $status ) } fun main () = isOpen2( 6 ) /* Output: Operating hours: 9 - 20 Open: false */ Let’s reverse the logic and check whether the business is currently closed. The “or” operator || produces true if at least one of the conditions is satisfied: // Booleans/Closed.kt fun isClosed (hour: Int) { val open = 9 val closed = 20 println( Operating hours: $open - $closed ) val status = hour < open || hour > closed println( Closed: $status ) } fun main () = isClosed( 6 ) /* Output: Operating hours: 9 - 20 Closed: true */ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Booleans 52 Boolean operators enable complicated logic in compact expressions. However, things can easily become confusing. Strive for readability and specify your intentions explicitly. Here’s an example of a complicated Boolean expression where different evaluation order produces different results: // Booleans/EvaluationOrder.kt fun main () { val sunny = true val hoursSleep = 6 val exercise = false val temp = 55 // [1]: val happy1 = sunny && temp > 50 || exercise && hoursSleep > 7 println(happy1) // [2]: val sameHappy1 = (sunny && temp > 50 ) || (exercise && hoursSleep > 7 ) println(sameHappy1) // [3]: val notSame = (sunny && temp > 50 || exercise) && hoursSleep > 7 println(notSame) } /* Output: true true false */ The Boolean expressions are sunny , temp > 50 , exercise , and hoursSleep > 7 . We read happy1 as “It’s sunny and the temperature is greater than 50 or I’ve exercised and had more than 7 hours of sleep.” But does && have precedence over || , or the opposite? Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Booleans 53 The expression in [1] uses Kotlin’s default evaluation order. This produces the same result as the expression in [2] because, without parentheses, the “ands” are evaluated first, then the “or”. The expression in [3] uses parentheses to produce a different result. In [3] , we’re only happy if we get at least 7 hours of sleep. Exercises and solutions for this atom can be found at AtomicKotlin.com ²⁸ . ²⁸ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Repetition with while Computers are ideal for repetitive tasks. The most basic form of repetition uses the while keyword. This repeats a block as long as the controlling Boolean expression is true : while (Boolean-expression) { // Code to be repeated } The Boolean expression is evaluated once at the beginning of the loop and again before each further iteration through the block. // RepetitionWithWhile/WhileLoop.kt fun condition (i: Int) = i < 100 // [1] fun main () { var i= 0 while (condition(i)) { print( . ) i += 10 // [2] } } /* Output: .......... */ • [1] The comparison operator < produces a Boolean result, so Kotlin infers Boolean as the result type for condition() . The conditional expression for the while says: “repeat the statements in the body as long as condition() returns true .” • [2] The += operator adds 10 to i and assigns the result to i in a single operation ( i must be a var for this to work). This is equivalent to: ","Repetition with while 55 i=i+ 10 There’s a second way to use while , in conjunction with the do keyword: do { // Code to be repeated } while (Boolean-expression) Rewriting WhileLoop.kt to use a do-while produces: // RepetitionWithWhile/DoWhileLoop.kt fun main () { var i= 0 do { print( . ) i += 10 } while (condition(i)) } /* Output: .......... */ The sole difference between while and do-while is that the body of the do-while always executes at least once, even if the Boolean expression initially produces false . In a while , if the conditional is false the first time, then the body never executes. In practice, do-while is less common than while . The short versions of assignment operators are available for all the arithmetic operations: += , -= , *= , /= , and %= . Here, we see -= and %= in use: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Repetition with while 56 // RepetitionWithWhile/AssignmentOperators.kt fun main () { var n= 10 val d= 3 print(n) while (n > d) { n -= d print(  - $d ) } println(  = $n ) var m= 10 print(m) m %= d println(  % $d = $m ) } /* Output: 10-3-3-3=1 10%3=1 */ To calculate the remainder of the integer division of two natural numbers, we start with a while loop, then use the remainder operator. Adding 1 and subtracting 1 from a number are so common that they have their own increment and decrement operators: ++ and --. You can replace i += 1 with i++ : // RepetitionWithWhile/IncrementOperator.kt fun main () { var i= 0 while (i < 4 ){ print( . ) i++ } } /* Output: .... */ In practice, while loops are not used for iterating over a range of numbers. The for loop is used instead. This is covered in the next atom. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Repetition with while 57 Exercises and solutions for this atom can be found at AtomicKotlin.com ²⁹ . ²⁹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Looping & Ranges The for keyword executes a block of code for each value in a sequence. The set of values can be a range of integers, a String , or, as you’ll see later in the book, a collection of items. The in keyword indicates that you are stepping through values: for (v in values) { // Do something with v } Each time through the loop, v is given the next element in values . Here, a for loop repeats an action a fixed number of times: // LoopingAndRanges/RepeatThreeTimes.kt fun main () { for (i in 1. . 3 ){ println( Hey $i! ) } } /* Output: Hey 1! Hey 2! Hey 3! */ The output shows the index i receiving each value in the range from 1 to 3. A range is an interval of values defined by a pair of endpoints. There are two basic ways to define ranges: ","Looping & Ranges 59 // LoopingAndRanges/DefiningRanges.kt fun main () { val range1 = 1. . 10 // [1] val range2 = 0 until 10 // [2] println(range1) println(range2) } /* Output: 1..10 0..9 */ • [1] Using .. syntax includes both bounds in the resulting range. • [2] until excludes the end. The output shows that 10 is not part of the range. Displaying a range produces a readable format. Here, we sum the numbers from 10 to 100: // LoopingAndRanges/SumUsingRange.kt fun main () { var sum = 0 for (n in 10. . 100 ){ sum += n } println( sum = $sum ) } /* Output: sum = 5005 */ You can iterate over a range in reverse order. You can also use a step value to change the interval from the default of 1 : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Looping & Ranges 60 // LoopingAndRanges/ForWithRanges.kt fun showRange (r: IntProgression) { for (i in r) { print( $i  ) } print(  // $r ) println() } fun main () { showRange( 1. . 5 ) showRange( 0 until 5 ) showRange( 5 downTo 1 ) // [1] showRange( 0. . 9 step 2 ) // [2] showRange( 0 until 10 step 3 ) // [3] showRange( 9 downTo 2 step 3 ) } /* Output: 12345 // 1..5 01234 // 0..4 54321 // 5 downTo 1 step 1 02468 // 0..8 step 2 0369 // 0..9 step 3 963 // 9 downTo 3 step 3 */ • [1] downTo produces a decreasing range. • [2] step changes the interval. Here, the range steps by a value of two instead of one. • [3] until can also be used with step . Notice how this affects the output. In each case, the sequence of numbers form an arithmetic progression, so showRange() accepts an IntProgression parameter, which is a built-in type that includes Int ranges. You can also produce a range of characters. Here, we iterate from a to z using for : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Looping & Ranges 61 // LoopingAndRanges/ForWithCharRange.kt fun main () { for (c in 'a' .. 'z' ){ print(c) } } /* Output: abcdefghijklmnopqrstuvwxyz */ You can iterate over a range of elements that are whole quantities, like integers and characters, but not floating-point values. Square brackets access characters by index. Because we start counting characters in a String at zero, s[0] selects the first character of the String s . Selecting s.lastIndex produces the final index number: // LoopingAndRanges/IndexIntoString.kt fun main () { val s= abc for (i in 0. .s.lastIndex) { print(s[i] + 1 ) } } /* Output: bcd */ Sometimes people describe s[0] as “the zeroth character.” Characters are stored as numbers corresponding to their ASCII codes³⁰ , so adding an integer to a character produces a new character corresponding to the new code value: ³⁰ https://en.wikipedia.org/wiki/ASCII Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Looping & Ranges 62 // LoopingAndRanges/AddingIntToChar.kt fun main () { val ch: Char = 'a' println(ch + 25 ) println(ch < 'z' ) } /* Output: z true */ The second println() shows that you can compare character codes. A for loop can iterate over String s directly: // LoopingAndRanges/IterateOverString.kt fun main () { for (ch in Jnskhm  ){ print(ch + 1 ) } } /* Output: Kotlin! */ ch receives each character in turn. In the following example, the function hasChar() iterates over the String s and tests whether it contains a given character ch . The return in the middle of the function stops the function when the answer is found: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Looping & Ranges 63 // LoopingAndRanges/HasChar.kt fun hasChar (s: String, ch: Char): Boolean { for (c in s) { if (c == ch) return true } return false } fun main () { println(hasChar( kotlin , 't' )) println(hasChar( kotlin , 'a' )) } /* Output: true false */ The next atom shows that hasChar() is unnecessary—you can use built-in syntax instead. If you simply want to repeat an action a fixed number of times, you may use repeat() instead of a for loop: // LoopingAndRanges/Repeat.kt fun main () { repeat( 2 ){ println( hi! ) } } /* Output: hi! hi! */ repeat() is a standard library function, not a keyword. You’ll see how it was created much later in the book. Exercises and solutions for this atom can be found at AtomicKotlin.com ³¹ . ³¹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","The in Keyword The in keyword tests whether a value is within a range. // InKeyword/MembershipInRange.kt fun main () { val percent = 35 println(percent in 1. . 100 ) } /* Output: true */ In Booleans , you learned to check bounds explicitly: // InKeyword/MembershipUsingBounds.kt fun main () { val percent = 35 println( 0 <= percent && percent <= 100 ) } /* Output: true */ 0 <= x && x <= 100 is logically equivalent to x in 0..100 . IntelliJ IDEA sug-gests automatically replacing the first form with the second, which is easier to read and understand. The in keyword is used for both iteration and membership. An in inside the control expression of a for loop means iteration, otherwise in checks membership: ","The in Keyword 65 // InKeyword/IterationVsMembership.kt fun main () { val values = 1. . 3 for (v in values) { println( iteration $v ) } val v= 2 if (v in values) println( $v is a member of $values ) } /* Output: iteration 1 iteration 2 iteration 3 2 is a member of 1..3 */ The in keyword is not limited to ranges. You can also check whether a character is a part of a String . The following example uses in instead of hasChar() from the previous atom: // InKeyword/InString.kt fun main () { println( 't' in kotlin ) println( 'a' in kotlin ) } /* Output: true false */ Later in the book you’ll see that in works with other types, as well. Here, in tests whether a character belongs to a range of characters: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","The in Keyword 66 // InKeyword/CharRange.kt fun isDigit (ch: Char) = ch in '0' .. '9' fun notDigit (ch: Char) = ch ! in '0' .. '9' // [1] fun main () { println(isDigit( 'a' )) println(isDigit( '5' )) println(notDigit( 'z' )) } /* Output: false true true */ • [1] !in checks that a value doesn’t belong to a range. You can create a Double range, but you can only use it to check for membership: // InKeyword/FloatingPointRange.kt fun inFloatRange (n: Double) { val r= 1.0 .. 10.0 println( $n in $r? ${n in r} ) } fun main () { inFloatRange( 0.999999 ) inFloatRange( 5.0 ) inFloatRange( 10.0 ) inFloatRange( 10.0000001 ) } /* Output: 0.999999 in 1.0..10.0? false 5.0 in 1.0..10.0? true 10.0 in 1.0..10.0? true 10.0000001 in 1.0..10.0? false */ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","The in Keyword 67 Floating-point ranges can only be created using .. because until would mean excluding a floating-point number as an endpoint, which doesn’t make sense. You can check whether a String is a member of a range of String s: // InKeyword/StringRange.kt fun main () { println( ab in aa .. az ) println( ba in aa .. az ) } /* Output: true false */ Here we use alphabetic comparison. Exercises and solutions for this atom can be found at AtomicKotlin.com ³² . ³² https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Expressions & Statements Statements and expressions are the smallest useful fragments of code in most programming languages. There’s a basic difference: a statement has an effect, but produces no result. An expression always produces a result. Because it doesn’t produce a result, a statement must change the state of its surroundings to be useful. Another way to say this is “a statement is called for its side effects ” (that is, what it does other than producing a result). As a memory aid: A statement changes state. One definition of “express” is “to force or squeeze out,” as in “to express the juice from an orange.” So An expression expresses. That is, it produces a result. The for loop is a statement in Kotlin. You cannot assign it, since there’s no result: // ExpressionsStatements/ForIsAStatement.kt fun main () { // Can't do this: // val f = for(i in 1..10) {} // Compiler error message: // for is not an expression, and // only expressions are allowed here } ","Expressions & Statements 69 A for loop is used for its side effects. An expression produces a value, which can be assigned or used as part of another expression, whereas a statement is always a top-level element. Every function call is an expression. Even if the function returns Unit and is called only for its side effects, the result can still be assigned: // ExpressionsStatements/UnitReturnType.kt fun unitFun () = Unit fun main () { println(unitFun()) val u1: Unit = println( 42 ) println(u1) val u2 = println( 0 ) // Type inference println(u2) } /* Output: kotlin.Unit 42 kotlin.Unit 0 kotlin.Unit */ The Unit type contains a single value called Unit , which you can return directly, as seen in unitFun() . Calling println() also returns Unit . The val u1 captures the return value of println() and is explicitly declared as Unit while u2 uses type inference. if creates an expression, so you can assign its result: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Expressions & Statements 70 // ExpressionsStatements/AssigningAnIf.kt fun main () { val result1 = if ( 11 > 42 ) 9 else 5 val result2 = if ( 1 < 2 ){ val a= 11 a+ 42 } else 42 val result3 = if ( 'x' < 'y' ) println( x < y ) else println( x > y ) println(result1) println(result2) println(result3) } /* Output: x<y 5 53 kotlin.Unit */ The first output line is x<y , even though result3 isn’t displayed until the end of main() . This happens because evaluating result3 calls println() , and the evaluation occurs when result3 is defined. Notice that a is defined inside the block of code for result2 . The result of the last expression becomes the result of the if expression; here, it’s the sum of 11 and 42. But what about a ? Once you leave the code block (move outside the curly braces), you can’t access a . It is temporary and is discarded once you exit the scope of that block. The increment operator i++ is also an expression, even if it looks like a statement. Kotlin follows the approach used by C-like languages and provides two versions of increment and decrement operators with slightly different semantics. The prefix operator appears before the operand, as in ++i , and returns the value after the Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Expressions & Statements 71 increment happens. You can read it as “first do the increment, then return the resulting value.” The postfix operator is placed after the operand, as in i++ , and returns the value of i before the increment occurs. You can read it as “first produce the result, then do the increment.” // ExpressionsStatements/PostfixVsPrefix.kt fun main () { var i= 10 println(i++) println(i) var j= 20 println(++j) println(j) } /* Output: 10 11 21 21 */ The decrement operator also has two versions: --i and i--. Using increment and decrement operators within other expressions is discouraged because it can produce confusing code: // ExpressionsStatements/Confusing.kt fun main () { var i= 1 println(i++ + ++i) } Try to guess what the output will be, then check it. Exercises and solutions for this atom can be found at AtomicKotlin.com ³³ . ³³ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 1 This atom summarizes and reviews the atoms in Section I, starting at Hello, World! and ending with Expressions & Statements . If you’re an experienced programmer, this should be your first atom. Beginning programmers should read this atom and perform the exercises as a review of Section I. If anything isn’t clear to you, study the associated atom for that topic (the sub-headings correspond to atom titles). Hello, World! Kotlin supports both // single-line comments, and /* -to-*/ multiline comments. A program’s entry point is the function main() : // Summary1/Hello.kt fun main () { println( Hello, world! ) } /* Output: Hello, world! */ The first line of each example in this book is a comment containing the name of the atom’s subdirectory, followed by a / and the name of the file. You can find all the extracted code examples via AtomicKotlin.com . println() is a standard library function which takes a single String parameter (or a parameter that can be converted to a String ). println() moves the cursor to a new line after displaying its parameter, while print() leaves the cursor on the same line. ","Summary 1 73 Kotlin does not require a semicolon at the end of an expression or statement. Semicolons are only necessary to separate multiple expressions or statements on a single line. var & val , Data Types To create an unchanging identifier, use the val keyword followed by the identifier name, a colon, and the type for that value. Then add an equals sign and the value to assign to that val : val identifier: Type = initialization Once a val is assigned, it cannot be reassigned. Kotlin’s type inference can usually determine the type automatically, based on the initialization value. This produces a simpler definition: val identifier = initialization Both of the following are valid: val daysInFebruary = 28 val daysInMarch: Int = 31 A var (variable) definition looks the same, using var instead of val : var identifier1 = initialization var identifier2: Type = initialization Unlike a val , you can modify a var , so the following is legal: var hoursSpent = 20 hoursSpent = 25 However, the type can’t be changed, so you get an error if you say: hoursSpent = 30.5 Kotlin infers the Int type when hoursSpent is defined, so it won’t accept the change to a floating-point value. Functions Functions are named subroutines: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 1 74 fun functionName (arg1: Type1, arg2: Type2, ...): ReturnType { // Lines of code ... return result } The fun keyword is followed by the function name and the parameter list in parentheses. Each parameter must have an explicit type, because Kotlin cannot infer parameter types. The function itself has a type, defined in the same way as for a var or val (a colon followed by the type). A function’s type is the type of the returned result. The function signature is followed by the function body contained within curly braces. The return statement provides the function’s return value. You can use an abbreviated syntax when the function consists of a single expression: fun functionName (arg1: Type1, arg2: Type2, ...): ReturnType = result This form is called an expression body . Instead of an opening curly brace, use an equals sign followed by the expression. You can omit the return type because Kotlin infers it. Here’s a function that produces the cube of its parameter, and another that adds an exclamation point to a String : // Summary1/BasicFunctions.kt fun cube (x: Int): Int { return x*x*x } fun bang (s: String) = s + ! fun main () { println(cube( 3 )) println(bang( pop )) } /* Output: 27 pop! */ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 1 75 cube() has a block body with an explicit return statement. bang() ’s body is a single expression that produces the function’s return value. Kotlin infers bang() s return type of String . Booleans For Boolean algebra, Kotlin provides operators such as: • ! (not) logically negates the value (turns true to false and vice-versa). • && (and) returns true only if both conditions are true . • || (or) returns true if at least one of the conditions is true . // Summary1/Booleans.kt fun main () { val opens = 9 val closes = 20 println( Operating hours: $opens - $closes ) val hour = 6 println( Current time:  + hour) val isOpen = hour >= opens && hour <= closes println( Open:  + isOpen) println( Not open:  + !isOpen) val isClosed = hour < opens || hour > closes println( Closed:  + isClosed) } /* Output: Operating hours: 9 - 20 Current time: 6 Open: false Not open: true Closed: true */ isOpen ’s initializer uses && to test whether both conditions are true . The first condition hour >= opens is false , so the result of the entire expression becomes false . The initializer for isClosed uses || , producing true if at least one of the conditions is true . The expression hour < opens is true , so the whole expression is true . Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 1 76 if Expressions Because if is an expression, it produces a result. This result can be assigned to a var or val . Here, you also see the use of the else keyword: // Summary1/IfResult.kt fun main () { val result = if ( 99 < 100 ) 4 else 42 println(result) } /* Output: 4 */ Either branch of an if expression can be a multiline block of code surrounded by curly braces: // Summary1/IfExpression.kt fun main () { val activity = swimming val hour = 10 val isOpen = if ( activity == swimming || activity == ice skating ){ val opens = 9 val closes = 20 println( Operating hours:  + opens + - + closes) hour >= opens && hour <= closes } else { false } println(isOpen) } /* Output: Operating hours: 9 - 20 true */ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 1 77 A value defined inside a block of code, such as opens , is not accessible outside the scope of that block. Because they are defined globally to the if expression, activity and hour are accessible inside the if expression. The result of an if expression is the result of the last expression of the chosen branch; here, it’s hour >= opens && hour <= closes which is true . String Templates You can insert a value within a String using String templates. Use a $ before the identifier name: // Summary1/StrTemplates.kt fun main () { val answer = 42 println( Found $answer! ) // [1] val condition = true println( ${if (condition) 'a' else 'b'} ) // [2] println( printing a $1 ) // [3] } /* Output: Found 42! a printing a $1 */ • [1] $answer substitutes the value contained in answer . • [2] ${if(condition) 'a' else 'b'} evaluates and substitutes the result of the expression inside ${} . • [3] If the $ is followed by anything unrecognizable as a program identifier, nothing special happens. Use triple-quoted String s to store multiline text or text with special characters: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 1 78 // Summary1/ThreeQuotes.kt fun json (q: String, a: Int) = { question : $q , answer : $ a }  fun main () { println(json( The Ultimate , 42 )) } /* Output: { question : The Ultimate, answer : 42 } */ You don’t need to escape special characters like  within a triple-quoted String . (In a regular String you write  to insert a double quote). As with normal String s, you can insert an identifier or an expression using $ inside a triple-quoted String . Number Types Kotlin provides integer types ( Int , Long ) and floating point types ( Double ). A whole number constant is Int by default and Long if you append an L . A constant is Double if it contains a decimal point: // Summary1/NumberTypes.kt fun main () { val n= 1000 // Int val l= 1000L // Long val d= 1000.0 // Double println( $n $l $d ) } /* Output: 1000 1000 1000.0 */ An Int holds values between -2³¹ and +2³¹-1. Integral values can overflow; for example, adding anything to Int.MAX_VALUE produces an overflow: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 1 79 // Summary1/Overflow.kt fun main () { println(Int.MAX_VALUE + 1 ) println(Int.MAX_VALUE + 1L ) } /* Output: -2147483648 2147483648 */ In the second println() statement we append L to 1 , forcing the whole expression to be of type Long , which avoids the overflow. (A Long can hold values between -2 ‘⁶³‘ and +2 ‘⁶³‘ -1 ). When you divide an Int with another Int , Kotlin produces an Int result, and any remainder is truncated. So 1/2 produces 0 . If a Double is involved, the Int is promoted to Double before the operation, so 1.0/2 produces 0.5 . You might expect d1 in the following to produce 3.4 : // Summary1/Truncation.kt fun main () { val d1: Double = 3.0 + 2 / 5 println(d1) val d2: Double = 3 + 2.0 / 5 println(d2) } /* Output: 3.0 3.4 */ Because of evaluation order, it doesn’t. Kotlin first divides 2 by 5 , and integer math produces 0 , yielding an answer of 3.0 . The same evaluation order does produce the expected result for d2 . Dividing 2.0 by 5 produces 0.4 . The 3 is promoted to a Double because we add it to a Double ( 0.4 ), which produces 3.4 . Understanding evaluation order helps you to decipher what a program does, both with logical operations (Boolean expressions) and with mathematical operations. If you’re unsure about evaluation order, use parentheses to force your intention. This also makes it clear to those reading your code. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 1 80 Repetition with while A while loop continues as long as the controlling Boolean-expression produces true : while (Boolean-expression) { // Code to be repeated } The Boolean expression is evaluated once at the beginning of the loop and again before each further iteration. // Summary1/While.kt fun testCondition (i: Int) = i < 100 fun main () { var i= 0 while (testCondition(i)) { print( . ) i += 10 } } /* Output: .......... */ Kotlin infers Boolean as the result type for testCondition() . The short versions of assignment operators are available for all mathematical operations ( += , -= , *= , /= , %= ). Kotlin also supports the increment and decrement operators ++ and --, in both prefix and postfix form. while can be used with the do keyword: do { // Code to be repeated } while (Boolean-expression) Rewriting While.kt : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 1 81 // Summary1/DoWhile.kt fun main () { var i= 0 do { print( . ) i += 10 } while (testCondition(i)) } /* Output: .......... */ The sole difference between while and do-while is that the body of the do-while always executes at least once, even if the Boolean expression produces false the first time. Looping & Ranges Many programming languages index into an iterable object by stepping through integers. Kotlin’s for allows you to take elements directly from iterable objects like ranges and String s. For example, this for selects each character in the String Kotlin : // Summary1/StringIteration.kt fun main () { for (c in Kotlin ){ print( $c  ) // c += 1 // error: // val cannot be reassigned } } /* Output: Kotlin */ c can’t be explicitly defined as either a var or val —Kotlin automatically makes it a val and infers its type as Char (you can provide the type explicitly, but in practice this is rarely done). Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 1 82 You can step through integral values using ranges : // Summary1/RangeOfInt.kt fun main () { for (i in 1. . 10 ){ print( $i  ) } } /* Output: 12345678910 */ Creating a range with .. includes both bounds, but until excludes the top endpoint: 1 until 10 is the same as 1..9 . You can specify an increment value using step : 1..21 step 3 . The in Keyword The same in that provides for loop iteration also allows you to check membership in a range. !in returns true if the tested value isn’t in the range: // Summary1/Membership.kt fun inNumRange (n: Int) = n in 50. . 100 fun notLowerCase (ch: Char) = ch ! in 'a' .. 'z' fun main () { val i1 = 11 val i2 = 100 val c1 = 'K' val c2 = 'k' println( $i1 ${inNumRange(i1)} ) println( $i2 ${inNumRange(i2)} ) println( $c1 ${notLowerCase(c1)} ) println( $c2 ${notLowerCase(c2)} ) } /* Output: 11 false Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 1 83 100 true K true k false */ in can also be used to test membership in floating-point ranges, although such ranges can only be defined using .. and not until . Expressions & Statements The smallest useful fragment of code in most programming languages is either a statement or an expression . These have one basic difference: • A statement changes state • An expression expresses That is, an expression produces a result, while a statement does not. Because it doesn’t return anything, a statement must change the state of its surroundings (that is, create a side effect ) to do anything useful. Almost everything in Kotlin is an expression: val hours = 10 val minutesPerHour = 60 val minutes = hours * minutesPerHour In each case, everything to the right of the = is an expression, which produces a result that is assigned to the identifier on the left. Some functions, like println() , don’t seem to produce a result, but because they are still expressions, they must return something . Kotlin has a special Unit type for these: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 1 84 // Summary1/UnitReturn.kt fun main () { val result = println( returns Unit ) println(result) } /* Output: returns Unit kotlin.Unit */ Experienced programmers should go to Summary 2 after working the exercises for this atom. Exercises and solutions for this atom can be found at AtomicKotlin.com ³⁴ . ³⁴ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Section II: Introduction to Objects Objects are the foundation for numerous modern languages, including Kotlin. In an object-oriented (OO) programming language, you discover “nouns” in the problem you’re solving, and translate those nouns to objects. Objects hold data and perform actions. An object-oriented language is oriented towards creating and using objects. Kotlin isn’t just object-oriented; it’s also functional . Functional languages focus on the actions you perform (“verbs”) instead of combining data and operations into objects. This section explains the basics of object-oriented programming. Section IV: Func-tional Programming introduces functional programming and Section V: Object-Oriented Programming covers object-oriented programming in detail. ","Objects Everywhere Objects store data using properties ( val s and var s) and perform opera-tions with this data using functions. Some definitions: • Class : Defines properties and functions for what is essentially a new data type. Classes are also called user-defined types . • Member : Either a property or a function of a class. • Member function : A function intended to work only with a specific class of object. • Creating an object : Making a val or var of a class. Also called creating an instance of that class. Because classes define state and behavior , we can even refer to instances of built-in types like Double or Boolean as objects. Consider Kotlin’s IntRange class: // ObjectsEverywhere/IntRanges.kt fun main () { val r1 = IntRange( 0 , 10 ) val r2 = IntRange( 5 , 7 ) println(r1) println(r2) } /* Output: 0..10 5..7 */ We create two objects (instances) of the IntRange class . Each object has its own piece of storage in memory. IntRange is a class, but a particular range r1 from 0 to 10 is an object that is distinct from range r2 . ","Objects Everywhere 87 Numerous operations are available for an IntRange object. Some are straightfor-ward, like sum() , and others require more understanding before you can use them. If you try calling one that needs arguments, the IDE will ask for those arguments. To learn about a particular member function, look it up in the Kotlin documentation, available online³⁵ . Notice the magnifying glass icon in the top right area of the page. Click on that and type IntRange into the search box. Click on kotlin.ranges > IntRange from the resulting search. You’ll see the documentation for the IntRange class. You can study all the member functions—the API (Application Programming Interface)—of the class. Although you won’t understand most of it at this time, it’s helpful to become comfortable looking things up in the Kotlin documentation. An IntRange is a kind of object, and a defining characteristic of an object is that you perform operations on it. Instead of “performing an operation,” we say calling a member function . To call a member function for an object, start with the object identifier, then a dot, then the name of the operation: // ObjectsEverywhere/RangeSum.kt fun main () { val r = IntRange( 0 , 10 ) println(r.sum()) } /* Output: 55 */ Because sum() is a member function defined for IntRange , you call it by saying r.sum() . This adds up all the numbers in that IntRange . Earlier object-oriented languages used the phrase “sending a message” to describe calling a member function for an object. You will sometimes still see that terminol-ogy. Classes can have many operations (member functions). It’s easy to explore classes using an IDE (integrated development environment) that includes a feature called code completion . For example, if you type .s after an object identifier within IntelliJ IDEA, it shows all the members of that object that begin with s : ³⁵ https://kotlinlang.org/api/latest/jvm/stdlib/index.html Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Objects Everywhere 88 Code Completion Try using code completion on other objects. For example, you can reverse a String or convert all the characters to lower case: // ObjectsEverywhere/Strings.kt fun main () { val s= AbcD println(s.reversed()) println(s.toLowerCase()) } /* Output: DcbA abcd */ You can easily convert a String to an integer and back: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Objects Everywhere 89 // ObjectsEverywhere/Conversion.kt fun main () { val s= 123 println(s.toInt()) val i= 123 println(i.toString()) } /* Output: 123 123 */ Later in the book we discuss strategies to handle situations when the String you want to convert doesn’t represent a correct integer value. You can also convert from one numerical type to another. To avoid confusion, conversions between number types are explicit. For example, you convert an Int i to a Long by calling i.toLong() , or to a Double with i.toDouble() : // ObjectsEverywhere/NumberConversions.kt fun fraction (numerator: Long, denom: Long) = numerator.toDouble() / denom fun main () { val num = 1 val den = 2 val f = fraction(num.toLong(), den.toLong()) println(f) } /* Output: 0.5 */ Well-defined classes are easy for a programmer to understand, and produce code that’s easy to read. Exercises and solutions for this atom can be found at AtomicKotlin.com ³⁶ . ³⁶ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Classes Not only can you use predefined types like IntRange and String , you can also create your own types of objects. Indeed, creating new types comprises much of the activity in object-oriented pro-gramming. You create new types by defining classes . An object is a piece of the solution for a problem you’re trying to solve. Start by thinking of objects as expressing concepts. As a first approximation, if you discover a “thing” in your problem, represent that thing as an object in your solution. Suppose you want to create a program to manage animals in a zoo. It makes sense to categorize the different types of animals based on how they behave, their needs, animals they get along with and those they fight with. Everything different about a species of animal is captured in the classification of that animal’s object. Kotlin uses the class keyword to create a new type of object: // CreatingClasses/Animals.kt // Create some classes: class Giraffe class Bear class Hippo fun main () { // Create some objects: val g1 = Giraffe() val g2 = Giraffe() val b = Bear() val h = Hippo() // Each object() is unique: println(g1) println(g2) println(h) ","Creating Classes 91 println(b) } /* Sample output: Giraffe@28d93b30 Giraffe@1b6d3586 Hippo@4554617c Bear@74a14482 */ To define a class, start with the class keyword, followed by an identifier for your new class. The class name must begin with a letter (A-Z, upper or lower case), but can include things like numbers and underscores. Following convention, we capitalize the first letter of a class name, and lowercase the first letter of all val s and var s. Animals.kt starts by defining three new classes, then creates four objects (also called instances ) of those classes. Giraffe is a class, but a particular five-year-old male giraffe that lives in Botswana is an object. Each object is different from all others, so we give them names like g1 and g2 . Notice the rather cryptic output of the last four lines. The part before the @ is the class name, and the number after the @ is the address where the object is located in your computer’s memory. Yes, that’s a number even though it includes some letters—it’s called “hexadecimal notation” and it’s explained in Wikipedia³⁷ . Every object in your program has its own unique address. The classes defined here ( Giraffe , Bear , and Hippo ) are as simple as possible: the entire class definition is a single line. More complex classes use curly braces ( { and } ) to create a class body containing the characteristics and behaviors for that class. A function defined within a class belongs to that class. In Kotlin, we call these member functions of the class. Some object-oriented languages like Java choose to call them methods , a term that came from early object-oriented languages like Smalltalk. To emphasize the functional nature of Kotlin, the designers chose to drop the term “method,” as some beginners found the distinction confusing. Instead, the term “function” is used throughout the language. If it is unambiguous, we will just say “function.” If we must make the distinction: ³⁷ https://en.wikipedia.org/wiki/Hexadecimal Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Classes 92 • Member functions belong to a class. • Top-level functions exist by themselves and are not part of a class. Here, bark() belongs to the Dog class: // CreatingClasses/Dog.kt class Dog { fun bark () = yip! } fun main () { val dog = Dog() } In main() , we create a Dog object and assign it to val dog . Kotlin emits a warning because we never use dog . Member functions are called ( invoked ) with the object name, followed by a . (dot/period), followed by the function name and parameter list. Here we call the meow() function and display the result: // CreatingClasses/Cat.kt class Cat { fun meow () = mrrrow! } fun main () { val cat = Cat() // Call 'meow()' for 'cat': val m1 = cat.meow() println(m1) } /* Output: mrrrow! */ A member function acts on a particular instance of a class. When you call meow() , you must call it with an object. During the call, meow() can access other members of that object. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Classes 93 When calling a member function, Kotlin keeps track of the object of interest by silently passing a reference to that object. That reference is available inside the member function by using the keyword this . Member functions have special access to other elements within a class, simply by naming those elements. You can also explicitly qualify access to those elements using this . Here, exercise() calls speak() with and without qualification: // CreatingClasses/Hamster.kt class Hamster { fun speak () = Squeak!  fun exercise () = this .speak() + // Qualified with 'this' speak() + // Without 'this' Running on wheel } fun main () { val hamster = Hamster() println(hamster.exercise()) } /* Output: Squeak! Squeak! Running on wheel */ In exercise() , we call speak() first with an explicit this and then omit the qualification. Sometimes you’ll see code containing an unnecessary explicit this . That kind of code often comes from programmers who know a different language where this is either required, or part of its style. Using a feature unnecessarily is confusing for the reader, who spends time trying to figure out why you’re doing it. We recommend avoiding the unnecessary use of this . Outside the class, you must say hamster.exercise() and hamster.speak() . Exercises and solutions for this atom can be found at AtomicKotlin.com ³⁸ . ³⁸ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Properties A property is a var or val that’s part of a class. Defining a property maintains state within a class. Maintaining state is the primary motivating reason for creating a class rather than just writing one or more standalone functions. A var property can be reassigned, while a val property can’t. Each object gets its own storage for properties: // Properties/Cup.kt class Cup { var percentFull = 0 } fun main () { val c1 = Cup() c1.percentFull = 50 val c2 = Cup() c2.percentFull = 100 println(c1.percentFull) println(c2.percentFull) } /* Output: 50 100 */ Defining a var or val inside a class looks just like defining it within a function. However, the var or val becomes part of that class, and you must refer to it by specifying its object using dot notation , placing a dot between the object and the name of the property. You can see dot notation used for each reference to percentFull . ","Properties 95 The percentFull property represents the state of the corresponding Cup object. c1.percentFull and c2.percentFull contain different values, showing that each object has its own storage. A member function can refer to a property within its object without using dot notation (that is, without qualifying it): // Properties/Cup2.kt class Cup2 { var percentFull = 0 val max = 100 fun add (increase: Int): Int { percentFull += increase if (percentFull > max) percentFull = max return percentFull } } fun main () { val cup = Cup2() cup.add( 50 ) println(cup.percentFull) cup.add( 70 ) println(cup.percentFull) } /* Output: 50 100 */ The add() member function tries to add increase to percentFull but ensures that it doesn’t go past 100%. You must qualify both properties and member functions from outside a class. You can define top-level properties: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Properties 96 // Properties/TopLevelProperty.kt val constant = 42 var counter = 0 fun inc () { counter++ } Defining a top-level val is safe because it cannot be modified. However, defining a mutable ( var ) top-level property is considered an anti-pattern . As your program becomes more complicated, it becomes harder to reason correctly about shared mutable state . If everyone in your code base can access the var counter , you can’t guarantee it will change correctly: while inc() increases counter by one, some other part of the program might decrease counter by ten, producing obscure bugs. It’s best to guard mutable state within a class. In Constraining Visibility you’ll see how to make it truly hidden. To say that var s can be changed while val s cannot is an oversimplification. As an analogy, consider a house as a val , and a sofa inside the house as a var . You can modify sofa because it’s a var . You can’t reassign house , though, because it’s a val : // Properties/ChangingAVal.kt class House { var sofa: String =  } fun main () { val house = House() house.sofa = Simple sleeper sofa: $89.00 println(house.sofa) house.sofa = New leather sofa: $3,099.00 println(house.sofa) // Cannot reassign the val to a new House: // house = House() } /* Output: Simple sleeper sofa: $89.00 New leather sofa: $3,099.00 */ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Properties 97 Although house is a val , its object can be modified because sofa in class House is a var . Defining house as a val only prevents it from being reassigned to a new object. If we make a property a val , it cannot be reassigned: // Properties/AnUnchangingVar.kt class Sofa { val cover: String = Loveseat cover } fun main () { var sofa = Sofa() // Not allowed: // sofa.cover = New cover // Reassigning a var: sofa = Sofa() } Even though sofa is a var , its object cannot be modified because cover in class Sofa is a val . However, sofa can be reassigned to a new object. We’ve talked about identifiers like house and sofa as if they were objects. They are actually references to objects. One way to see this is to observe that two identifiers can refer to the same object: // Properties/References.kt class Kitchen { var table: String = Round table } fun main () { val kitchen1 = Kitchen() val kitchen2 = kitchen1 println( kitchen1: ${kitchen1.table} ) println( kitchen2: ${kitchen2.table} ) kitchen1.table = Square table println( kitchen1: ${kitchen1.table} ) println( kitchen2: ${kitchen2.table} ) } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Properties 98 /* Output: kitchen1: Round table kitchen2: Round table kitchen1: Square table kitchen2: Square table */ When kitchen1 modifies table , kitchen2 sees the modification. kitchen1.table and kitchen2.table display the same output. Remember that var and val control references rather than objects. A var allows you to rebind a reference to a different object, and a val prevents you from doing so. Mutability means an object can change its state. In the examples above, class House and class Kitchen define mutable objects while class Sofa defines immutable objects. Exercises and solutions for this atom can be found at AtomicKotlin.com ³⁹ . ³⁹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Constructors You initialize a new object by passing information to a constructor . Each object is an isolated world. A program is a collection of objects, so correct initialization of each individual object solves a large part of the initialization problem. Kotlin includes mechanisms to guarantee proper object initialization. A constructor is like a special member function that initializes a new object. The simplest form of a constructor is a single-line class definition: // Constructors/Wombat.kt class Wombat fun main () { val wombat = Wombat() } In main() , calling Wombat() creates a Wombat object. If you are coming from another object-oriented language you might expect to see a new keyword used here, but new would be redundant in Kotlin so it was omitted. You pass information to a constructor using a parameter list, just like a function. Here, the Alien constructor takes a single argument: ","Constructors 100 // Constructors/Arg.kt class Alien (name: String) { val greeting = Poor $name! } fun main () { val alien = Alien( Mr. Meeseeks ) println(alien.greeting) // alien.name // Error // [1] } /* Output: Poor Mr. Meeseeks! */ Creating an Alien object requires the argument (try it without one). name initializes the greeting property within the constructor, but it is not accessible outside the constructor—try uncommenting line [1] . If you want the constructor parameter to be accessible outside the class body, define it as a var or val in the parameter list: // Constructors/VisibleArgs.kt class MutableNameAlien ( var name: String) class FixedNameAlien ( val name: String) fun main () { val alien1 = MutableNameAlien( Reverse Giraffe ) val alien2 = FixedNameAlien( Krombopolis Michael ) alien1.name = Parasite // Can't do this: // alien2.name = Parasite } These class definitions have no explicit class bodies—the bodies are implied. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Constructors 101 When name is defined as a var or val , it becomes a property and is thus accessible outside the constructor. val constructor parameters cannot be changed, while var constructor parameters are mutable. Your class can have numerous constructor parameters: // Constructors/MultipleArgs.kt class AlienSpecies ( val name: String, val eyes: Int, val hands: Int, val legs: Int ){ fun describe () = $name with $eyes eyes,  + $hands hands and $legs legs } fun main () { val kevin = AlienSpecies( Zigerion , 2 , 2 , 2 ) val mortyJr = AlienSpecies( Gazorpian , 2 , 6 , 2 ) println(kevin.describe()) println(mortyJr.describe()) } /* Output: Zigerion with 2 eyes, 2 hands and 2 legs Gazorpian with 2 eyes, 6 hands and 2 legs */ In Complex Constructors , you’ll see that constructors can also contain complex initialization logic. When an object is used where a String is expected, Kotlin calls the object’s toString() member function. If you don’t write one, you still get a default toString() : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Constructors 102 // Constructors/DisplayAlienSpecies.kt fun main () { val krombopulosMichael = AlienSpecies( Gromflomite , 2 , 2 , 2 ) println(krombopulosMichael) } /* Sample output: AlienSpecies@4d7e1886 */ The default toString() isn’t very useful—it produces the class name and the physical address of the object (this varies from one program execution to the next). You can define your own toString() : // Constructors/Scientist.kt class Scientist ( val name: String) { override fun toString (): String { return Scientist('$name') } } fun main () { val zeep = Scientist( Zeep Xanflorp ) println(zeep) } /* Output: Scientist('Zeep Xanflorp') */ override is a new keyword for us. It is required here because toString() already has a definition, the one producing the primitive result. override tells Kotlin that yes, we do actually want to replace the default toString() with our own definition. The explicitness of override clarifies the code and prevents mistakes. A good toString() is useful when debugging a program. Sometimes just looking inside an object is enough to discover the problem. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁴⁰ . ⁴⁰ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Constraining Visibility A piece of writing usually isn’t ready until it’s been rewritten, often many times. If you leave a piece of code for a few days or weeks, then come back to it, you might see a much better way to write it. This is one of the prime motivations for refactoring , which rewrites working code to make it more readable, understandable, and thus maintainable. There is a tension in this desire to change and improve your code. Consumers ( client programmers ) require aspects of your code to be stable. You want to change it, and they want it to stay the same. This is particularly important for libraries. Consumers of a library don’t want to rewrite code for a new version of that library. However, the library creator must be free to make modifications and improvements, with the certainty that the client code won’t be affected by those changes. Therefore, a primary consideration in software design is: Separate things that change from things that stay the same. To control visibility, Kotlin and some other languages provide access modifiers . Library creators decide what is and is not accessible by the client programmer by using the modifiers public , private , protected , and internal . This atom covers public and private ; protected is explained later in the book while internal is beyond the scope of this book. An access modifier such as private appears before the definition for a class, function, or property. An access modifier only controls access for that particular definition. A public definition is accessible by client programmers, so changes to that definition impact client code directly. If you don’t provide a modifier, your definition is ","Constraining Visibility 104 automatically public , so public is technically redundant. You will sometimes still specify public for the sake of clarity. A private definition is hidden and only accessible from other members of the same class. Changing, or even removing, a private definition doesn’t directly impact client programmers. private classes, top-level functions, and top-level properties are accessible only inside that file: // Visibility/RecordAnimals.kt private var index = 0 // [1] private class Animal ( val name: String) // [2] private fun recordAnimal ( // [3] animal: Animal ){ println( Animal #$index: ${animal.name} ) index++ } fun recordAnimals () { recordAnimal(Animal( Tiger )) recordAnimal(Animal( Antelope )) } fun recordAnimalsCount () { println( $index animals are here! ) } You can access private top-level properties ( [1] ), classes ( [2] ), and functions ( [3] ) from other functions and classes within RecordAnimals.kt . Kotlin prevents you from accessing a private top-level element from within another file, telling you it’s private in the file: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Constraining Visibility 105 // Visibility/ObserveAnimals.kt fun main () { // Can't access private members // declared in another file. // Class is private: // val rabbit = Animal(Rabbit) // Function is private: // recordAnimal(rabbit) // Property is private: // index++ recordAnimals() recordAnimalsCount() } /* Output: Animal #0: Tiger Animal #1: Antelope 2 animals are here! */ Privacy is most commonly used for members of a class: // Visibility/Cookie.kt class Cookie ( private var isReady: Boolean // [1] ){ private fun crumble () = // [2] println( crumble ) public fun bite () = // [3] println( bite ) fun eat () { // [4] isReady = true // [5] crumble() bite() } } fun main () { Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Constraining Visibility 106 val x = Cookie( false ) x.bite() // Can't access private members: // x.isReady // x.crumble() x.eat() } /* Output: bite crumble bite */ • [1] A private property, not accessible outside the containing class. • [2] A private member function. • [3] A public member function, accessible to anyone. • [4] No access modifier means public . • [5] Only members of the same class can access private members. The private keyword means no one can access that member except other members of that class. Other classes cannot access private members, so it’s as if you’re also insulating the class against yourself and your collaborators. With private , you can freely change that member without worrying whether it affects another class in the same package. As a library designer you’ll typically keep things as private as possible, and expose only functions and classes to client programmers. Any member function that is a helper function for a class can be made private to ensure you don’t accidentally use it elsewhere in the package and thus prohibit yourself from changing or removing that function. The same is true for a private property inside a class. Unless you must expose the underlying implementation (which is less likely than you might think), make properties private . However, just because a reference to an object is private inside a class doesn’t mean some other object can’t have a public reference to the same object: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Constraining Visibility 107 // Visibility/MultipleRef.kt class Counter ( var start: Int) { fun increment () { start += 1 } override fun toString () = start.toString() } class CounterHolder (counter: Counter) { private val ctr = counter override fun toString () = CounterHolder:  + ctr } fun main () { val c = Counter( 11 ) // [1] val ch = CounterHolder(c) // [2] println(ch) c.increment() // [3] println(ch) val ch2 = CounterHolder(Counter( 9 )) // [4] println(ch2) } /* Output: CounterHolder: 11 CounterHolder: 12 CounterHolder: 9 */ • [1] c is now defined in the scope surrounding the creation of the Counter-Holder object on the following line. • [2] Passing c as the argument to the CounterHolder constructor means that the new CounterHolder now refers to the same Counter object that c refers to. • [3] The Counter that is supposedly private inside ch can still be manipulated via c . • [4] Counter(9) has no other references except within CounterHolder , so it cannot be accessed or modified by anything except ch2 . Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Constraining Visibility 108 Maintaining multiple references to a single object is called aliasing and can produce surprising behavior. Access modifiers are useful, but they are not a substitute for programmer vigilance. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁴¹ . ⁴¹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Packages A fundamental principle in programming is the acronym DRY: Don’t Repeat Yourself . Duplicating code is not just extra work—multiple identical pieces of code require maintenance whenever you make fixes or improvements. Every duplication creates opportunities for mistakes. The import keyword reuses code from other files. One way to use import is to specify a class, function or property name: import packagename.ClassName import packagename.functionName import packagename.propertyName A package is an associated collection of code; each package is usually designed to solve a particular problem, and often contains multiple functions and classes. For ex-ample, we can import mathematical constants and functions from the kotlin.math library: // Packages/ImportClass.kt import kotlin.math.PI import kotlin.math.cos // Cosine fun main () { println(PI) println(cos(PI)) println(cos( 2 * PI)) } /* Output: 3.141592653589793 -1.0 1.0 */ Sometimes you want to use multiple third-party libraries containing classes or functions with the same name. The as keyword allows you to change names while importing: ","Packages 110 // Packages/ImportNameChange.kt import kotlin.math.PI as circleRatio import kotlin.math.cos as cosine fun main () { println(circleRatio) println(cosine(circleRatio)) println(cosine( 2 * circleRatio)) } /* Output: 3.141592653589793 -1.0 1.0 */ as is useful if a library name is poorly chosen or excessively long. You can fully qualify an import in the body of your code. In the following example, the code might be less readable due to the explicit package names, but the origin of each element is absolutely clear: // Packages/FullyQualify.kt fun main () { println(kotlin.math.PI) println(kotlin.math.cos(kotlin.math.PI)) println(kotlin.math.cos( 2 * kotlin.math.PI)) } /* Output: 3.141592653589793 -1.0 1.0 */ To import everything from a package, use a star: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Packages 111 // Packages/ImportEverything.kt import kotlin.math.* fun main () { println(E) println(E.roundToInt()) println(E.toInt()) } /* Output: 2.718281828459045 3 2 */ Note that the kotlin.math package contains a convenient roundToInt() that rounds the Double value to the nearest integer, unlike toInt() that simply truncates anything after a decimal point. To reuse your code, create a package using the package keyword. The package statement must be the first non-comment statement in the file. package is followed by the name of your package, which by convention is all lowercase: // Packages/PythagoreanTheorem.kt package pythagorean import kotlin.math.sqrt class RightTriangle ( val a: Double, val b: Double ){ fun hypotenuse () = sqrt(a * a + b * b) fun area ()=a*b/ 2 } You can name the source-code file anything you like, unlike Java which requires the file name to be the same as the class name. Kotlin allows you to choose any name for your package, but it’s considered good style for the package name to be identical to the directory name where the package files are located (this will not always be the case for the examples in this book). The elements in the pythagorean package are now available using import : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Packages 112 // Packages/ImportPythagorean.kt import pythagorean.RightTriangle fun main () { val rt = RightTriangle( 3.0 , 4.0 ) println(rt.hypotenuse()) println(rt.area()) } /* Output: 5.0 6.0 */ In the remainder of this book we use package statements for any file that defines functions, classes, etc., outside of main() , to prevent name clashes with other files in the book, but we usually won’t put a package statement in a file that only contains a main() . Exercises and solutions for this atom can be found at AtomicKotlin.com ⁴² . ⁴² https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Testing Constant testing is essential for rapid program development. If changing one part of your code breaks other code, your tests reveal the problem right away. If you don’t find out immediately, changes accumulate and you can no longer tell which change caused the problem. You’ll spend a lot longer tracking it down. Testing is a crucial practice, so we introduce it early and use it throughout the rest of the book. This way, you become accustomed to testing as a standard part of the programming process. Using println() to verify code correctness is a weak approach—you must scrutinize the output every time and consciously ensure that it’s correct. To simplify your experience while using this book, we created our own tiny testing system. The goal is a minimal approach that: 1. Shows the expected result of expressions. 2. Provides output so you know the program is running, even when all tests succeed. 3. Ingrains the concept of testing early in your practice. Although useful for this book, ours is not a testing system for the workplace. Others have toiled long and hard to create such test systems. For example: • JUnit⁴³ is one of the most popular Java test frameworks, and is easily used from within Kotlin. • KotlinTest⁴⁴ is designed specifically for Kotlin, and takes advantage of Kotlin language features. • The Spek Framework⁴⁵ produces a different form of testing, called Specification Testing . To use our testing framework, we must first import it. The basic elements of the framework are eq (for equals ) and neq (for not equals ): ⁴³ https://junit.org ⁴⁴ https://github.com/kotlintest/kotlintest ⁴⁵ https://spekframework.org/ ","Testing 114 // Testing/TestingExample.kt import atomictest.* fun main () { val v1 = 11 val v2 = Ontology // 'eq' means equals: v1 eq 11 v2 eq Ontology // 'neq' means not equal v2 neq Epistimology // [Error] Epistimology != Ontology // v2 eq Epistimology } /* Output: 11 Ontology Ontology */ The code for the atomictest package is in Appendix A: AtomicTest . We don’t intend that you understand everything in AtomicTest.kt right now, because it uses some features that won’t appear until later in the book. To produce a clean, comfortable appearance, AtomicTest uses a Kotlin feature you haven’t seen yet: the ability to write a function call a.function(b) in the text-like form a function b . This is called infix notation . Only functions defined using the infix keyword can be called this way. AtomicTest.kt defines the infix eq and neq used in TestingExample.kt : expression eq expected expression neq expected eq and neq are flexible—almost anything works as a test expression. If expected is a String , then expression is converted to a String and the two String s are compared. Otherwise, expression and expected are compared directly (without converting them Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Testing 115 first). In either case, the result of expression appears on the console so you see something when the program runs. Even when the tests succeed, you still see the result on the left of eq or neq . If expression and expected are not equivalent, AtomicTest shows an error when the program runs. The last test in TestingExample.kt intentionally fails so you see an example of failure output. If the two values are not equal, Kotlin displays the message and stops executing the program. If you uncomment the last line and run the example above, you will see, after all the successful tests: [Error] Epistimology != Ontology The actual value stored in v2 is not what it is claimed to be in the “expected” expression. AtomicTest displays the String representations for both expected and actual values. eq and neq are the basic (infix) functions defined for AtomicTest —it truly is a minimal testing system. When you put eq and neq expressions in your examples, you’ll create both a test and some console output. You verify the correctness of the program by running it. There’s a second tool in AtomicTest . The trace object captures output for later comparison: // Testing/Trace1.kt import atomictest.* fun main () { trace( line 1 ) trace( 47 ) trace( line 2 ) trace eq  line 1 47 line 2  } Adding results to trace looks like a function call, so you can effectively replace calls to println() with calls to trace() . Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Testing 116 In previous atoms, we displayed output and relied on human visual inspection to catch any discrepancies. That’s unreliable; even in a book where we scrutinize the code over and over, we’ve learned that visual inspection can’t be trusted to find errors. From now on we rarely use commented output blocks because AtomicTest will do everything for us. However, sometimes we still include commented output blocks when that produces a more useful effect. Seeing the benefits of using testing throughout the rest of the book should help you incorporate testing into your programming process. You’ll probably start feeling uncomfortable when you see code that doesn’t have tests. You might even decide that code without tests is broken by definition. Testing as Part of Programming Testing is most effective when it’s built into your software development process. Writing tests ensures you get the results you expect. Many people advocate writing tests before writing the implementation code—you first make the test fail before you write the code to make it pass. This technique, called Test Driven Development (TDD), is a way to ensure that you’re really testing what you think you are. You’ll find a more complete description of TDD on Wikipedia (search for “Test Driven Development”). There’s another benefit to writing testably—it changes the way you craft your code. You could just display the results on the console. But in the test mindset you wonder, “How will I test this?” When you create a function, you decide you should return something from the function, if for no other reason than to test that result. Functions that do nothing but take input and produce output tend to generate better designs, as well. Here’s a simplified example using TDD to implement the BMI calculation from Number Types . First, we write the tests, along with an initial implementation that fails (because we haven’t yet implemented the functionality): Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Testing 117 // Testing/TDDFail.kt package testing1 import atomictest.eq fun main () { calculateBMI( 160 , 68 ) eq Normal weight // calculateBMI(100, 68) eq Underweight // calculateBMI(200, 68) eq Overweight } fun calculateBMI (lbs: Int, height: Int) = Normal weight Only the first test passes. The other tests fail and are commented. Next, we add code to determine which weights are in which categories. Now all the tests fail: // Testing/TDDStillFails.kt package testing2 import atomictest.eq fun main () { // Everything fails: // calculateBMI(160, 68) eq Normal weight // calculateBMI(100, 68) eq Underweight // calculateBMI(200, 68) eq Overweight } fun calculateBMI ( lbs: Int, height: Int ): String { val bmi = lbs / (height * height) * 703.07 return if (bmi < 18.5 ) Underweight else if (bmi < 25 ) Normal weight else Overweight } We’re using Int s instead of Double s, producing a zero result. The tests guide us to the fix: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Testing 118 // Testing/TDDWorks.kt package testing3 import atomictest.eq fun main () { calculateBMI( 160.0 , 68.0 ) eq Normal weight calculateBMI( 100.0 , 68.0 ) eq Underweight calculateBMI( 200.0 , 68.0 ) eq Overweight } fun calculateBMI ( lbs: Double, height: Double ): String { val bmi = lbs / (height * height) * 703.07 return if (bmi < 18.5 ) Underweight else if (bmi < 25 ) Normal weight else Overweight } You may choose to add additional tests for the boundary conditions. In the exercises for this book, we include tests that your code must pass. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁴⁶ . ⁴⁶ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Exceptions The word “exception” is used in the same sense as the phrase “I take exception to that.” An exceptional condition prevents the continuation of the current function or scope. At the point the problem occurs, you might not know what to do with it, but you cannot continue within the current context. You don’t have enough information to fix the problem. So you must stop and hand the problem to another context that’s able to take appropriate action. This atom covers the basics of exceptions as an error-reporting mechanism. In Section VI: Preventing Failure , we look at other ways to deal with problems. It’s important to distinguish an exceptional condition from a normal problem. A normal problem has enough information in the current context to cope with the issue. With an exceptional condition, you cannot continue processing. All you can do is leave, relegating the problem to an external context. This is what happens when you throw an exception . The exception is the object that is “thrown” from the site of the error. Consider toInt() , which converts a String to an Int . What happens if you call this function for a String that doesn’t contain an integer value? // Exceptions/ToIntException.kt package exceptions fun erroneousCode () { // Uncomment this line to get an exception: // val i = 1$.toInt() // [1] } fun main () { erroneousCode() } ","Exceptions 120 Uncommenting line [1] produces an exception. Here, the failing line is commented so we don’t stop the book’s build, which checks whether each example compiles and runs as expected. When an exception is thrown, the path of execution—the one that can’t be continued— stops, and the exception object ejects from the current context. Here, it exits the context of erroneousCode() and goes out to the context of main() . In this case, Kotlin only reports the error; the programmer has presumably made a mistake and must fix the code. When an exception isn’t caught, the program aborts and displays a stack trace containing detailed information. Uncommenting line [1] in ToIntException.kt , produces the following output: Exception in thread main java.lang.NumberFormatException: For input s tring: 1$ at java.lang.NumberFormatException.forInputString(NumberFormatExcepti on.java:65) at java.lang.Integer.parseInt(Integer.java:580) at java.lang.Integer.parseInt(Integer.java:615) at ToIntExceptionKt.erroneousCode(at ToIntException.kt:5) at ToIntExceptionKt.main(at ToIntException.kt:9) The stack trace gives details such as the file and line where the exception occurred, so you can quickly discover the issue. The last two lines show the problem: in line 9 of main() we call erroneousCode() . Then, more precisely, in line 5 of erroneousCode() we call toInt() . To avoid commenting and uncommenting code to display exceptions, we use a function from the AtomicTest package: atomictest.capture() . It stores the exception and compares it to what we expect: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Exceptions 121 // Exceptions/IntroducingCapture.kt import atomictest.* fun main () { capture { 1$ .toInt() } eq NumberFormatException:  + For input string:  1 $  } capture() produces a String containing the type of the exception together with a message describing what went wrong. capture() isn’t very helpful in normal programming—it’s designed specifically for this book, so you can see the exception and know that the output has been checked by the book’s build system. Another strategy when you can’t successfully produce the expected result is to return null , which is a special constant denoting “no value.” You can return null instead of a value of any type. Later in Nullable Types we discuss the way null affects the type of the resulting expression. The Kotlin standard library contains String.toIntOrNull() which performs the conversion if the String contains an integer number, or produces null if the conversion is impossible— null is a simple way to indicate failure: // Exceptions/IntroducingNull.kt import atomictest.eq fun main () { 1$ .toIntOrNull() eq null } Suppose we calculate average income over a period of months: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Exceptions 122 // Exceptions/AverageIncome.kt package firstversion import atomictest.* fun averageIncome (income: Int, months: Int) = income / months fun main () { averageIncome( 3300 , 3 ) eq 1100 capture { averageIncome( 5000 , 0 ) } eq ArithmeticException: / by zero } If months is zero, the division in averageIncome() throws an ArithmeticExcep-tion . Unfortunately, this doesn’t tell us anything about why the error occurred, what the denominator means and whether it can legally be zero in the first place. This is clearly a bug in the code— averageIncome() should cope with a months of 0 in a way that prevents a divide-by-zero error. Let’s modify averageIncome() to produce more information about the source of the problem. If months is zero, we can’t return a regular integer value as a result. One strategy is to return null : // Exceptions/AverageIncomeWithNull.kt package withnull import atomictest.eq fun averageIncome (income: Int, months: Int) = if (months == 0 ) null else income / months fun main () { averageIncome( 3300 , 3 ) eq 1100 averageIncome( 5000 , 0 ) eq null } If a function can return null , Kotlin requires that you check the result before using it (this is covered in Nullable Types ). Even if you only want to display output to the Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Exceptions 123 user, it’s better to say “No full month periods have passed,” rather than “Your average income for the period is: null.” Instead of executing averageIncome() with the wrong arguments, you can throw an exception—escape and force some other part of the program to manage the issue. You could just allow the default ArithmeticException , but it’s often more useful to throw a specific exception with a detailed error message. When, after a couple of years in production, your application suddenly throws an exception because a new feature calls averageIncome() without properly checking the arguments, you’ll be grateful for that message: // Exceptions/AverageIncomeWithException.kt package properexception import atomictest.* fun averageIncome (income: Int, months: Int) = if (months == 0 ) throw IllegalArgumentException( // [1] Months can't be zero ) else income / months fun main () { averageIncome( 3300 , 3 ) eq 1100 capture { averageIncome( 5000 , 0 ) } eq IllegalArgumentException:  + Months can't be zero } Your goal is to generate the most useful messages possible to simplify the support of your application in the future. [1] Shows how to throw an exception: the throw keyword followed by the exception to be thrown, along with any arguments it might need. Here we use the standard exception class IllegalArgumentException . Later you’ll learn to define your own exception types and make them specific to your circumstances. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁴⁷ . ⁴⁷ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Lists A List is a container , which is an object that holds other objects. Containers are also called collections . When we need a basic container for the examples in this book, we normally use List . List s are part of the standard Kotlin package so they don’t require an import . The following example creates a List populated with Int s by calling the standard library function listOf() with initialization values: // Lists/Lists.kt import atomictest.eq fun main () { val ints = listOf( 99 , 3 , 5 , 7 , 11 , 13 ) ints eq [99, 3, 5, 7, 11, 13] // [1] // Select each element in the List: var result =  for (i in ints) { // [2] result += $i  } result eq 99 3 5 7 11 13  // Indexing into the List: ints[ 4 ] eq 11 // [3] } • [1] A List uses square brackets when displaying itself. • [2] for loops work well with List s: for(i in ints) means i receives each value in ints . You don’t declare val i or give its type; Kotlin knows from the context that i is a for loop identifier. ","Lists 125 • [3] Square brackets index into a List .A List keeps its elements in initialization order, and you select them individually by number. Like most programming languages, Kotlin starts indexing at element zero, which in this case produces the value 99 . Thus an index of 4 produces the value 11 . Forgetting that indexing starts at zero produces the so-called off-by-one error. In a language like Kotlin we often don’t select elements one at a time, but instead iterate through an entire container using in . This eliminates off-by-one errors. If you use an index beyond the last element in a List , Kotlin throws an ArrayIn-dexOutOfBoundsException : // Lists/OutOfBounds.kt import atomictest.* fun main () { val ints = listOf( 1 , 2 , 3 ) capture { ints[ 3 ] } eq ArrayIndexOutOfBoundsException:  + Index 3 out of bounds for length 3 } A List can hold all different types. Here, we create a List of Double s and a List of String s: // Lists/ListUsefulFunction.kt import atomictest.eq fun main () { val doubles = listOf( 1.1 , 2.2 , 3.3 , 4.4 ) doubles.min() eq 1.1 doubles.max() eq 4.4 val strings = listOf( Twas , Brillig , And , Slithy , Toves ) strings eq listOf( Twas , Brillig , And , Slithy , Toves ) strings.sorted() eq listOf( And , Brillig , Slithy , Toves , Twas ) Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Lists 126 strings.reversed() eq listOf( Toves , Slithy , And , Brillig , Twas ) strings.first() eq Twas strings.takeLast( 2 ) eq listOf( Slithy , Toves ) } This shows some of List ’s operations. Note the name “sorted” instead of “sort.” When you call sorted() it produces a new List containing the same elements as the old, in sorted order—but it leaves the original List alone. Calling it “sort” implies that the original List is changed directly (a.k.a. sorted in place ). Throughout Kotlin, you see this tendency of “leaving the original object alone and producing a new object.” reversed() also produces a new List . Parameterized Types We consider it good practice to use type inference—it tends to make the code cleaner and easier to read. Sometimes, however, Kotlin complains that it can’t figure out what type to use, and in other cases explicitness makes the code more understandable. Here’s how we tell Kotlin the type contained by a List : // Lists/ParameterizedTypes.kt import atomictest.eq fun main () { // Type is inferred: val numbers = listOf( 1 , 2 , 3 ) val strings = listOf( one , two , three ) // Exactly the same, but explicitly typed: val numbers2: List<Int> = listOf( 1 , 2 , 3 ) val strings2: List<String> = listOf( one , two , three ) numbers eq numbers2 strings eq strings2 } Kotlin uses the initialization values to infer that numbers contains a List of Int s, while strings contains a List of String s. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Lists 127 numbers2 and strings2 are explicitly-typed versions of numbers and strings , created by adding the type declarations List<Int> and List<String> . You haven’t seen angle brackets before—they denote a type parameter , allowing you to say, “this container holds ‘parameter’ objects.” We pronounce List<Int> as “ List of Int .” Type parameters are useful for components other than containers, but you often see them with container-like objects. Return values can also have type parameters: // Lists/ParameterizedReturn.kt package lists import atomictest.eq // Return type is inferred: fun inferred (p: Char, q: Char) = listOf(p, q) // Explicit return type: fun explicit (p: Char, q: Char): List<Char> = listOf(p, q) fun main () { inferred( 'a' , 'b' ) eq [a, b] explicit( 'y' , 'z' ) eq [y, z] } Kotlin infers the return type for inferred() , while explicit() specifies the function return type. You can’t just say it returns a List ; Kotlin will complain, so you must give the type parameter as well. When you specify the return type of a function, Kotlin enforces your intention. Read-only and Mutable Lists If you don’t explicitly say you want a mutable List , you won’t get one. listOf() produces a read-only List that has no mutating functions. If you’re creating a List gradually (that is, you don’t have all the elements at creation time), use mutableListOf() . This produces a MutableList that can be modified: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Lists 128 // Lists/MutableList.kt import atomictest.eq fun main () { val list = mutableListOf<Int>() list.add( 1 ) list.addAll(listOf( 2 , 3 )) list += 4 list += listOf( 5 , 6 ) list eq listOf( 1 , 2 , 3 , 4 , 5 , 6 ) } You can add elements to a MutableList using add() and addAll() , or the shortcut += which adds a single element or another collection. Because list has no initial elements, we must tell Kotlin what type it is by providing the <Int> specification in the call to mutableListOf() . A MutableList can be treated as a List , in which case it cannot be changed. You can’t, however, treat a read-only List as a MutableList : // Lists/MutListIsList.kt package lists import atomictest.eq fun getList (): List<Int> { return mutableListOf( 1 , 2 , 3 ) } fun main () { // getList() produces a read-only List: val list = getList() // list += 3 // Error list eq listOf( 1 , 2 , 3 ) } Note that list lacks mutation functions despite being originally created using mutableListOf() inside getList() . During the return , the result type becomes a List<Int> . The original object is still a MutableList , but it is viewed through the lens of a List . Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Lists 129 A List is read-only —you can read its contents but not write to it. If the underlying implementation is a MutableList and you retain a mutable reference to that implementation, you can still modify it via that mutable reference, and any read-only references will see those changes. This is another example of aliasing , introduced in Constraining Visibility : // Lists/MultipleListRefs.kt import atomictest.eq fun main () { val first = mutableListOf( 1 ) val second: List<Int> = first second eq listOf( 1 ) first += 2 // second sees the change: second eq listOf( 1 , 2 ) } first is an immutable reference ( val ) to the mutable object produced by muta-bleListOf(1) . Then second is aliased to first , so it is a view of that same object. second is read-only because List<Int> does not include modification functions. Note that, without the explicit List<Int> type declaration, Kotlin would infer that second was also a reference to a mutable object. We’re able to add an element ( 2 ) to the object because first is a reference to a mutable List . Note that second observes these changes—it cannot change the List although the List changes via first . Exercises and solutions for this atom can be found at AtomicKotlin.com ⁴⁸ . ⁴⁸ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Variable Argument Lists The vararg keyword produces a flexibly-sized argument list. In Lists we introduced listOf() , which takes any number of parameters and produces a List : // Varargs/ListOf.kt import atomictest.eq fun main () { listOf( 1 ) eq [1] listOf( a , b ) eq [a, b] } Using the vararg keyword, you can define a function that takes any number of arguments, just like listOf() does. vararg is short for variable argument list : // Varargs/VariableArgList.kt package varargs fun v (s: String, vararg d: Double) {} fun main () { v( abc , 1.0 , 2.0 ) v( def , 1.0 , 2.0 , 3.0 , 4.0 ) v( ghi , 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 ) } A function definition may specify only one parameter as vararg . Although it’s possible to specify any item in the parameter list as vararg , it’s usually simplest to do it for the last one. vararg allows you to pass any number (including zero) of arguments. All arguments must be of the specified type. vararg arguments are accessed using the parameter name, which becomes an Array : ","Variable Argument Lists 131 // Varargs/VarargSum.kt package varargs import atomictest.eq fun sum ( vararg numbers: Int): Int { var total = 0 for (n in numbers) { total += n } return total } fun main () { sum( 13 , 27 , 44 ) eq 84 sum( 1 , 3 , 5 , 7 , 9 , 11 ) eq 36 sum() eq 0 } Array s and List s have very similar interfaces, but are implemented differently— List is a regular library class while Array has special low-level support. Array comes from Kotlin’s requirement for compatibility with other languages, especially Java. In day-to-day programming, use a List when you need a simple sequence. Use Array s only when a third-party API requires an Array , or when you’re dealing with vararg s. In most cases you can just ignore the fact that vararg produces an Array and treat it as if it were a List : // Varargs/VarargLikeList.kt package varargs fun evaluate ( vararg ints: Int) { println( Size: ${ints.size} ) println( Sum: ${ints.sum()} ) println( Min: ${ints.min()} ) println( Max: ${ints.max()} ) println( Average: ${ints.average()} ) } fun main () { Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Variable Argument Lists 132 evaluate( 10 ,-3 , 8 , 1 , 9 ) } /* Output: Size: 5 Sum: 25 Min: -3 Max: 10 Average: 5.0 */ You can pass an Array of elements wherever a vararg is accepted. To create an Array , use arrayOf() in the same way you use listOf() . Note that an Array is always mutable. To convert an Array into a sequence of arguments (not just a single element of type Array ), use the spread operator , * : // Varargs/SpreadOperator.kt import varargs.sum import atomictest.eq fun main () { val array = intArrayOf( 4 , 5 ) sum( 1 , 2 , 3 , *array, 6 ) eq 21 // [1] // Doesn't compile: // sum(1, 2, 3, array, 6) val list = listOf( 9 , 10 , 11 ) sum(*list.toIntArray()) eq 30 // [2] } If you pass an Array of primitive types (like Int , Double or Boolean ) as in the example above, the Array creation function must be specifically typed. If you use arrayOf(4, 5) instead of intArrayOf(4, 5) , line [1] will produce an error complaining that inferred type is Array<Int> but IntArray was expected . The spread operator only works with arrays. If you have a List that you want to pass as a sequence of arguments, first convert it to an Array and then apply the spread operator, as in [2] . Because the result is an Array of a primitive type, we must again use the specific conversion function toIntArray() . The spread operator is especially helpful when you must pass vararg arguments to another function that also expects vararg s: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Variable Argument Lists 133 // Varargs/TwoFunctionsWithVarargs.kt package varargs fun first ( vararg numbers: Int) { for (i in numbers) { print( [$i] ) } } fun second ( vararg numbers: Int) = first(*numbers) fun main () { second( 7 , 9 , 32 ) } /* Output: [7][9][32] */ Command-Line Arguments You can pass a variable number of arguments on the command line, when you are starting a program. To capture command-line arguments, you must provide a particular parameter to main() : // Varargs/MainArgs.kt fun main (args: Array<String>) { for (a in args) { println(a) } } The parameter is traditionally called args (although you can call it anything), and the type for args can only be Array<String> ( Array of String ). If you use IDE, you can pass program arguments by editing the corresponding “Run configuration”. The last exercise in the corresponding course explains how to do that in IntelliJ IDEA. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Variable Argument Lists 134 Alternatively, you can use the kotlinc compiler. If kotlinc doesn’t appear to be on your computer, you can install it by following the instructions on the Kotlin main site⁴⁹ . Once you’ve entered and saved the code for MainArgs.kt , type the following at a command prompt: kotlinc MainArgs.kt You provide the command-line arguments following the program invocation, like this: kotlin MainArgsKt hamster 42 3.14159 You’ll see this output: hamster 42 3.14159 If you want to turn a String parameter into a specific type, Kotlin provides conversion functions, such as a toInt() for converting to an Int , and toFloat() for converting to a Float . Using these assumes that the command-line arguments appear in a particular order. Here, the program expects a String , followed by something convertible to an Int , followed by something convertible to a Float : // Varargs/MainArgConversion.kt fun main (args: Array<String>) { if (args.size < 3 ) return val first = args[ 0 ] val second = args[ 1 ].toInt() val third = args[ 2 ].toFloat() println( $first $second $third ) } The first line in main() quits the program if there aren’t enough arguments. If you don’t provide something convertible to an Int and a Float as the second and third command-line arguments, you will see runtime errors (try it to see the errors). Compile and run MainArgConversion.kt with the same command-line arguments we used before, and you’ll see: ⁴⁹ https://kotlinlang.org/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Variable Argument Lists 135 hamster 42 3.14159 Exercises and solutions for this atom can be found at AtomicKotlin.com ⁵⁰ . ⁵⁰ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Sets A Set is a collection that allows only one element of each value. The most common Set activity is to test for membership using in or contains() : // Sets/Sets.kt import atomictest.eq fun main () { val intSet = setOf( 1 , 1 , 2 , 3 , 9 , 9 , 4 ) // No duplicates: intSet eq setOf( 1 , 2 , 3 , 4 , 9 ) // Element order is unimportant: setOf( 1 , 2 ) eq setOf( 2 , 1 ) // Set membership: ( 9 in intSet) eq true ( 99 in intSet) eq false intSet.contains( 9 ) eq true intSet.contains( 99 ) eq false // Does this set contain another set? intSet.containsAll(setOf( 1 , 9 , 2 )) eq true // Set union: intSet.union(setOf( 3 , 4 , 5 , 6 )) eq setOf( 1 , 2 , 3 , 4 , 5 , 6 , 9 ) // Set intersection: intSet intersect setOf( 0 , 1 , 2 , 7 , 8 ) eq setOf( 1 , 2 ) // Set difference: intSet subtract setOf( 0 , 1 , 9 , 10 ) eq ","Sets 137 setOf( 2 , 3 , 4 ) intSet - setOf( 0 , 1 , 9 , 10 ) eq setOf( 2 , 3 , 4 ) } This example shows: 1. Placing duplicate items into a Set automatically removes those duplicates. 2. Element order is not important for sets. Two sets are equal if they contain the same elements. 3. Both in and contains() test for membership. 4. You can perform the usual Venn-diagram operations like checking for subset, union, intersection and difference, using either dot notation (like set.union(other) ) or infix notation (like set intersect other ). The functions union , inter-sect and subtract are declared as infix . 5. Set difference can be expressed with either subtract() or the minus operator. To remove duplicates from a List , convert it to a Set : // Sets/RemoveDuplicates.kt import atomictest.eq fun main () { val list = listOf( 3 , 3 , 2 , 1 , 2 ) list.toSet() eq setOf( 1 , 2 , 3 ) list.distinct() eq listOf( 3 , 2 , 1 ) abbcc .toSet() eq setOf( 'a' , 'b' , 'c' ) } You can also use distinct() , which returns a List . You may call toSet() on a String to convert it into a set of unique characters. As with List , Kotlin provides two creation functions for Set . The result of setOf() is read-only. To create a mutable Set , use mutableSetOf() : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Sets 138 // Sets/MutableSet.kt import atomictest.eq fun main () { val mutableSet = mutableSetOf<Int>() mutableSet += 42 mutableSet += 42 mutableSet eq setOf( 42 ) mutableSet -= 42 mutableSet eq setOf<Int>() } The operators += and -= add and remove elements to Set s, just as with List s. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁵¹ . ⁵¹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Maps A Map connects keys to values and looks up a value when given a key. You create a Map by providing key-value pairs to mapOf() . Each key is separated from its associated value by to : // Maps/Maps.kt import atomictest.eq fun main () { val constants = mapOf( Pi to 3.141 , e to 2.718 , phi to 1.618 ) constants eq {Pi=3.141, e=2.718, phi=1.618} // Look up a value from a key: constants[ e ] eq 2.718 // [1] constants.keys eq setOf( Pi , e , phi ) constants.values eq [3.141, 2.718, 1.618] var s=  // Iterate through key-value pairs: for (entry in constants) { // [2] s += ${entry.key}=${entry.value},  } s eq Pi=3.141, e=2.718, phi=1.618,  s=  // Unpack during iteration: for ((key, value) in constants) // [3] s += $key=$value,  s eq Pi=3.141, e=2.718, phi=1.618,  } ","Maps 140 • [1] The [] operator looks up a value using a key. You can produce all the keys using keys() and all the values using values() . Calling keys() produces a Set because all keys in a Map must be unique, otherwise you’d have ambiguity during a lookup. • [2] Iterating through a Map produces key-value pairs as map entries. • [3] You can unpack keys and values as you iterate. A plain Map is read-only. Here’s a MutableMap : // Maps/MutableMaps.kt import atomictest.eq fun main () { val m= mutableMapOf( 5 to five , 6 to six ) m[ 5 ] eq five m[ 5 ]= 5ive m[ 5 ] eq 5ive m += 4 to four m eq mapOf( 5 to 5ive , 4 to four , 6 to six ) } map[key] = value adds or changes the value associated with key . Alternatively, you can explicitly add a pair by saying map += key to value . mapOf() and mutableMapOf() preserve the order in which the elements are put into the Map . This is not guaranteed for other types of Map . A read-only Map doesn’t allow mutations: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Maps 141 // Maps/ReadOnlyMaps.kt import atomictest.eq fun main () { val m = mapOf( 5 to five , 6 to six ) m[ 5 ] eq five // m[5] = 5ive // Fails // m += (4 to four) // Fails m+( 4 to four ) // Doesn't change m m eq mapOf( 5 to five , 6 to six ) val m2=m+( 4 to four ) m2 eq mapOf( 5 to five , 6 to six , 4 to four ) } The definition of m creates a Map associating Int s with String s. If we try to replace a String , Kotlin emits an error. An expression with + creates a new Map that includes both the old elements and the new one, but doesn’t affect the original Map . The only way to “add” an element to a read-only Map is by creating a new Map . A Map returns null if it doesn’t contain an entry for a given key. If you need a result that can’t be null , use getValue() and catch NoSuchElementException if the key is missing: // Maps/GetValue.kt import atomictest.* fun main () { val map = mapOf( 'a' to attempt ) map[ 'b' ] eq null capture { map.getValue( 'b' ) } eq NoSuchElementException:  + Key b is missing in the map. } You can store class instances as values in a Map . Here, we create a map to retrieve a Contact using a number String : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Maps 142 // Maps/ContactMap.kt package maps import atomictest.eq class Contact ( val name: String, val number: String ){ override fun toString (): String { return Contact('$name', '$number') } } fun main () { val miffy = Contact( Miffy , 1-234-567890 ) val cleo = Contact( Cleo , 098-765-4321 ) val contacts = mapOf( miffy.number to miffy, cleo.number to cleo) contacts[ 1-234-567890 ] eq miffy contacts[ 1-111-111111 ] eq null } It’s possible to use class instances as keys in a Map , but that’s trickier so we discuss it later in the book. Map s look like simple little databases. They are sometimes called associative arrays , because they associate keys with values. Although they are quite limited compared to a full-featured database, they are nonetheless remarkably useful (and far more efficient than a database). Exercises and solutions for this atom can be found at AtomicKotlin.com ⁵² . ⁵² https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Accessors To read a property, use its name. To assign a value to a mutable property, use the assignment operator = . Here, we read and write the property i : // PropertyAccessors/Data.kt package propertyaccessors import atomictest.eq class Data ( var i: Int) fun main () { val data = Data( 10 ) data .i eq 10 // Read the 'i' property data .i = 20 // Write to the 'i' property } This appears to be straightforward access to the piece of storage named i . However, Kotlin calls functions to perform the read and write operations. As you expect, the default behavior of those functions reads and writes the data stored in i . In this atom you’ll learn to write your own property accessors to customize the reading and writing actions. The accessor used to get the value of a property is called a getter . You create a getter by defining get() immediately after the property definition. The accessor used to modify a mutable property is called a setter . You create a setter by defining set() immediately after the property definition. The property accessors defined in the following example imitate the default imple-mentations generated by Kotlin. We display additional information so you can see that the property accessors are indeed called during reads and writes. We indent get() and set() to visually associate them with the property, but the actual association happens because get() and set() are defined immediately after that property (Kotlin doesn’t care about the indentation): ","Property Accessors 144 // PropertyAccessors/Default.kt package propertyaccessors class Default { var i: Int = 0 get () { println( get() ) return field // [1] } set (value) { println( set($value) ) field = value // [2] } } fun main () { val d = Default() d.i = 2 println(d.i) } /* Output: set(2) get() 2 */ The definition order for get() and set() is unimportant. You can define get() without defining set() , and vice-versa. The default behavior for a property returns its stored value from a getter and modifies it with a setter—the actions of [1] and [2] . Inside the getter and setter, the stored value is manipulated indirectly using the field keyword, which is only accessible within these two functions. This next example uses the default implementation of the getter and adds a setter to trace changes to the property n : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Accessors 145 // PropertyAccessors/LogChanges.kt package propertyaccessors import atomictest.eq class LogChanges { var n: Int = 0 set (value) { println( $field becomes $value ) field = value } } fun main () { val lc = LogChanges() lc.n eq 0 lc.n = 2 lc.n eq 2 } /* Output: 0 0 becomes 2 2 */ If you define a property as private , both accessors become private . You can also make the setter private and the getter public . Then you can read the property outside the class, but only change its value inside the class: // PropertyAccessors/Counter.kt package propertyaccessors import atomictest.eq class Counter { var value: Int = 0 private set fun inc () = value++ } fun main () { val counter = Counter() repeat( 10 ){ counter.inc() Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Accessors 146 } counter.value eq 10 } Using private set , we control the value property so it can only be incremented by one. Normal properties store their data in a field. You can also create a property that doesn’t have a field: // PropertyAccessors/Hamsters.kt package propertyaccessors import atomictest.eq class Hamster ( val name: String) class Cage ( private val maxCapacity: Int) { private val hamsters = mutableListOf<Hamster>() val capacity: Int get () = maxCapacity - hamsters.size val full: Boolean get () = hamsters.size == maxCapacity fun put (hamster: Hamster): Boolean = if (full) false else { hamsters += hamster true } fun take (): Hamster = hamsters.removeAt( 0 ) } fun main () { val cage = Cage( 2 ) cage.full eq false cage.capacity eq 2 cage.put(Hamster( Alice )) eq true cage.put(Hamster( Bob )) eq true cage.full eq true cage.capacity eq 0 Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Accessors 147 cage.put(Hamster( Charlie )) eq false cage.take() cage.capacity eq 1 } The properties capacity and full contain no underlying state—they are computed at the time of each access. Both capacity and full are similar to functions, and you can alternatively define them as such: // PropertyAccessors/Hamsters2.kt package propertyaccessors class Cage2 ( private val maxCapacity: Int) { private val hamsters = mutableListOf<Hamster>() fun capacity (): Int = maxCapacity - hamsters.size fun isFull (): Boolean = hamsters.size == maxCapacity } In this case, using properties improves readability because capacity and fullness are properties of the cage. However, don’t just convert all your functions to properties— first, see how they read. The Kotlin style guide prefers properties over functions when the value is cheap to calculate and the property returns the same result for each invocation as long as the object state hasn’t changed. Property accessors provide a kind of protection for properties. Many object-oriented languages rely on making a physical field private to control access to that property. With property accessors you can add code to control or modify that access, while allowing anyone to use a property. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁵³ . ⁵³ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 This atom summarizes and reviews the atoms in Section II, from Objects Everywhere through Property Accessors . If you’re an experienced programmer, this is your next atom after Summary 1 , and you will go through the atoms sequentially after this. Beginning programmers should read this atom and perform the exercises as review. If any information here isn’t clear to you, go back and study the atom for that topic. The topics appear in appropriate order for experienced programmers, which is not the same as the order of the atoms in the book. For example, we start by introducing packages and imports so we can use our minimal test framework for the rest of the atom. Packages & Testing Any number of reusable library components can be bundled under a single library name using the package keyword: // Summary2/ALibrary.kt package com.yoururl.libraryname // Components to reuse ... fun f () = result You can put multiple components in a single file, or spread components out among multiple files under the same package name. Here we’ve defined f() as the sole component. To make it unique, the package name conventionally begins with your reversed domain name. In this example, the domain name is yoururl.com . ","Summary 2 149 In Kotlin, the package name can be independent from the directory where its contents are located. Java requires that the directory structure correspond to the fully-quali-fied package name: in Java, all the content for the package com.yoururl.libraryname should be located under the com/yoururl/libraryname directory. For mixed Kotlin and Java projects, Kotlin’s style guide recommends the same practice. For pure Kotlin projects, put the directory libraryname at the top level of your project’s directory structure. An import statement brings one or more names into the current namespace: // Summary2/UseALibrary.kt import com.yoururl.libraryname.* fun main () { val x = f() } The star after libraryname tells Kotlin to import all the components of a library. You can also select components individually; details are in Packages . In the remainder of this book we use package statements for any file that defines functions, classes, etc., outside of main() , to prevent name clashes with other files in the book, but we usually won’t put a package statement in a file that only contains a main() . An important library for this book is atomictest , our simple testing framework. atomictest is defined in Appendix A: AtomicTest , although it uses language features you will not understand at this point in the book. After importing atomictest , you use eq (equals) and neq (not equals) almost as if they were language keywords: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 150 // Summary2/UsingAtomicTest.kt import atomictest.* fun main () { val pi = 3.14 val pie = A round dessert pi eq 3.14 pie eq A round dessert pi neq pie } /* Output: 3.14 A round dessert 3.14 */ The ability to use eq / neq without any dots or parentheses is called infix notation . You can call infix functions either in the regular way: pi.eq(3.14) , or using infix notation: pi eq 3.14 . Both eq and neq are assertions of truth that also display the result from the left side of the eq / neq statement, and an error message if the expression on the right of the eq isn’t equivalent to the left (or is equivalent, in the case of neq ). This way you see verified results in the source code. Objects Everywhere Kotlin is a hybrid object-functional language: it supports both object-oriented and functional programming paradigms. Objects contain val s and var s to store data (these are called properties ) and perform operations using functions defined within a class, called member functions (when it’s unambiguous, we just say “functions”). A class defines properties and member functions for what is essentially a new, user-defined data type. When you create a val or var of a class, it’s called creating an object or creating an instance . An especially useful type of object is the container , also called collection . A container is an object that holds other objects. In this book, we often use the List because it’s the most general-purpose sequence. Here we perform several operations on a List that holds Double s. listOf() creates a new List from its arguments: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 151 // Summary2/ListCollection.kt import atomictest.eq fun main () { val lst = listOf( 19.2 , 88.3 , 22.1 ) lst[ 1 ] eq 88.3 // Indexing lst.reversed() eq listOf( 22.1 , 88.3 , 19.2 ) lst.sorted() eq listOf( 19.2 , 22.1 , 88.3 ) lst.max() eq 88.3 lst.min() eq 19.2 lst.sum() eq 129.6 } No import statement is required to use a List . Kotlin uses square brackets for indexing into sequences. Indexing is zero-based. This example also shows a few of the many standard library functions available for List s: sorted() , reversed() , max() , min() and sum() . To understand these functions, consult the online Kotlin documentation⁵⁴ . When you call sorted() or reversed() , lst is not modified. Instead, a new List is created and returned, containing the desired result. This approach of never modifying the original object is consistent throughout Kotlin libraries and you should endeavor to follow this pattern when writing your own code. Creating Classes A class definition consists of the class keyword, a name for the class, and an optional body. The body contains property definitions ( val s and var s) and function definitions. This example defines a NoBody class without a body, and classes with val properties: ⁵⁴ https://kotlinlang.org/docs/reference/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 152 // Summary2/ClassBodies.kt package summary2 class NoBody class SomeBody { val name = Janet Doe } class EveryBody { val all = listOf(SomeBody(), SomeBody(), SomeBody()) } fun main () { val nb = NoBody() val sb = SomeBody() val eb = EveryBody() } To create an instance of a class, put parentheses after its name, along with arguments if those are required. Properties within class bodies can be any type. SomeBody contains a property of type String , and EveryBody ’s property is a List holding SomeBody objects. Here’s a class with member functions: // Summary2/Temperature.kt package summary2 import atomictest.eq class Temperature { var current = 0.0 var scale = f fun setFahrenheit (now: Double) { current = now scale = f } fun setCelsius (now: Double) { current = now scale = c Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 153 } fun getFahrenheit (): Double = if (scale == f ) current else current * 9.0 / 5.0 + 32.0 fun getCelsius (): Double = if (scale == c ) current else (current -32.0 )* 5.0 / 9.0 } fun main () { val temp = Temperature() // [1] temp.setFahrenheit( 98.6 ) temp.getFahrenheit() eq 98.6 temp.getCelsius() eq 37.0 temp.setCelsius( 100.0 ) temp.getFahrenheit() eq 212.0 } These member functions are just like the top-level functions we’ve defined outside of classes, except they belong to the class and have unqualified access to the other members of the class, such as current and scale . Member functions can also call other member functions in the same class without qualification. • [1] Although temp is a val , we later modify the Temperature object. The val definition prevents the reference temp from being reassigned to a new object, but it does not restrict the behavior of the object itself. The following two classes are the foundation of a tic-tac-toe game: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 154 // Summary2/TicTacToe.kt package summary2 import atomictest.eq class Cell { var entry = '' // [1] fun setValue (e: Char): String = // [2] if (entry == '' && (e == 'X' || e == 'O' )) { entry = e Successful move } else Invalid move } class Grid { val cells = listOf( listOf(Cell(), Cell(), Cell()), listOf(Cell(), Cell(), Cell()), listOf(Cell(), Cell(), Cell()) ) fun play (e: Char, x: Int, y: Int): String = if (x ! in 0. . 2 || y ! in 0. . 2 ) Invalid move else cells[x][y].setValue(e) // [3] } fun main () { val grid = Grid() grid.play( 'X' , 1 , 1 ) eq Successful move grid.play( 'X' , 1 , 1 ) eq Invalid move grid.play( 'O' , 1 , 3 ) eq Invalid move } • [1] The entry property in Cell is a var so it can be modified. The single quotes in the initialization produce a Char type, so all assignments to entry must also be Char s. • [2] setValue() tests that the Cell is available and that you’ve passed the correct character. It returns a String result to indicate success or failure. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 155 The Grid class holds a List containing three List s, each containing three Cell s—a matrix. • [3] play() checks to see if the x and y arguments are within range, then indexes into the matrix, relying on the tests performed by setValue() . Constructors Constructors create new objects. You pass information to a constructor using its parameter list, placed in parentheses directly after the class name. A constructor call thus looks like a function call, except that the initial letter of the name is capitalized (following the Kotlin style guide). The constructor returns an object of the class: // Summary2/WildAnimals.kt package summary2 import atomictest.eq class Badger (id: String, years: Int) { val name = id val age = years override fun toString (): String { return Badger: $name, age: $age } } class Snake ( var type: String, var length: Double ){ override fun toString (): String { return Snake: $type, length: $length } } class Moose ( val age: Int, val height: Double ){ override fun toString (): String { Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 156 return Moose, age: $age, height: $height } } fun main () { Badger( Bob , 11 ) eq Badger: Bob, age: 11 Snake( Garden , 2.4 ) eq Snake: Garden, length: 2.4 Moose( 16 , 7.2 ) eq Moose, age: 16, height: 7.2 } The parameters id and years in Badger are only available in the constructor body . The constructor body consists of the lines of code other than function definitions; in this case, the definitions for name and age . Often you want the constructor parameters to be available in parts of the class other than the constructor body, but without the trouble of explicitly defining new identifiers as we did with name and age . If you define your parameters as var s or val s, they becomes properties and are accessible everywhere in the class. Both Snake and Moose use this approach, and you can see that the constructor parameters are now available inside their respective toString() functions. Constructor parameters declared with val cannot be changed, but those declared with var can. Whenever you use an object in a situation that expects a String , Kotlin produces a String representation of that object by calling its toString() member function. To define a toString() , you must understand a new keyword: override . This is necessary (Kotlin insists on it) because toString() is already defined. override tells Kotlin that we do actually want to replace the default toString() with our own definition. The explicitness of override makes this clear to the reader and helps prevent mistakes. Notice the formatting of the multiline parameter list for Snake and Moose —this is the recommended standard when you have too many parameters to fit on one line, for both constructors and functions. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 157 Constraining Visibility Kotlin provides access modifiers similar to those available in other languages like C++ or Java. These allow component creators to decide what is available to the client programmer. Kotlin’s access modifiers include the public , private , protected , and internal keywords. protected is explained later in the book while internal is beyond the scope of this book. An access modifier like public or private appears before the definition for a class, function or property. Each access modifier only controls the access for that particular definition. A public definition is available to everyone, in particular to the client programmer who uses that component. Thus, any changes to a public definition will impact client code. If you don’t provide a modifier, your definition is automatically public . For clarity in certain cases, programmers still sometimes redundantly specify public . If you define a class, top-level function, or property as private , it is available only within that file: // Summary2/Boxes.kt package summary2 private var count = 0 // [1] private class Box ( val dimension: Int) { // [2] fun volume () = dimension * dimension * dimension override fun toString () = Box volume: ${volume()} } private fun countBox (box: Box) { // [3] println( $box ) count++ } fun countBoxes () { countBox(Box( 4 )) Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 158 countBox(Box( 5 )) } fun main () { countBoxes() println( $count boxes ) } /* Output: Box volume: 64 Box volume: 125 2 boxes */ You can access private properties ( [1] ), classes ( [2] ), and functions ( [3] ) only from other functions and classes in the Boxes.kt file. Kotlin prevents you from accessing private top-level elements from another file. Class members can be private : // Summary2/JetPack.kt package summary2 class JetPack ( private var fuel: Double // [1] ){ private var warning = false private fun burn () = // [2] if (fuel -1 <= 0 ){ fuel = 0.0 warning = true } else fuel -= 1 public fun fly () = burn() // [3] fun check () = // [4] if (warning) // [5] Warning else OK } fun main () { val jetPack = JetPack( 3.0 ) Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 159 while (jetPack.check() != Warning ){ println(jetPack.check()) jetPack.fly() } println(jetPack.check()) } /* Output: OK OK OK Warning */ • [1] fuel and warning are both private properties and can’t be used by non-members of JetPack . • [2] burn() is private , and thus only accessible inside JetPack . • [3] fly() and check() are public and can be used everywhere. • [4] No access modifier means public visibility. • [5] Only members of the same class can access private members. Because a private definition is not available to everyone, you can generally change it without concern for the client programmer. As a library designer, you’ll typically keep everything as private as possible, and expose only functions and classes you want client programmers to use. To limit the size and complexity of example listings in this book, we only use private in special cases. Any function you’re certain is only a helper function can be made private , to ensure you don’t accidentally use it elsewhere and thus prohibit yourself from changing or removing the function. Exceptions Consider toDouble() , which converts a String to a Double . What happens if you call it for a String that doesn’t translate into a Double ? Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 160 // Summary2/ToDoubleException.kt fun main () { // val i = $1.9.toDouble() } Uncommenting the line in main() produces an exception. Here, the failing line is commented so we don’t stop the book’s build (which checks whether each example compiles and runs as expected). When an exception is thrown, the current path of execution stops, and the exception object ejects from the current context. When an exception isn’t caught, the program aborts and displays a stack trace containing detailed information. To avoid displaying exceptions by commenting and uncommenting code, atom-ictest.capture() stores the exception and compares it to what we expect: // Summary2/AtomicTestCapture.kt import atomictest.* fun main () { capture { $1.9 .toDouble() } eq NumberFormatException:  + For input string:  $ 1.9  } capture() is designed specifically for this book, so you can see the exception and know that the output has been checked by the book’s build system. Another strategy when your function can’t successfully produce the expected result is to return null . Later in Nullable Types we discuss how null affects the type of the resulting expression. To throw an exception, use the throw keyword followed by the exception you want to throw, along with any arguments it might need. quadraticZeroes() in the following example solves the quadratic equation⁵⁵ that defines a parabola: ax² + bx + c = 0 The solution is the quadratic formula : ⁵⁵ https://en.wikipedia.org/wiki/Quadratic_formula Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 161 The Quadratic Formula The example finds the zeroes of the parabola, where the lines cross the x-axis. We throw exceptions for two limitations: 1. a cannot be zero. 2. For zeroes to exist, b² - 4ac cannot be negative. If zeroes exist, there are two of them, so we create the Roots class to hold the return values: // Summary2/Quadratic.kt package summary2 import kotlin.math.sqrt import atomictest.* class Roots ( val root1: Double, val root2: Double ) fun quadraticZeroes ( a: Double, b: Double, c: Double ): Roots { if (a == 0.0 ) throw IllegalArgumentException( a is zero ) val underRadical = b * b -4 *a*c if (underRadical < 0 ) throw IllegalArgumentException( Negative underRadical: $underRadical ) val squareRoot = sqrt(underRadical) val root1 = (-b - squareRoot) / 2 *a val root2 = (-b + squareRoot) / 2 *a return Roots(root1, root2) } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 162 fun main () { capture { quadraticZeroes( 0.0 , 4.0 , 5.0 ) } eq IllegalArgumentException:  + a is zero capture { quadraticZeroes( 3.0 , 4.0 , 5.0 ) } eq IllegalArgumentException:  + Negative underRadical: -44.0 val roots = quadraticZeroes( 3.0 , 8.0 , 5.0 ) roots.root1 eq -15.0 roots.root2 eq -9.0 } Here we use the standard exception class IllegalArgumentException . Later you’ll learn to define your own exception types and to make them specific to your circumstances. Your goal is to generate the most useful messages possible, to simplify the support of your application in the future. Lists List s are Kotlin’s basic sequential container type, and are part of the standard Kotlin package so they’re available without any imports. You create a read-only list using listOf() and a mutable list using mutableListOf() : // Summary2/ReadonlyVsMutableList.kt import atomictest.eq fun main () { val ints = listOf( 5 , 13 , 9 ) // ints.add(11) // 'add()' not available for (i in ints) { if (i > 10 ){ println(i) } } val chars = mutableListOf( 'a' , 'b' , 'c' ) chars.add( 'd' ) // 'add()' available Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 163 chars += 'e' println(chars) } /* Output: 13 [a, b, c, d, e] */ A basic List is read-only, and does not include modification functions. Thus, the modification function add() doesn’t work with ints . for loops work well with List s: for(i in ints) means i gets each value in ints . chars is created as a MutableList ; it can be modified using functions like add() or remove() . Alternatively, you can use += and -= to add or remove elements. A read-only List is not the same as an immutable List , which can’t be modified at all. Here, we assign first , a mutable List , to second , a read-only List reference. The read-only characteristic of second doesn’t prevent the List from changing via first : // Summary2/MultipleListReferences.kt import atomictest.eq fun main () { val first = mutableListOf( 1 ) val second: List<Int> = first second eq listOf( 1 ) first += 2 // second sees the change: second eq listOf( 1 , 2 ) } first and second refer to the same object in memory. We mutate the List via the first reference, and then observe this change in the second reference. Here’s a List of String s created by breaking up a triple-quoted paragraph. This shows the power of some of the standard library functions. Notice how those functions can be chained: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 164 // Summary2/ListOfStrings.kt fun main () { val jabber =  Twas brillig, and the slithy toves Did gyre and gimble in the wabe: All mimsy were the borogoves, And the mome raths outgrabe. .trim().split(Regex(  W+ )) println(jabber.take( 5 )) println(jabber.slice( 6. . 12 )) println(jabber.slice( 6. . 18 step 2 )) println(jabber.sorted().takeLast( 5 )) println( jabber.sorted().distinct().takeLast( 5 )) } /* Output: [Twas, brillig, and, the, slithy] [Did, gyre, and, gimble, in, the, wabe] [Did, and, in, wabe, mimsy, the, And] [the, the, toves, wabe, were] [slithy, the, toves, wabe, were] */ trim() produces a new String with the leading and trailing whitespace characters (including newlines) removed. split() divides the String according to its argu-ment. In this case we use a Regex object, which creates a regular expression —a pattern that matches the parts to split. W is a special pattern that means “not a word character,” and + means “one or more of the preceeding.” Thus split() will break at one or more non-word characters, and so divides the block of text into its component words. In a String literal,  precedes a special character and produces, for example, a newline character ( n ), or a tab ( t ). To produce an actual  in the resulting String you need two backslashes:  . Thus all regular expressions require an extra  to insert a backslash, unless you use a triple-quoted String : W+ . take(n) produces a new List containing the first n elements. slice() produces a new List containing the elements selected by its Range argument, and this Range can include a step . Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 165 Note the name sorted() instead of sort() . When you call sorted() it produces a sorted List , leaving the original List alone. sort() only works with a Muta-bleList , and that list is sorted in place —the original List is modified. As the name implies, takeLast(n) produces a new List of the last n elements. You can see from the output that “the” is duplicated. This is eliminated by adding the distinct() function to the call chain. Parameterized Types Type parameters allow us to describe compound types, most commonly containers. In particular, type parameters specify what a container holds. Here, we tell Kotlin that numbers contain a List of Int , while strings contain a List of String : // Summary2/ExplicitTyping.kt package summary2 import atomictest.eq fun main () { val numbers: List<Int> = listOf( 1 , 2 , 3 ) val strings: List<String> = listOf( one , two , three ) numbers eq [1, 2, 3] strings eq [one, two, three] toCharList( seven ) eq [s, e, v, e, n] } fun toCharList (s: String): List<Char> = s.toList() For both the numbers and strings definitions, we add colons and the type declara-tions List<Int> and List<String> . The angle brackets denote a type parameter , allowing us to say, “the container holds ‘parameter’ objects.” You typically pronounce List<Int> as “ List of Int .” A return value can also have a type parameter, as seen in toCharList() . You can’t just say it returns a List —Kotlin complains, so you must give the type parameter as well. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 166 Variable Argument Lists The vararg keyword is short for variable argument list , and allows a function to accept any number of arguments (including zero) of the specified type. The vararg becomes an Array , which is similar to a List : // Summary2/VarArgs.kt package summary2 fun varargs (s: String, vararg ints: Int) { for (i in ints) { print( $i  ) } println(s) } fun main () { varargs( primes , 5 , 7 , 11 , 13 , 17 , 19 , 23 ) } /* Output: 5 7 11 13 17 19 23 primes */ A function definition may specify only one parameter as vararg . Any parameter in the list can be the vararg , but the final one is generally simplest. You can pass an Array of elements wherever a vararg is accepted. To create an Array , use arrayOf() in the same way you use listOf() . Note that an Array is always mutable. To convert an Array into a sequence of arguments (not just a single element of type Array ), use the spread operator * : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 167 // Summary2/ArraySpread.kt import summary2.varargs fun main () { val array = intArrayOf( 4 , 5 ) // [1] varargs( x , 1 , 2 , 3 , *array, 6 ) // [2] val list = listOf( 9 , 10 , 11 ) varargs( y , 7 , 8 , *list.toIntArray()) // [3] } /* Output: 123456x 7 8 9 10 11 y */ If you pass an Array of primitive types as in the example above, the Array creation function must be specifically typed. If [1] uses arrayOf(4, 5) instead of intArrayOf(4, 5) , [2] produces an error: inferred type is Array<Int> but IntArray was expected . The spread operator only works with arrays. If you have a List to pass as a sequence of arguments, first convert it to an Array and then apply the spread operator, as in [3] . Because the result is an Array of a primitive type, we must use the specific conversion function toIntArray() . Sets Set s are collections that allow only one element of each value. A Set automatically prevents duplicates. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 168 // Summary2/ColorSet.kt package summary2 import atomictest.eq val colors = Yellow Green Green Blue .split(Regex( W+ )).sorted() // [1] fun main () { colors eq listOf( Blue , Green , Green , Yellow ) val colorSet = colors.toSet() // [2] colorSet eq setOf( Yellow , Green , Blue ) (colorSet + colorSet) eq colorSet // [3] val mSet = colorSet.toMutableSet() // [4] mSet -= Blue mSet += Red // [5] mSet eq setOf( Yellow , Green , Red ) // Set membership: ( Green in colorSet) eq true // [6] colorSet.contains( Red ) eq false } • [1] The String is split() using a regular expression as described earlier for ListOfStrings.kt . • [2] When colors is copied into the read-only Set colorSet , one of the two Green String s is removed, because it is a duplicate. • [3] Here we create and display a new Set using the + operator. Placing duplicate items into a Set automatically removes those duplicates, so the resulting set is the same. • [4] toMutableSet() produces a MutableSet from a read-only Set . • [5] For a MutableSet , the operators += and -= add and remove elements, as they do with MutableList s. • [6] Test for Set membership using in or contains() The normal mathematical set operations such as union, intersection, difference, etc., are all available. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 169 Maps A Map connects keys to values and looks up a value when given a key. You create a Map by providing key-value pairs to mapOf() . Each key is separated from its associated value by to : // Summary2/ASCIIMap.kt import atomictest.eq fun main () { val ascii = mapOf( A to 65 , B to 66 , C to 67 , I to 73 , J to 74 , K to 75 ) ascii eq {A=65, B=66, C=67, I=73, J=74, K=75} ascii[ B ] eq 66 // [1] ascii.keys eq [A, B, C, I, J, K] ascii.values eq [65, 66, 67, 73, 74, 75] for (entry in ascii) { // [2] print( ${entry.key}:${entry.value}, ) } println() for ((key, value) in ascii) // [3] print( $key:$value, ) println() val mutable = ascii.toMutableMap() // [4] mutable.remove( I ) mutable eq {A=65, B=66, C=67, J=74, K=75} mutable.put( Z , 90 ) mutable eq {A=65, B=66, C=67, J=74, K=75, Z=90} mutable.clear() mutable[ A ]= 100 mutable eq {A=100} Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 170 } /* Output: {A=65, B=66, C=67, I=73, J=74, K=75} 66 [A, B, C, I, J, K] [65, 66, 67, 73, 74, 75] A:65,B:66,C:67,I:73,J:74,K:75, A:65,B:66,C:67,I:73,J:74,K:75, {A=65, B=66, C=67, J=74, K=75} {A=65, B=66, C=67, J=74, K=75, Z=90} {A=100} */ • [1] With a Map , the [] operator is used for lookup using a key. You can produce all the keys using keys and all the values using values . Accessing keys produces a Set because all keys in a Map must already be unique (otherwise you’d have ambiguity during a lookup). • [2] Iterating through a Map produces key-value pairs as map entries. • [3] You can unpack key-value pairs as you iterate. • [4] You can create a MutableMap using mutableMapOf() . Here, we create a MutableMap from a read-only Map using toMutableMap() . Now we can perform operations that modify mutable , such as remove() , put() , and clear() . Square brackets can assign a new key-value pair into mutable . You can also add a pair by saying map += key to value . Property Accessors This appears to be straightforward access to the property i : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 171 // Summary2/PropertyReadWrite.kt package summary2 import atomictest.eq class Holder ( var i: Int) fun main () { val holder = Holder( 10 ) holder.i eq 10 // Read the 'i' property holder.i = 20 // Write to the 'i' property } However, Kotlin calls functions to perform the read and write operations. The default behavior of those functions is to read and write the data stored in i . By creating property accessors , you change the actions that occur during reading and writing. The accessor used to fetch the value of a property is called a getter . To create your own getter, define get() immediately after the property declaration. The accessor used to modify a mutable property is called a setter . To create your own setter, define set() immediately after the property declaration. The order of definition of getters and setters is unimportant, and you can define one without the other. The property accessors in the following example imitate the default implementations. They display additional information so you can see that the property accessors are indeed called during reads and writes. We indent the get() and set() functions to visually associate them with the property, but the actual association happens because they are defined immediately after that property: // Summary2/GetterAndSetter.kt package summary2 class GetterAndSetter { var i: Int = 0 get () { println( get() ) return field } set (value) { println( set($value) ) field = value } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Summary 2 172 } fun main () { val gs = GetterAndSetter() gs.i = 2 println(gs.i) } /* Output: set(2) get() 2 */ Inside the getter and setter, the stored value is manipulated indirectly using the field keyword, which is only accessible within these two functions. You can also create a property that doesn’t have a field , but simply calls the getter to produce a result. If you declare a private property, both accessors become private . You can make the setter private and the getter public . This means you can read the property outside the class, but only change its value inside the class. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁵⁶ . ⁵⁶ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Section III: Usability Computer languages differ not so much in what they make possible, but in what they make easy — Larry Wall , inventor of the Perl language ","Extension Functions Suppose you discover a library that does everything you need … almost. If it only had one or two additional member functions, it would solve your problem perfectly. But it’s not your code—either you don’t have access to the source code or you don’t control it. You’d have to repeat your modifications every time a new version came out. Kotlin’s extension functions effectively add member functions to existing classes. The type you extend is called the receiver . To define an extension function, you precede the function name with the receiver type: fun ReceiverType .extensionFunction() { ... } This adds two extension functions to the String class: // ExtensionFunctions/Quoting.kt package extensionfunctions import atomictest.eq fun String .singleQuote() = '$this' fun String .doubleQuote() = $this fun main () { Hi .singleQuote() eq 'Hi' Hi .doubleQuote() eq Hi } You call extension functions as if they were members of the class. To use extensions from another package, you must import them: ","Extension Functions 175 // ExtensionFunctions/Quote.kt package other import atomictest.eq import extensionfunctions.doubleQuote import extensionfunctions.singleQuote fun main () { Single .singleQuote() eq 'Single' Double .doubleQuote() eq Double } You can access member functions or other extensions using the this keyword. this can be omitted in the same way it can be omitted inside a class, so you don’t need explicit qualification: // ExtensionFunctions/StrangeQuote.kt package extensionfunctions import atomictest.eq // Apply two sets of single quotes: fun String .strangeQuote() = this .singleQuote().singleQuote() // [1] fun String .tooManyQuotes() = doubleQuote().doubleQuote() // [2] fun main () { Hi .strangeQuote() eq ''Hi'' Hi .tooManyQuotes() eq Hi } • [1] this refers to the String receiver. • [2] We omit the receiver object ( this ) of the first doubleQuote() function call. Creating extensions to your own classes can sometimes produce simpler code: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Extension Functions 176 // ExtensionFunctions/BookExtensions.kt package extensionfunctions import atomictest.eq class Book ( val title: String) fun Book .categorize(category: String) = title:  $ title , category: $category fun main () { Book( Dracula ).categorize( Vampire ) eq title:  Dracula , category: Vampire } Inside categorize() , we access the title property without explicit qualification. Ultimately, extension functions are syntax sugar. The function in the previous example can be rewritten as categorize(Book, String) . However, extension functions often make the resulting code more readable, which is the best argument for syntax sugar. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁵⁷ . ⁵⁷ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Named & Default Arguments You can provide argument names during a function call. Named arguments improve code readability. This is especially true for long and complex argument lists—named arguments can be clear enough that the reader can understand a function call without looking at the documentation. In this example, all parameters are Int . Named arguments clarify their meaning: // NamedAndDefaultArgs/NamedArguments.kt package color1 import atomictest.eq fun color (red: Int, green: Int, blue: Int) = ($red, $green, $blue) fun main () { color( 1 , 2 , 3 ) eq // [1] (1, 2, 3) color( red = 76 , // [2] green = 89 , blue = 0 ) eq (76, 89, 0) color( 52 , 34 , blue = 0 ) eq // [3] (52, 34, 0) } • [1] This doesn’t tell you much. You’ll have to look at the documentation to know what the arguments mean. • [2] Now you know what every argument is. • [3] You aren’t required to name all arguments. Named arguments allow you to change the order of the colors. Here, we specify blue first: ","Named & Default Arguments 178 // NamedAndDefaultArgs/ArgumentOrder.kt import color1.color import atomictest.eq fun main () { color(blue = 0 , red = 99 , green = 52 ) eq (99, 52, 0) // Can't put regular arguments after named: // color(red = 255, 255, 0) } You can mix named and regular (positional) arguments, but only other named arguments can follow a named argument. Named arguments are even more useful when combined with default arguments , which are default values for arguments, specified in the function definition: // NamedAndDefaultArgs/Color2.kt package color2 import atomictest.eq fun color ( red: Int = 0 , green: Int = 0 , blue: Int = 0 )= ($red, $green, $blue) fun main () { color( 139 ) eq (139, 0, 0) color(blue = 139 ) eq (0, 0, 139) color( 255 , 165 ) eq (255, 165, 0) color(red = 128 , blue = 128 ) eq (128, 0, 128) } Any argument you don’t provide gets its default value, so you need only give arguments that differ from the defaults. If you have a long argument list, this simplifies the resulting code, making it easier to write and—more importantly—to read. Named and default arguments also work for constructors: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Named & Default Arguments 179 // NamedAndDefaultArgs/Color3.kt package color3 import atomictest.eq class Color ( val red: Int = 0 , val green: Int = 0 , val blue: Int = 0 ){ override fun toString (): String { return ($red, $green, $blue) } } fun main () { Color(red = 77 ).toString() eq (77, 0, 0) } joinToString() is a standard library function that uses default arguments. It combines the contents of an iterable (a list, set or range) into a String . You can specify a separator, a prefix element and a postfix element: // NamedAndDefaultArgs/CreateString.kt import atomictest.eq fun main () { val list = listOf( 1 , 2 , 3 ) list.toString() eq [1, 2, 3] list.joinToString() eq 1, 2, 3 list.joinToString(prefix = ( , postfix = ) ) eq (1, 2, 3) list.joinToString(separator = : ) eq 1:2:3 } The default toString() for a List returns the contents in square brackets, which might not be what you want. The default values for joinToString() s parameters are a comma for separator and empty String s for prefix and postfix . In the above example, we use named and default arguments to specify only the arguments we want to change. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Named & Default Arguments 180 If you use an object as a default argument, a new instance of that object is created for each invocation: // NamedAndDefaultArgs/Evaluation.kt package namedanddefault class DefaultArg fun h (d: DefaultArg = DefaultArg()) = println(d) fun main () { h() h() } /* Sample output: DefaultArg@28d93b30 DefaultArg@1b6d3586 */ The addresses of the Default objects are different for the two calls to h() , showing that there are two distinct objects. Specify argument names when they improve readability. Compare the following two versions: // NamedAndDefaultArgs/CreateString2.kt import atomictest.eq fun main () { val list = listOf( 1 , 2 , 3 ) list.joinToString( .  ,  , ! ) eq 1. 2. 3! list.joinToString(separator = .  , postfix = ! ) eq 1. 2. 3! } It’s hard to guess whether .  or  is a separator unless you memorize the parameter order, which is impractical. As another example of default arguments, trimMargin() is a standard library function that formats multi-line String s. It uses a margin prefix String to establish Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Named & Default Arguments 181 the beginning of each line. trimMargin() trims leading whitespace characters followed by the margin prefix from every line of the source String . It removes the first and last lines if they are blank: // NamedAndDefaultArgs/TrimMargin.kt import atomictest.eq fun main () { val poem =  |->Last night I saw upon the stair |->A little man who wasn ' t there |->He wasn ' t there again today |->Oh, how I wish he ' d go away.  poem.trimMargin() eq ->Last night I saw upon the stair ->A little man who wasn ' t there ->He wasn ' t there again today ->Oh, how I wish he ' d go away.  poem.trimMargin(marginPrefix = |-> ) eq Last night I saw upon the stair A little man who wasn ' t there He wasn ' t there again today Oh, how I wish he ' d go away.  } The | (“pipe”) is the default argument for the margin prefix, and you can replace it with a String of your choosing. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁵⁸ . ⁵⁸ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Overloading Languages without support for default arguments often use overloading to imitate that feature. The term overload refers to the name of a function: You use the same name (“overload” that name) for different functions as long as the parameter lists differ. Here, we overload the member function f() : // Overloading/Overloading.kt package overloading import atomictest.eq class Overloading { fun f () = 0 fun f (n: Int) = n + 2 } fun main () { val o = Overloading() o.f() eq 0 o.f( 11 ) eq 13 } In Overloading , you see two functions with the same name, f() . The function’s signature consists of the name, parameter list and return type. Kotlin distinguishes one function from another by comparing signatures. When overloading functions, the parameter lists must be unique—you cannot overload on return types. The calls show that they are indeed different functions. A function signature also includes information about the enclosing class or the receiver type, if it’s an extension function. Note that if a class already has a member function with the same signature as an extension function, Kotlin prefers the member function. However, you can overload the member function in an extension function: ","Overloading 183 // Overloading/MemberVsExtension.kt package overloading import atomictest.eq class My { fun foo () = 0 } fun My .foo() = 1 // [1] fun My .foo(i: Int) = i + 2 // [2] fun main () { My().foo() eq 0 My().foo( 1 ) eq 3 } It’s senseless to declare an extension that duplicates a member (line [1] ), because it can never be called. However, you can overload a member function (line [2] ) using an extension function by providing a different parameter list. Don’t use overloading to imitate default arguments. That is, don’t do this: // Overloading/WithoutDefaultArguments.kt package withoutdefaultarguments import atomictest.eq fun f (n: Int) = n + 373 fun f () = f( 0 ) fun main () { f() eq 373 } The function without parameters just calls the first function. The two functions can be replaced with a single function by using a default argument: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Overloading 184 // Overloading/WithDefaultArguments.kt package withdefaultarguments import atomictest.eq fun f (n: Int = 0 )=n+ 373 fun main () { f() eq 373 } In both examples you can call the function either without an argument or by passing an integer value. Prefer the form in WithDefaultArguments.kt . When using overloaded functions together with default arguments, calling the overloaded function searches for the “closest” match. In the following example, the foo() call in main() does not call the first version of the function using its default argument of 99, but instead calls the second version, the one without parameters: // Overloading/OverloadedVsDefaultArg.kt package overloadingvsdefaultargs fun foo (n: Int = 99 ) = print( foo-1-$n ) fun foo () { println( foo-2 ) foo( 14 ) } fun main () { foo() } /* Output: foo-2 foo-1-14 */ You can never utilize the default argument of 99 , because foo() always calls the second version of f() . Why is overloading useful? It allows you to express “variations on a theme” more clearly than if you were forced to use different function names. Suppose you want addition functions: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Overloading 185 // Overloading/OverloadingAdd.kt package overloading import atomictest.eq fun addInt (i: Int, j: Int) = i + j fun addDouble (i: Double, j: Double) = i + j fun add (i: Int, j: Int) = i + j fun add (i: Double, j: Double) = i + j fun main () { addInt( 5 , 6 ) eq add( 5 , 6 ) addDouble( 56.23 , 44.77 ) eq add( 56.23 , 44.77 ) } addInt() takes two Int s and returns an Int , while addDouble() takes two Double s and returns a Double . Without overloading, you can’t just name the operation add() , so programmers typically conflate what with how to produce unique names (you can also create unique names using random characters but the typical pattern is to use meaningful information like parameter types). In contrast, the overloaded add() is much clearer. The lack of overloading in a language is not a terrible hardship, but the feature provides valuable simplification, producing more readable code. With overloading, you just say what , which raises the level of abstraction and puts less mental load on the reader. If you want to know how , look at the parameters. Notice also that overloading reduces redundancy: If we must say addInt() and addDouble() , then we essentially repeat the parameter information in the function name. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁵⁹ . ⁵⁹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","when Expressions A large part of computer programming is performing an action when a pattern matches. Anything that simplifies this task is a boon for programmers. Kotlin’s when expres-sions are much nicer than if Expressions when you have more than two or three choices to make. A when expression compares a value against a selection of possibilities. It begins with the keyword when and the parenthesized value to compare. This is followed by a body containing a set of possible matches and their associated actions. Each match is an expression followed by a right arrow -> . The arrow is the two separate characters -and > with no white space between them. The expression is evaluated and compared to the target value. If it matches, the expression to the right of the -> produces the result of the when expression. ordinal() in the following example builds the German word for an ordinal number based on a word for the cardinal number. It matches an integer to a fixed set of numbers to check whether it applies to a general rule or is an exception (which happens painfully often in German): // WhenExpressions/GermanOrdinals.kt package whenexpressions import atomictest.eq val numbers = mapOf( 1 to eins , 2 to zwei , 3 to drei , 4 to vier , 5 to fuenf , 6 to sechs , 7 to sieben , 8 to acht , 9 to neun , 10 to zehn , 11 to elf , 12 to zwoelf , 13 to dreizehn , 14 to vierzehn , 15 to fuenfzehn , 16 to sechzehn , 17 to siebzehn , 18 to achtzehn , 19 to neunzehn , 20 to zwanzig ","when Expressions 187 ) fun ordinal (i: Int): String = when (i) { // [1] 1 -> erste // [2] 3 -> dritte 7 -> siebte 8 -> achte 20 -> zwanzigste else -> numbers.getValue(i) + te // [3] } fun main () { ordinal( 2 ) eq zweite ordinal( 3 ) eq dritte ordinal( 11 ) eq elfte } • [1] This when expression compares i to the match expressions in the body. • [2] The first successful match completes execution of the when expression— here, a String is produced by the when expression which becomes the return value of ordinal() . • [3] The else keyword produces the “fall through” if there are no matches. When we test against 2 , it doesn’t match 1, 3, 7, 8 or 20, and hits the else case, which always appears last in the match list. If you forget the else branch in the example above, the compile-time error is: ‘when’ expression must be exhaustive, add necessary ‘else’ branch . If you treat a when expression as a statement—that is, you don’t use the result of the when —you can omit the else branch. Unmatched values are then just ignored. readLine() in the following example is a standard library function that reads String input from the user. The when expression takes that input and acts accord-ingly: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","when Expressions 188 // WhenExpressions/AnalyzeInput.kt package whenexpressions class Coordinates ( var x: Int, var y: Int) { override fun toString (): String { return ($x, $y) } } fun readInput () { println( |Welcome! Type 'up', 'down', | ' left ' , ' right ' or ' nowhere ' to move; | ' exit ' to exit. .trimMargin()) val coordinates = Coordinates( 0 , 0 ) while ( true ){ println( Your coordinates: $coordinates ) println( Where do you want to move? ) when (readLine()) { // [1] up , u -> coordinates.y--// [2] down , d -> coordinates.y++ left , l -> coordinates.x--right , r -> { // [3] coordinates.x++ } nowhere -> {} // [4] exit -> return // [5] else -> println( Sorry,  + I don't understand you ) } } } fun main () { readInput() } /* Input/Output: Welcome! Type 'up', 'down', 'left', 'right' or 'nowhere' to move; 'exit' to exit. Your coordinates: (0, 0) Where do you want to move? >>> right Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","when Expressions 189 Your coordinates: (1, 0) Where do you want to move? >>> d Your coordinates: (1, 1) Where do you want to move? >>> nowhere Your coordinates: (1, 1) Where do you want to move? >>> exit */ The /* Input/Output: comment is a special case for the book’s output testing system. It automatically provides user input to the program, denoted with >>> . • [1] The result of readLine() is matched against the different options. • [2] You can list several values in one when branch using commas. Here, if the user enters either “up” or “u” we interpret it as a move up. • [3] Multiple actions within a branch must be enclosed in a block body. • [4] “Doing nothing” is expressed with an empty block. • [5] Returning from the outer function is a valid action inside a branch. In this case, the return terminates the call to readInput() . We use a while(true) loop to repeat the interaction until the user explicitly exits the program. Any expression can be an argument for when , and the matches can be any values (not just constants): // WhenExpressions/MatchingAgainstVals.kt fun main () { val yes = yes val no = no val choice = readLine() when (choice) { yes -> println( Hooray! ) no -> println( Too bad! ) } // The same code rewritten with if: if (choice == yes) println( Hooray! ) else if (choice == no) println( Too bad! ) Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","when Expressions 190 } /* Input/Output: >>> yes Hooray! Hooray! */ when expressions can overlap the functionality of if expressions. Because when is more flexible, we prefer it over if when there’s a choice. We can match a Set of values against another Set of values: // WhenExpressions/MixColors.kt package whenexpressions import atomictest.eq fun mixColors (first: String, second: String) = when (setOf(first, second)) { setOf( red , blue ) -> purple setOf( red , yellow ) -> orange setOf( blue , yellow ) -> green else -> unknown } fun main () { mixColors( red , blue ) eq purple mixColors( blue , red ) eq purple mixColors( blue , purple ) eq unknown } Inside mixColors() we use a Set as a when argument and compare it with different Set s. We use a Set because the order of elements is unimportant in this case. We need the same the result when we mix “red” and “blue” as when we mix “blue” and “red.” when has a special form that takes no argument. Omitting the argument means the branches can check different Boolean conditions. You can use any Boolean expres-sion as a branch condition. As an example, we rewrite bmiMetric() introduced in Number Types , first showing the original solution, then using when instead of if : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","when Expressions 191 // WhenExpressions/BmiWhen.kt package whenexpressions import atomictest.eq fun bmiMetricOld ( kg: Double, heightM: Double ): String { val bmi = kg / (heightM * heightM) return if (bmi < 18.5 ) Underweight else if (bmi < 25 ) Normal weight else Overweight } fun bmiMetricWithWhen ( kg: Double, heightM: Double ): String { val bmi = kg / (heightM * heightM) return when { bmi < 18.5 -> Underweight bmi < 25 -> Normal weight else -> Overweight } } fun main () { bmiMetricOld( 72.57 , 1.727 ) eq bmiMetricWithWhen( 72.57 , 1.727 ) } The solution using when is a more elegant way to choose between several options. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁶⁰ . ⁶⁰ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Enumerations An enumeration is a collection of names. Kotlin’s enum class is a convenient way to manage these names: // Enumerations/Level.kt package enumerations import atomictest.eq enum class Level { Overflow, High, Medium, Low, Empty } fun main () { Level.Medium eq Medium } Here, the enum names represent various levels. Note that creating an enum automat-ically generates toString() s for the enum names. By default, you must qualify each reference to an enumeration name, for example, Level.High . To eliminate this extra qualification, use the import statement, which in this case imports all the names from the enumeration into the current namespace (namespaces keep names from colliding with each other): ","Enumerations 193 // Enumerations/EnumImport.kt import atomictest.eq import enumerations.Level.* // [1] fun main () { Overflow eq Overflow High eq High } • [1] The * imports all the names inside the Level enumeration, but not the name Level . You can even import enum values into the same file where the enum class is defined: // Enumerations/RecursiveEnumImport.kt package enumerations import atomictest.eq import enumerations.Size.* // [1] enum class Size { Tiny, Small, Medium, Large, Huge, Gigantic } fun main () { Gigantic eq Gigantic // [2] Size.values().toList() eq // [3] listOf(Tiny, Small, Medium, Large, Huge, Gigantic) Tiny.ordinal eq 0 // [4] Huge.ordinal eq 4 } • [1] Note how we import values even before they appear in the file. • [2] After the import , we no longer need to qualify access to the enumeration names. • [3] You can iterate through the enumeration names using values() . values() returns an Array , so we call toList() to convert it to a List . • [4] There’s an ordinal property in every enum constant that is incremented each time a new value is created. The first declared constant has an ordinal value of zero. You can perform different actions for different enum entries using a when expression. Here we import the name Level , as well as all its entries: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Enumerations 194 // Enumerations/CheckingOptions.kt package enumerations import atomictest.eq import enumerations.Level import enumerations.Level.* fun checkLevel (level: Level) { when (level) { Overflow -> println( >>> Overflow! ) Empty -> println( Alert: Empty ) else -> println( Level $level OK ) } } fun main () { checkLevel(Empty) checkLevel(Low) checkLevel(Overflow) } /* Output: Alert: Empty Level Low OK >>> Overflow! */ checkLevel() performs specific actions for only two of the constants, while behaving ordinarily (the else case) for all other options. An enumeration is a special kind of class with a fixed number of instances, all listed within the class body. In other ways, an enum class behaves like a regular class, so you can define member properties and functions: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Enumerations 195 // Enumerations/Direction.kt package enumerations import atomictest.eq import enumerations.Direction.* enum class Direction ( val notation: String) { North( N ), South( S ), East( E ), West( W ); val opposite: Direction get () = when ( this ){ North -> South South -> North West -> East East -> West } } fun main () { North.notation eq N North.opposite eq South West.opposite.opposite eq West North.opposite.notation eq S } The Direction class contains a notation property holding a different value for each instance. You pass values for the notation constructor parameter in parentheses ( North(N) ), just like you construct an instance of a regular class. The opposite property has a getter that computes the result dynamically whenever it is accessed. when doesn’t require an else branch if you cover all possible enum entries. Enumerations can make your code more readable, which is always desirable. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁶¹ . ⁶¹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Data Classes Kotlin tries to eliminate repetition wherever it can. The class mechanism performs a fair amount of work for you. However, creating classes that primarily hold data still requires a significant amount of repetitive code. When you need a class that’s essentially a data holder, data classes simplify your code and perform common tasks. You define a data class using the data keyword, which tells Kotlin to generate additional functionality. Each constructor parameter must be preceded by var or val : // DataClasses/Simple.kt package dataclasses import atomictest.eq data class Simple ( val arg1: String, var arg2: Int ) fun main () { val s1 = Simple( Hi , 29 ) val s2 = Simple( Hi , 29 ) s1 eq s2 } /* Output: Simple(arg1=Hi, arg2=29) */ This example reveals two features of data classes: 1. The output produced by s1 eq s2 is different than what we usually see; it includes the parameter names and values of the data held by the object. data classes display objects in a nice, readable format without requiring any additional code. ","Data Classes 197 2. If you create two instances of the same data class containing identical data (equal values for properties), you probably also want those two instances to be equal. To achieve that behavior for a regular class, you must define a special function equals() to compare instances. In data classes, this function is automatically generated; it compares the values of all properties specified as constructor parameters. Next we define a data class Contact and an ordinary class Person , showing how they differ: // DataClasses/DataClasses.kt package dataclasses import atomictest.* data class Contact ( val name: String, val number: String ) class Person ( val name: String) fun main () { Contact( Miffy , 1-234-567890 ) eq Contact( Miffy , 1-234-567890 ) // These seem the same, but they're not: Person( Cleo ) neq Person( Cleo ) } /* Sample output: Contact(name=Miffy, number=1-234-567890) dataclasses.Person@54bedef2 */ Because the Person class is defined without the data keyword, two instances containing the same name are not equal, which doesn’t seem logical. Fortunately, creating Contact as a data class produces a reasonable result. Notice the difference between the display format of the data class, and Person , which just shows default object information. Another useful function generated for every data class is copy() , which creates a Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Data Classes 198 new object containing the data from the current object. However, it also allows you to change selected values in the process: // DataClasses/CopyDataClass.kt package dataclasses import atomictest.eq data class DetailedContact ( val name: String, val surname: String, val number: String, val address: String ) fun main () { val contact = DetailedContact( Miffy , Miller , 1-234-567890 , 1600 Amphitheatre Parkway ) val newContact = contact.copy( number = 098-765-4321 , address = Brandschenkestrasse 110 ) newContact eq DetailedContact( Miffy , Miller , 098-765-4321 , Brandschenkestrasse 110 ) } The parameter names for copy() are identical to the constructor parameters. All arguments have default values that are equal to the current values, so you provide only the ones you want to replace. HashMap and HashSet Creating a data class also generates an appropriate hash function so that objects can be used as keys in HashMap s and HashSet s: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Data Classes 199 // DataClasses/HashCode.kt package dataclasses import atomictest.eq data class Key ( val name: String, val id: Int) fun main () { val korvo: Key = Key( Korvo , 19 ) korvo.hashCode() eq -2041757108 val map = HashMap<Key, String>() map[korvo] = Alien map[korvo] eq Alien val set = HashSet<Key>() set .add(korvo) set .contains(korvo) eq true } The hashCode() is used in conjunction with equals() to rapidly look up a Key in a HashMap or a HashSet . Creating a correct hashCode() by hand is tricky and error-prone, so it is quite beneficial to have the data class do it for you. You can learn more about hash functions in Wikipedia⁶² . Exercises and solutions for this atom can be found at AtomicKotlin.com ⁶³ . ⁶² https://en.wikipedia.org/wiki/Hash_function ⁶³ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Destructuring Declarations Suppose you want to return more than one item from a function, such as a result along with some information about that result. The Pair class, which is part of the standard library, allows you to return two values: // Destructuring/Pairs.kt package destructuring import atomictest.eq fun compute (input: Int): Pair<Int, String> = if (input > 5 ) Pair(input * 2 , High ) else Pair(input * 2 , Low ) fun main () { compute( 7 ) eq Pair( 14 , High ) compute( 4 ) eq Pair( 8 , Low ) val result = compute( 5 ) result.first eq 10 result.second eq Low } We specify the return type of compute() as Pair<Int, String> .A Pair is a parameterized type, like List or Set . Returning multiple values is helpful, but we’d also like a convenient way to unpack the results. As shown above, you can access the components of a Pair using its first and second properties, but you can also declare and initialize several identifiers simultaneously using a destructuring declaration : val ( a, b, c) = composedValue ","Destructuring Declarations 201 This destructures a composed value and positionally assigns its components. The syntax differs from defining a single identifier—for destructuring, you put the names of the identifiers inside parentheses. Here’s a destructuring declaration for the Pair returned from compute() : // Destructuring/PairDestructuring.kt import destructuring.compute import atomictest.eq fun main () { val ( value, description) = compute( 7 ) value eq 14 description eq High } The Triple class combines three values, but that’s as far as it goes. This is intentional: if you need to store more values, or if you find yourself using many Pair s or Triple s, consider creating special classes instead. data classes automatically allow destructuring declarations: // Destructuring/Computation.kt package destructuring import atomictest.eq data class Computation ( val data: Int, val info: String ) fun evaluate (input: Int) = if (input > 5 ) Computation(input * 2 , High ) else Computation(input * 2 , Low ) fun main () { val ( value, description) = evaluate( 7 ) value eq 14 description eq High } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Destructuring Declarations 202 It’s clearer to return a Computation instead of a Pair<Int, String> . Choosing a good name for the result is almost as important as choosing a good self-explanatory name for the function itself. Adding or removing Computation information is simpler if it’s a separate class rather than a Pair . When you unpack an instance of a data class, you must assign values to the new identifiers in the same order you define the properties in the class: // Destructuring/Tuple.kt package destructuring import atomictest.eq data class Tuple ( val i: Int, val d: Double, val s: String, val b: Boolean, val l: List<Int> ) fun main () { val tuple = Tuple( 1 , 3.14 , Mouse , false , listOf()) val ( i, d, s, b, l) = tuple i eq 1 d eq 3.14 s eq Mouse b eq false l eq listOf() val ( _, _, animal) = tuple // [1] animal eq Mouse } • [1] If you don’t need some of the identifiers, you may use underscores instead of their names, or omit them completely if they appear at the end. Here, the unpacked values 1 and 3.14 are discarded using underscores, Mouse is captured into animal , and false and the empty List are discarded because they are at the end of the list. The properties of a data class are assigned by order, not by name. If you destructure an object and later add a property anywhere except the end of its data class, that Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Destructuring Declarations 203 new property will be destructured on top of your previous identifier, producing unexpected results (see Exercise 3). Especially if your data class has properties with identical types (so the compiler can’t detect misuse), it’s safer to avoid destructuring custom data classes. Destructuring library data classes like Pair or Triple is safe, because they don’t change. Using a for loop, you can iterate over a Map or a List of pairs (or other data classes) and destructure each element: // Destructuring/ForLoop.kt import atomictest.eq fun main () { var result =  val map = mapOf( 1 to one , 2 to two ) for ((key, value) in map) { result += $key = $value,  } result eq 1 = one, 2 = two,  result =  val listOfPairs = listOf(Pair( 1 , one ), Pair( 2 , two )) for ((i, s) in listOfPairs) { result += ($i, $s),  } result eq (1, one), (2, two),  } Iterating over a List with index uses the same destructuring feature: // Destructuring/LoopWithIndex.kt import atomictest.trace fun main () { val list = listOf( 'a' , 'b' , 'c' ) for ((index, value) in list.withIndex()) { trace( $index:$value ) } trace eq 0:a 1:b 2:c } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Destructuring Declarations 204 withIndex is an extension function defined in the Kotlin standard library which returns a collection of IndexedValue s, which can be destructured. Destructuring declarations are only allowed for local var s and val s, and cannot be used to create class properties. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁶⁴ . ⁶⁴ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Nullable Types Consider a function that will sometimes produce “no result.” When this happens, the function doesn’t produce an error per se. Nothing went wrong, there’s just “no answer.” A good example is retrieving a value from a Map . If the Map doesn’t contain a value for a given key, it can’t give you an answer and returns a null reference to indicate “no value”: // NullableTypes/NullInMaps.kt import atomictest.eq fun main () { val map = mapOf( 0 to yes , 1 to no ) map[ 2 ] eq null } Languages like Java allow a result to be either null or a meaningful value. Unfortunately, if you treat null the same way you treat a meaningful value, you get a dramatic failure (In Java, this produces a NullPointerException ; in a more primitive language like C, a null pointer can crash the process or even the operating system or machine). The creator of the null reference, Tony Hoare⁶⁵ , refers to it as “my billion-dollar mistake” (although it has arguably cost much more than that). One possible solution to this problem is for a language to never allow null s in the first place, and instead introduce a special “no value” indicator. Kotlin might have done this, except that it must interact with Java, and Java uses null s. Kotlin’s solution is arguably the best compromise. Types default to non-nullable. However, if something can produce a null result, you must append a question mark to the type name to explicitly tag that result as nullable: ⁶⁵ https://en.wikipedia.org/wiki/Tony_Hoare ","Nullable Types 206 // NullableTypes/NullableTypes.kt import atomictest.eq fun main () { val s1 = abc // [1] // Compile-time error: // val s2: String = null // [2] // Nullable definitions: val s3: String? = null // [3] val s4: String? = s1 // [4] // Compile-time error: // val s5: String = s4 // [5] val s6 = s4 // [6] s1 eq abc s3 eq null s4 eq abc s6 eq abc } • [1] All the var s and val s we’ve created until now are automatically non-nullable. s1 can’t contain a null reference. • [2] The compile-time error is: null can not be a value of a non-null type String . • [3] To define an identifier that can contain a null reference, you put a ? at the end of the type name. Such an identifier can contain either null or a regular value. • [4] Both null s and regular non-nullable values can be stored in a nullable type. • [5] You can’t assign an identifier of a nullable type to an identifier of a non-null type. Kotlin emits: Type mismatch: inferred type is String? but String was expected. Even if the actual value is non-null as in this case (we know it’s abc ), Kotlin won’t allow it because they are two different types. • [6] If you use type inference, Kotlin produces the appropriate type. Here, s6 is nullable because s4 is nullable. Even though it looks like we just modify an existing type by adding a ? at the end, we’re actually specifying a different type . For example, String and String? are two Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Nullable Types 207 different types. The String? type forbids the operations in lines [2] and [5] , thus guaranteeing that a value of a non-nullable type is never null . Retrieving a value from a Map using square brackets produces a nullable result, because the underlying Map implementation comes from Java: // NullableTypes/NullableInMap.kt import atomictest.eq fun main () { val map = mapOf( 0 to yes , 1 to no ) val first: String? = map[ 0 ] val second: String? = map[ 2 ] first eq yes second eq null } Why is it important to know that a value can’t be null ? Many operations implicitly assume a non-null result. For example, calling a member function will fail with an exception if the receiver value is null . In Java such a call will fail with a NullPointerException (often abbreviated NPE ). Because almost any value can be null in Java, any function invocation can fail this way, so you must write code to check for null results, or rely on other parts of the code to guard against null s. In Kotlin you can’t simply dereference (call a member function or access a member property) a value of a nullable type: // NullableTypes/Dereference.kt import atomictest.eq fun main () { val s1: String = abc val s2: String? = s1 s1.length eq 3 // [1] // Doesn't compile: // s2.length // [2] } You can access members of a non-nullable type as in [1] . If you reference members of a nullable type, as in [2] , Kotlin emits an error. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Nullable Types 208 Values of most types are stored as references to the objects in memory. That’s the meaning of the term dereference —to access an object, you retrieve its value from memory. The most straightforward way to ensure that dereferencing a nullable type won’t throw a NullPointerException is to explicitly check that the reference is not null : // NullableTypes/ExplicitCheck.kt import atomictest.eq fun main () { val s: String? = abc if (s != null ) s.length eq 3 } After the explicit if -check, Kotlin allows you to dereference a nullable. But writing this if whenever you work with nullable types is too noisy for such a common operation. Kotlin has concise syntax to alleviate this problem, which you’ll learn about in subsequent atoms. Whenever you create a new class or interface, Kotlin automatically includes nullable and non-nullable types: // NullableTypes/Amphibian.kt package nullabletypes interface Amphibian class Frog : Amphibian enum class Species { Frog, Toad, Salamander, Caecilian } fun main () { val a1: Amphibian = Frog() val a2: Amphibian? = null val f1: Frog = Frog() val f2: Frog? = null val at1: Species = Species.Toad val at2: Species? = null } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Nullable Types 209 As you can see, we didn’t do anything special to produce the complementary nullable types—they’re available by default. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁶⁶ . ⁶⁶ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Safe Calls & the Elvis Operator Kotlin provides convenient operations for handling nullability. Nullable types come with numerous restrictions. You can’t simply dereference an identifier of a nullable type: // SafeCallsAndElvis/DereferenceNull.kt fun main () { val s: String? = null // Doesn't compile: // s.length // [1] } Uncommenting [1] produces a compile-time error: Only safe ( ?. ) or non-null asserted ( !!. ) calls are allowed on a nullable receiver of type String? . A safe call replaces the dot ( . ) in a regular call with a question mark and a dot ( ?. ), without intervening space. Safe calls access members of a nullable in a way that ensures no exceptions are thrown. They only allow you to perform an operation when the receiver is not null : // SafeCallsAndElvis/SafeOperation.kt package safecalls fun String .echo() { println( this .toUpperCase()) println( this ) println( this .toLowerCase()) } fun main () { val s1: String? = Howdy! s1 ?. echo() // [1] val s2: String? = null ","Safe Calls & the Elvis Operator 211 s2 ?. echo() // [2] } /* Output: HOWDY! Howdy! howdy! */ Line [1] calls echo() and produces output, while line [2] does nothing, since s2 is null . Safe calls are a clean way to capture the result of an invocation: // SafeCallsAndElvis/SafeCall.kt package safecalls import atomictest.eq fun checkLength (s: String?, expected: Int?) { val length1 = if (s != null ) s.length else null // [1] val length2 = s ?. length // [2] length1 eq expected length2 eq expected } fun main () { checkLength( abc , 3 ) checkLength( null , null ) } Line [2] achieves the same effect as line [1] . If the receiver is not null it performs a normal access ( s.length ). If the receiver is null it doesn’t perform the s.length call (which would cause an exception), but produces null for the expression. If the null value produced by a safe call doesn’t meet your needs, the Elvis operator provides an alternative. This operator is a question mark followed by a colon ( ?: ), with no intervening space. It is named for an emoticon of the musician Elvis Presley, and is also a play on the words “else-if” (which sounds vaguely like “Elvis”). ? and : are used in a number of programming languages as a shorthand for an if-then-else expression. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Safe Calls & the Elvis Operator 212 If the expression on the left of ?: is not null , that expression becomes the result. If the left-hand expression is null , then the expression on the right of the ?: becomes the result: // SafeCallsAndElvis/ElvisOperator.kt import atomictest.eq fun main () { val s1: String? = abc (s1 ?: --- ) eq abc val s2: String? = null (s2 ?: --- ) eq --- } s1 is not null , so the Elvis operator produces abc as the result. Because s2 is null , the Elvis operator produces the alternate result of --- . The Elvis operator is typically used after a safe call, to produce a meaningful value instead of the default null , as you see in [2] : // SafeCallsAndElvis/ElvisCall.kt package safecalls import atomictest.eq fun checkLength (s: String?, expected: Int) { val length1 = if (s != null ) s.length else 0 // [1] val length2 = s ?. length ?: 0 // [2] length1 eq expected length2 eq expected } fun main () { checkLength( abc , 3 ) checkLength( null , 0 ) } This checkLength() function is quite similar to the one in SafeCall.kt above. The expected parameter type is now non-nullable. [1] and [2] produce zero instead of null . Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Safe Calls & the Elvis Operator 213 Safe calls allow you to write chained calls concisely, when some elements in the chain might be null and you’re only interested in the final result: // SafeCallsAndElvis/ChainedCalls.kt package safecalls import atomictest.eq class Person ( val name: String, var friend: Person? = null ) fun main () { val alice = Person( Alice ) alice.friend ?. friend ?. name eq null // [1] val bob = Person( Bob ) val charlie = Person( Charlie , bob) bob.friend = charlie bob.friend ?. friend ?. name eq Bob // [2] (alice.friend ?. friend ?. name ?: Unknown ) eq Unknown // [3] } When you chain access to several members using safe calls, the result is null if any intermediate expressions are null . • [1] The property alice.friend is null , so the rest of the calls return null . • [2] Here, all intermediate calls produce meaningful values. • [3] An Elvis operator after the chain of safe calls provides an alternate value if any intermediate element is null . Exercises and solutions for this atom can be found at AtomicKotlin.com ⁶⁷ . ⁶⁷ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Non-null Assertions A second approach to the problem of nullable types is to have special knowledge that the reference in question isn’t null . This claim is achieved using the double exclamation point, !! , called the non-null assertion . If this looks alarming, it should: believing that something can’t be null is the source of most null -related program failures (the rest come from not realizing that a null can happen). x!! means “forget the fact that x might be null —I guarantee that it’s not null .” x!! produces the reference if x isn’t null ; otherwise it throws an exception: // NonNullAssertions/NonNullAssert.kt import atomictest.* fun main () { val s1: String? = abc s1 !! eq abc val s2: String? = null // Ignore nullability: capture { val s3: String = s2 !! } eq NullPointerException } The definition val s3: String = s2!! tells Kotlin to ignore what it thinks it knows about s2 and just assign it to s3 , which is a non-nullable reference. Fortu-nately, there’s run-time support that throws an exception when it turns out s2 is null . A NullPointerException comes from a non-null asserted call ( null pointer excep-tions are often abbreviated as NPEs). Ordinarily you won’t use the !! by itself, but instead in conjunction with a . dereference: ","Non-null Assertions 215 // NonNullAssertions/NonNullAssertCall.kt import atomictest.eq fun main () { val s1: String? = abc s1 !! .length eq 3 } If you limit yourself to a single non-null asserted call per line, it’s easier to locate a failure when the exception gives you a line number. The safe call ?. is a single operator, but a non-null asserted call consists of two operators: the non-null assertion ( !! ) and a dereference ( . ). As you saw in NonNullAssert.kt , you can use a non-null assertion by itself. You should avoid non-null assertions and prefer safe calls or explicit checks. Non-null assertions were introduced to enable interaction between Kotlin and Java, and for the rare cases when Kotlin isn’t smart enough to ensure the necessary checks are performed. If you frequently use non-null assertions in your code for the same operation, it’s better to introduce a separate function with a specific assertion describing the problem. Suppose your program logic requires a particular key to be present in a Map , and you prefer getting an exception instead of silently doing nothing if the key is absent. Instead of extracting the value with the usual approach (square brackets), getValue() throws NoSuchElementException if the key is missing: // NonNullAssertions/ValueFromMap.kt import atomictest.* fun main () { val map = mapOf( 1 to one ) map[ 1 ] !! .toUpperCase() eq ONE map.getValue( 1 ).toUpperCase() eq ONE capture { map[ 2 ] !! .toUpperCase() } eq NullPointerException capture { map.getValue( 2 ).toUpperCase() } eq NoSuchElementException:  + Key 2 is missing in the map. } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Non-null Assertions 216 Throwing the more specific NoSuchElementException gives you better details when something goes wrong. In general, prefer safe calls and special functions that throw detailed exceptions instead of non-null asserted calls. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁶⁸ . ⁶⁸ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Extensions for Nullable Types Sometimes it’s not what it looks like. s?.f() implies that s is nullable—otherwise you could simply call s.f() . Similarly, t.f() seems to imply that t is non-nullable because Kotlin doesn’t require a safe call or programmatic check. However, t is not necessarily non-nullable. The Kotlin standard library provides String extension functions, including: • isNullOrEmpty() : Tests whether the receiver String is null or empty. • isNullOrBlank() : Performs the same check as isNullOrEmpty() and allows the receiver String to consist solely of whitespace characters, including tabs ( t ) and newlines ( n ). Here’s a basic test of these functions: // NullableExtensions/StringIsNullOr.kt import atomictest.eq fun main () { val s1: String? = null s1.isNullOrEmpty() eq true s1.isNullOrBlank() eq true val s2 =  s2.isNullOrEmpty() eq true s2.isNullOrBlank() eq true val s3: String =  tn s3.isNullOrEmpty() eq false s3.isNullOrBlank() eq true } The function names suggest they are for nullable types. However, even though s1 is nullable, you can call isNullOrEmpty() or isNullOrBlank() without a safe call ","Extensions for Nullable Types 218 or explicit check. That’s because these are extension functions on the nullable type String? . We can rewrite isNullOrEmpty() as a non-extension function that takes the nullable String s as a parameter: // NullableExtensions/NullableParameter.kt package nullableextensions import atomictest.eq fun isNullOrEmpty (s: String?): Boolean = s == null || s.isEmpty() fun main () { isNullOrEmpty( null ) eq true isNullOrEmpty(  ) eq true } Because s is nullable, we explicitly check to see if it’s either null or empty. The expression s == null || s.isEmpty() uses short-circuiting : if the first part of the expression is true , the rest of the expression is not evaluated, thus preventing a null pointer exception. An extension function has an additional parameter: the receiver this . An extension function’s this becomes nullable by adding ? to the class that’s being extended: // NullableExtensions/Definition.kt package nullableextensions import atomictest.eq fun String ?. isNullOrEmpty(): Boolean = this == null || this .isEmpty() fun main () {  .isNullOrEmpty() eq true } isNullOrEmpty() is more readable as an extension function. Take care when using extensions for nullable types. They are great for simple cases like isNullOrEmpty() and isNullOrBlank() , especially with self-explanatory names that imply the receiver might be null . In general, however, it’s better to Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Extensions for Nullable Types 219 declare regular (non-nullable) extensions. Safe calls and explicit checks clarify the receiver’s nullability, while extensions for nullable types may conceal nullability and confuse the reader of your code (probably, “future you”). Exercises and solutions for this atom can be found at AtomicKotlin.com ⁶⁹ . ⁶⁹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Introduction to Generics Generics create parameterized types : components that work across multi-ple types. The term “generic” means “pertaining or appropriate to large groups of classes.” The original intent of generics in programming languages was to provide the programmer maximum expressiveness when writing classes or functions, by loosening type constraints on those classes or functions. One of the most compelling initial motivations for generics is to create collection classes, which you’ve seen in the List s, Set s and Map s used for the examples in this book. A collection is an object that holds other objects. Many programs require you to hold a group of objects while you use them, so collections are one of the most reusable of class libraries. Let’s look at a class that holds a single object. This class specifies the exact type of that object: // IntroGenerics/RigidHolder.kt package introgenerics import atomictest.eq data class Automobile ( val brand: String) class RigidHolder ( private val a: Automobile) { fun getValue () = a } fun main () { val holder = RigidHolder(Automobile( BMW )) holder.getValue() eq Automobile(brand=BMW) } ","Introduction to Generics 221 RigidHolder is not a very reusable tool; it can’t hold anything but an Automobile . We would prefer not to write a new type of holder for every different type. To achieve this, we use a type parameter instead of Automobile . To define a generic type, add angle brackets ( <> ) containing one or more generic placeholders and put this generic specification after the class name. Here, the generic placeholder T represents the unknown type and is used within the class as if it were a regular type: // IntroGenerics/GenericHolder.kt package introgenerics import atomictest.eq class GenericHolder <T>( // [1] private val value: T ){ fun getValue (): T = value } fun main () { val h1 = GenericHolder(Automobile( Ford )) val a: Automobile = h1.getValue() // [2] a eq Automobile(brand=Ford) val h2 = GenericHolder( 1 ) val i: Int = h2.getValue() // [3] i eq 1 val h3 = GenericHolder( Chartreuse ) val s: String = h3.getValue() // [4] s eq Chartreuse } [1] GenericHolder stores a T , and its member function getValue() returns a T . When you call getValue() as in [2] , [3] or [4] , the result is automatically the right type. It seems like we might be able to solve this problem with a “universal type”—a type that is the parent of all other types. In Kotlin, this universal type is called Any . As the name implies, Any allows any type of argument. If you want to pass a variety of types to a function and they have nothing in common, Any solves the problem. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Introduction to Generics 222 At a glance, it looks like we might be able to use Any instead of T in Generi-cHolder.kt : // IntroGenerics/AnyInstead.kt package introgenerics import atomictest.eq class AnyHolder ( private val value: Any) { fun getValue (): Any = value } class Dog { fun bark () = Ruff! } fun main () { val holder = AnyHolder(Dog()) val any = holder.getValue() // Doesn't compile: // any.bark() val genericHolder = GenericHolder(Dog()) val dog = genericHolder.getValue() dog.bark() eq Ruff! } Any does in fact work for simple cases, but as soon as we need the specific type—to call bark() for the Dog —the loss of information that comes from assigning a Dog to Any just doesn’t do what we need. When we pass a Dog as an Any , the result is just an Any , which has no bark() . Using generics retains the information that, in this case, we actually have a Dog , which means we can perform Dog operations on the object returned by getValue() . Generic Functions To define a generic function, specify a generic type parameter by putting the generic specification before the function name: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Introduction to Generics 223 // IntroGenerics/GenericFunction.kt package introgenerics import atomictest.eq fun < T > identity(arg: T): T = arg fun main () { identity( Yellow ) eq Yellow identity( 1 ) eq 1 val d: Dog = identity(Dog()) d.bark() eq Ruff! } d has type Dog because identity() is a generic function and returns a T . The Kotlin standard library contains many generic extension functions for collec-tions. To write a generic extension function, put the generic specification before the receiver. For example, notice how first() and firstOrNull() are defined: // IntroGenerics/GenericListExtensions.kt package introgenerics import atomictest.eq fun < T > List<T>.first(): T { if (isEmpty()) throw NoSuchElementException( Empty List ) return this [ 0 ] } fun < T > List<T>.firstOrNull(): T? = if (isEmpty()) null else this [ 0 ] fun main () { listOf( 1 , 2 , 3 ).first() eq 1 val i: Int? = // [1] listOf( 1 , 2 , 3 ).firstOrNull() i eq 1 val s: String? = // [2] Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Introduction to Generics 224 listOf<String>().firstOrNull() s eq null } first() and firstOrNull() work with any kind of List . To return a T , they must be generic functions. Notice how firstOrNull() specifies a nullable return type. Line [1] shows that calling the function on List<Int> returns the nullable type Int? . Line [2] shows that calling firstOrNull() on List<String> returns String? . Kotlin requires the ? on lines [1] and [2] —take them out and see the error messages. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁷⁰ . ⁷⁰ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Extension Properties Just as functions can be extension functions, properties can be extension properties . The receiver type specification for extension properties is similar to the syntax for extension functions—the extended type comes right before the function or property name: fun ReceiverType .extensionFunction() { ... } val ReceiverType.extensionProperty: PropType get () { ... } An extension property requires a custom getter. Since extensions don’t belong to the class they extend, they don’t have the necessary access to store the value of the extension property—thus there can be no set() . The property value must be computed during each access: // ExtensionProperties/StringIndices.kt package extensionproperties import atomictest.eq val String.indices: IntRange get () = 0 until length fun main () { abc .indices eq 0. . 2 } It’s possible to convert any extension function without parameters into a property, but we don’t recommend this. The reasons described in Property Accessors for choosing between properties and functions also apply to extension properties. Preferring a property over a function makes sense only if it’s simple enough and improves readability. You can define a generic extension property. For example, let’s convert firstOr-Null() from Introduction to Generics to an extension property: ","Extension Properties 226 // ExtensionProperties/GenericListExt.kt package extensionproperties import atomictest.eq val < T> List<T>.firstOrNull: T? get () = if (isEmpty()) null else this [ 0 ] fun main () { listOf( 1 , 2 , 3 ).firstOrNull eq 1 listOf<String>().firstOrNull eq null } The Kotlin Style Guide⁷¹ recommends a function over a property if the function throws an exception. When the generic argument type isn’t used, you may replace it with * . This is called a star projection : // ExtensionProperties/ListOfStar.kt package extensionproperties import atomictest.eq val List<*>.indices: IntRange get () = 0 until size fun main () { listOf( 1 ).indices eq 0. . 0 listOf( 'a' , 'b' , 'c' , 'd' ).indices eq 0. . 3 emptyList<Int>().indices eq IntRange.EMPTY } When you use List<*> , you lose all specific information about the type contained in the List . For example, an element of a List<*> can only be assigned to Any? : ⁷¹ https://kotlinlang.org/docs/reference/coding-conventions.html Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Extension Properties 227 // ExtensionProperties/AnyFromListOfStar.kt import atomictest.eq fun main () { val list: List<*> = listOf( 1 , 2 ) val any: Any? = list[ 0 ] any eq 1 } We have no information whether a value stored in a List<*> is nullable or not, which is why it can be only assigned to a nullable Any? type. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁷² . ⁷² https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","break & continue break and continue allow you to “jump” within a loop. Early programmers wrote directly to the processor, using either numerical opcodes as instructions, or assembly language , which translates into opcodes. This kind of programming is as low-level as you can get. For example, many coding decisions were facilitated by “jumping” directly to other places in the code. Early higher-level languages (including FORTRAN, ALGOL, Pascal, C and C++) duplicated this practice by implementing a goto keyword. goto made assembly-language programmers more comfortable as they transitioned to higher-level languages. As we accumulated more experience, however, the pro-gramming community discovered that unconditional jumps produce complicated and un-maintainable code. This generated a large backlash against goto , and most subsequent languages have avoided any kind of unconditional jump. Kotlin provides a constrained jump in the form of break and continue . These are tied to the looping constructs for , while and do-while —you can only use break and continue within such loops. In addition, continue can only jump to the beginning of a loop, and break can only jump to the end of a loop. In practice you rarely use break and continue when writing new Kotlin code. These features are artifacts from earlier languages. Although they are occasionally useful, you’ll learn in this book that Kotlin provides superior mechanisms. Here’s an example with a for loop containing both a continue and a break : ","break & continue 229 // BreakAndContinue/ForControl.kt import atomictest.eq fun main () { val nums = mutableListOf( 0 ) for (i in 4 until 100 step 4 ){ // [1] if (i == 8 ) continue // [2] if (i == 40 ) break // [3] nums.add(i) } // [4] nums eq listOf( 0 , 4 , 12 , 16 , 20 , 24 , 28 , 32 , 36 ) } The example aggregates Int s into a mutable List . The continue at [2] jumps back to the beginning of the loop, which is the opening brace at [1] . It “continues” execution starting with the next iteration of the loop. Note that the code following continue inside the for loop body is not executed: nums.add(i) is not called when i == 8 so you don’t see it in the resulting nums . When i == 40 , break is executed at [3] , which “breaks out” of the for loop by jumping to the end of its scope at [4] . The numbers beginning at 40 are not added to the resulting List because the for loop stops executing. Lines [2] and [3] are interchangeable because their logic doesn’t overlap. Try swapping the lines and verify that the output doesn’t change. We can rewrite ForControl.kt using a while loop: // BreakAndContinue/WhileControl.kt import atomictest.eq fun main () { val nums = mutableListOf( 0 ) var i= 0 while (i < 100 ){ i += 4 if (i == 8 ) continue if (i == 40 ) break nums.add(i) } nums eq Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","break & continue 230 listOf( 0 , 4 , 12 , 16 , 20 , 24 , 28 , 32 , 36 ) } The break and continue behavior remains the same, as it does for a do -while loop: // BreakAndContinue/DoWhileControl.kt import atomictest.eq fun main () { val nums = mutableListOf( 0 ) var i= 0 do { i += 4 if (i == 8 ) continue if (i == 40 ) break nums.add(i) } while (i < 100 ) nums eq listOf( 0 , 4 , 12 , 16 , 20 , 24 , 28 , 32 , 36 ) } A do -while loop always executes at least once, because the while test is at the end of the loop. Labels Plain break and continue can jump no further than the boundaries of their local loop. Labels allow break and continue to jump to the boundaries of enclosing loops, so you aren’t limited to the scope of the current loop. You create a label by using label@ , where label can be any name. Here, the label is outer : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","break & continue 231 // BreakAndContinue/ForLabeled.kt import atomictest.eq fun main () { val strings = mutableListOf<String>() outer @ for (c in 'a' .. 'e' ){ for (i in 1. . 9 ){ if (i == 5 ) continue @outer if ( $c$i == c3 ) break @outer strings.add( $c$i ) } } strings eq listOf( a1 , a2 , a3 , a4 , b1 , b2 , b3 , b4 , c1 , c2 ) } The labeled continue expression continue@outer continues back to the label outer@ . The labeled break expression break@outer finds the end of the block named outer@ , and proceeds from there. As expected, labels also work with while and do -while : // BreakAndContinue/WhileLabeled.kt import atomictest.eq fun main () { val strings = mutableListOf<String>() var c= 'a' -1 outer @ while (c < 'f' ){ c += 1 var i= 0 do { i++ if (i == 5 ) continue @outer if ( $c$i == c3 ) break @outer strings.add( $c$i ) } while (i < 10 ) } strings eq listOf( a1 , a2 , a3 , a4 , b1 , b2 , b3 , b4 , c1 , c2 ) } Code produced using break and continue is not especially understandable. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","break & continue 232 The last sample can be rewritten as: // BreakAndContinue/Improved.kt import atomictest.eq fun main () { val strings = mutableListOf<String>() for (c in 'a' .. 'c' ){ for (i in 1. . 4 ){ val value = $c$i if (value < c3 ){ // [1] strings.add(value) } } } strings eq listOf( a1 , a2 , a3 , a4 , b1 , b2 , b3 , b4 , c1 , c2 ) } This is far more comprehensible. In line [1] , we only add String s that occur (alphabetically) before c3 . This produces the same behavior as using break when reaching c3 in the previous versions of the example. break and continue tend to create complicated and un-maintainable code. Al-though these jumps are somewhat more civilized than “goto,” they still interrupt program flow. Code without jumps is almost always easier to understand. In some cases, you can write the conditions for iteration explicitly instead of using break and continue , as we did in the example above. In other cases, you can restructure your code and introduce new functions. Both break and continue can be replaced with return if you extract the whole loop or the loop body into new functions. In the next section, Functional Programming , you’ll learn to write clear code without using break and continue . Consider alternative approaches, and choose the simpler and more readable solution— which typically won’t include break and continue . Exercises and solutions for this atom can be found at AtomicKotlin.com ⁷³ . ⁷³ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Section IV: Functional Programming The unavoidable price of reliability is simplicity — C.A.R. Hoare ","Lambdas Lambdas produce compact code that’s easier to understand. A lambda (also called a function literal ) is a low-ceremony function: it has no name, requires a minimal amount of code to create, and you can insert it directly into other code. As a starting point, consider map() , which works with collections like List . The parameter for map() is a transformation function which is applied to each element in a collection. map() returns a new List containing all the transformed elements. Here, we transform each List item to a String surrounded with [] : // Lambdas/BasicLambda.kt import atomictest.eq fun main () { val list = listOf( 1 , 2 , 3 , 4 ) val result = list.map({ n: Int -> [$n] }) result eq listOf( [1] , [2] , [3] , [4] ) } The lambda is used in the initialization of result ; it is the code within the curly braces. The parameter list is separated from the function body by an arrow -> (the same arrow used in when expressions). The function body can be one or more expressions. The final expression becomes the return value of the lambda. BasicLambda.kt shows the full lambda syntax, but this can often be simplified. We typically create and use a lambda in place, which means Kotlin can usually infer type information: ","Lambdas 235 // Lambdas/LambdaTypeInference.kt import atomictest.eq fun main () { val list = listOf( 1 , 2 , 3 , 4 ) val result = list.map({ n -> [$n] }) result eq listOf( [1] , [2] , [3] , [4] ) } In BasicLambda.kt we specified the type of n , but in LambdaTypeInference.kt we omit it. Kotlin can tell it’s an Int because the lambda is being used with a List<Int> . If there’s only a single parameter, Kotlin generates the name it for that parameter, which means we no longer need the n -> : // Lambdas/LambdaIt.kt import atomictest.eq fun main () { val list = listOf( 1 , 2 , 3 , 4 ) val result = list.map({ [$it] }) result eq listOf( [1] , [2] , [3] , [4] ) } map() works with a List of any type. Here, Kotlin infers the type of the lambda argument it to be Char : // Lambdas/Mapping.kt import atomictest.eq fun main () { val list = listOf( 'a' , 'b' , 'c' , 'd' ) val result = list.map({ [${it.toUpperCase()}] }) result eq listOf( [A] , [B] , [C] , [D] ) } If the lambda is the only function argument, or the last argument, you can remove the parentheses around the curly braces, producing cleaner syntax: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Lambdas 236 // Lambdas/OmittingParentheses.kt import atomictest.eq fun main () { val list = listOf( 'a' , 'b' , 'c' , 'd' ) val result = list.map { [$it] } result eq listOf( [a] , [b] , [c] , [d] ) } If the function takes many arguments, all except the last lambda argument must be in parentheses. For example, you can specify the last argument for joinToString() as a lambda. The lambda is used to transform each element to a String , then all the elements are joined: // Lambdas/JoinToString.kt import atomictest.eq fun main () { val list = listOf( 9 , 11 , 23 , 32 ) list.joinToString(  ){ [$it] } eq [9] [11] [23] [32] } If you want to provide the lambda as a named argument, you must place the lambda inside the parentheses of the argument list: // Lambdas/LambdaAndNamedArgs.kt import atomictest.eq fun main () { val list = listOf( 9 , 11 , 23 , 32 ) list.joinToString( separator =  , transform = { [$it] } ) eq [9] [11] [23] [32] } Here’s the syntax for a lambda with more than one parameter: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Lambdas 237 // Lambdas/TwoArgLambda.kt import atomictest.eq fun main () { val list = listOf( 'a' , 'b' , 'c' ) list.mapIndexed { index, element -> [$index: $element] } eq listOf( [0: a] , [1: b] , [2: c] ) } This uses the mapIndexed() library function, which takes each element in list and produces the index of that element together with the element. The lambda that we apply after mapIndexed() requires two arguments to match the index and the element (which is a character, in the case of List<Char> ). Here, we display the index and element to demonstrate mapIndexed() . If you aren’t using a particular argument, you can ignore it using an underscore to eliminate compiler warnings about unused identifiers: // Lambdas/Underscore.kt import atomictest.eq fun main () { val list = listOf( 'a' , 'b' , 'c' ) list.mapIndexed { index, _ -> [$index] } eq listOf( [0] , [1] , [2] ) } Note that Underscore.kt can be rewritten using list.indices : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Lambdas 238 // Lambdas/ListIndicesMap.kt import atomictest.eq fun main () { val list = listOf( 'a' , 'b' , 'c' ) list.indices.map { [$it] } eq listOf( [0] , [1] , [2] ) } Lambdas can have zero parameters, in which case you can leave the arrow for emphasis, but the Kotlin style guide recommends omitting the arrow completely: // Lambdas/ZeroArguments.kt import atomictest.eq fun main () { run { -> println( A Lambda )} run { println( Without args )} } /* Output: A Lambda Without args */ The standard library run() simply calls its lambda argument. You can use a lambda anywhere you use a regular function, but if the lambda becomes too complex it’s often better to define a named function, for clarity, even if you’re only going to use it once. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁷⁴ . ⁷⁴ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","The Importance of Lambdas Lambdas may seem like syntactic sugar, but they provide important power to your programming. Code often manipulates the contents of a collection, and typically repeats these manipulations with minor modifications. Consider selecting elements from a collec-tion, such as people under a given age, employees with a specific role, citizens of a particular city, or unfinished orders. Here’s an example that selects even numbers from a list. Suppose we don’t have a rich library of functions for working with collections—we’d have to implement our own filterEven() operation: // ImportanceOfLambdas/FilterEven.kt package importanceoflambdas import atomictest.eq fun filterEven (nums: List<Int>): List<Int> { val result = mutableListOf<Int>() for (i in nums) { if (i % 2 == 0 ){ // [1] result += i } } return result } fun main () { filterEven(listOf( 1 , 2 , 3 , 4 )) eq listOf( 2 , 4 ) } If an element has a remainder of 0 when divided by 2, it’s appended to the result. Imagine you need something similar, but for numbers that are greater than 2. You can copy filterEven() and modify the small part that chooses the elements included in the result: ","The Importance of Lambdas 240 // ImportanceOfLambdas/GreaterThan2.kt package importanceoflambdas import atomictest.eq fun greaterThan2 (nums: List<Int>): List<Int> { val result = mutableListOf<Int>() for (i in nums) { if (i > 2 ){ // [1] result += i } } return result } fun main () { greaterThan2(listOf( 1 , 2 , 3 , 4 )) eq listOf( 3 , 4 ) } The only notable difference between the previous two examples is the line of code ( [1] in both cases) specifying the desired elements. With lambdas, we can use the same function for both cases. The standard library function filter() takes a predicate specifying the elements you want to preserve, and this predicate can be a lambda: // ImportanceOfLambdas/Filter.kt import atomictest.eq fun main () { val list = listOf( 1 , 2 , 3 , 4 ) val even = list.filter { it % 2 == 0 } val greaterThan2 = list.filter { it > 2 } even eq listOf( 2 , 4 ) greaterThan2 eq listOf( 3 , 4 ) } Now we have clear, concise code that avoids repetition. Both even and greaterThan2 use filter() and differ only in the predicate. filter() has been heavily tested, so you’re less likely to introduce a bug. Notice that filter() handles the iteration that would otherwise require handwrit-ten code. Although managing the iteration yourself might not seem like much effort, Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","The Importance of Lambdas 241 it’s one more error-prone detail and one more place to make a mistake. Because they’re so “obvious,” such mistakes are particularly hard to find. This is one of the hallmarks of functional programming , of which map() and filter() are examples. Functional programming solves problems in small steps. The functions often do things that seem trivial—it’s not that hard to write your own code rather than using map() and filter() . However, once you have a collection of these small, debugged solutions, you can easily combine them without debugging at every level. This allows you to create more robust code, more quickly. You can store a lambda in a var or val . This allows reuse of that lambda’s logic, by passing it as an argument to different functions: // ImportanceOfLambdas/StoringLambda.kt import atomictest.eq fun main () { val list = listOf( 1 , 2 , 3 , 4 ) val isEven = { e: Int -> e % 2 == 0 } val even: List<Int> = list.filter(isEven) val hasEven: Boolean = list.any(isEven) even eq listOf( 2 , 4 ) hasEven eq true } The library function any() checks whether there’s at least one element in the List satisfying a given predicate. isEven checks whether a number is even, and this reference is passed as an argument to both filter() and any() . Note that when we define isEven we must specify the parameter type because there is no context for the type inferencer to use. Another important quality of lambdas is the ability to refer to elements outside their scope. When a function “closes over” or “captures” the elements in its environment, we call it a closure . Unfortunately, some languages conflate the term “closure” with the idea of a lambda. The two concepts are completely distinct: you can have lambdas without closures, and closures without lambdas. When a language supports closures, it “just works” the way you expect: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","The Importance of Lambdas 242 // ImportanceOfLambdas/Closures.kt import atomictest.eq fun main () { val list = listOf( 1 , 5 , 7 , 10 ) val divider = 5 list.filter { it % divider == 0 } eq listOf( 5 , 10 ) } Here, the lambda “captures” the val divider that is defined outside the lambda. The lambda not only reads captured elements, it can also modify them: // ImportanceOfLambdas/Closures2.kt import atomictest.eq fun main () { val list = listOf( 1 , 5 , 7 , 10 ) var sum = 0 val divider = 5 list.filter { it % divider == 0 } .forEach { sum += it } sum eq 15 } The forEach() library function applies the specified action to each element of the collection. Although you can capture the mutable variable sum as in Closures2.kt , you can usually change your code and avoid modifying the state of your environment: // ImportanceOfLambdas/Sum.kt import atomictest.eq fun main () { val list = listOf( 1 , 5 , 7 , 10 ) val divider = 5 list.filter { it % divider == 0 } .sum() eq 15 } sum() works on a list of numbers, adding all the elements in the list. An ordinary function can also close over surrounding elements: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","The Importance of Lambdas 243 // ImportanceOfLambdas/FunctionClosure.kt package importanceoflambdas import atomictest.eq var x= 100 fun useX () { x++ } fun main () { useX() x eq 101 } useX() captures and modifies x from its surroundings. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁷⁵ . ⁷⁵ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Operations on Collections An essential aspect of functional languages is the ability to easily perform batch operations on collections of objects. Most functional languages provide powerful support for working with collections, and Kotlin is no exception. You’ve already seen map() , filter() , any() and forEach() . This atom shows additional operations available for List s and other collections. We start by looking at various ways to manufacture List s. Here, we initialize List s using lambdas: // OperationsOnCollections/CreatingLists.kt import atomictest.eq fun main () { // The lambda argument is the element index: val list1 = List( 10 ){it} list1 eq [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] // A list of a single value: val list2 = List( 10 ){ 0 } list2 eq [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] // A list of letters: val list3 = List( 10 ){ 'a' + it } list3 eq [a, b, c, d, e, f, g, h, i, j] // Cycle through a sequence: val list4 = List( 10 ) { list3[it % 3 ]} list4 eq [a, b, c, a, b, c, a, b, c, a] } This version of the List constructor has two parameters: the size of the List and a lambda that initializes each List element (the element index is passed in as the it ","Operations on Collections 245 argument). Remember that if a lambda is the last argument, it can be separated from the argument list. MutableList s can be initialized in the same way. Here we see the initialization lambda both inside the argument list ( mutableList1 ) and separated from the argument list ( mutableList2 ): // OperationsOnCollections/ListInit.kt import atomictest.eq fun main () { val mutableList1 = MutableList( 5 ,{ 10 * (it + 1 ) }) mutableList1 eq [10, 20, 30, 40, 50] val mutableList2 = MutableList( 5 ){ 10 * (it + 1 )} mutableList2 eq [10, 20, 30, 40, 50] } Note that List() and MutableList() are not constructors, but functions. Their names intentionally begin with an upper-case letter to make them look like con-structors. Many collection functions take a predicate and test it against the elements of a collection, some of which we’ve already seen: • filter() produces a list containing all elements matching the given predicate. • any() returns true if at least one element matches the predicate. • all() checks whether all elements match the predicate. • none() checks that no elements match the predicate. • find() and firstOrNull() both return the first element matching the predi-cate, or null if no such element was found. • lastOrNull() returns the last element matching the predicate, or null . • count() returns the number of elements matching the predicate. Here are simple examples of each function: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Operations on Collections 246 // OperationsOnCollections/Predicates.kt import atomictest.eq fun main () { val list = listOf(-3 ,-1 , 5 , 7 , 10 ) list.filter { it > 0 } eq listOf( 5 , 7 , 10 ) list.count { it > 0 } eq 3 list.find { it > 0 } eq 5 list.firstOrNull { it > 0 } eq 5 list.lastOrNull { it < 0 } eq -1 list.any { it > 0 } eq true list.any { it != 0 } eq true list.all { it > 0 } eq false list.all { it != 0 } eq true list.none { it > 0 } eq false list.none { it == 0 } eq true } filter() and count() apply the predicate against each element, while any() or find() stop when the first matching result is found. For example, if the first element satisfies the predicate, any() returns true right away, while find() returns the first matching element. The only time all the elements are processed is if the list contains no elements matching the given predicate. filter() returns a group of elements satisfying the given predicate. Sometimes you’re also interested in the remaining group—the elements that don’t satisfy the predicate. filterNot() produces this remaining group, but partition() is often more useful because it simultaneously produces both lists: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Operations on Collections 247 // OperationsOnCollections/Partition.kt import atomictest.eq fun main () { val list = listOf(-3 ,-1 , 5 , 7 , 10 ) val isPositive = { i: Int -> i > 0 } list.filter(isPositive) eq [5, 7, 10] list.filterNot(isPositive) eq [-3, -1] val ( pos, neg) = list.partition { it > 0 } pos eq [5, 7, 10] neg eq [-3, -1] } partition() produces a Pair object containing List s. Using Destructuring Dec-larations , you can assign the elements of the Pair to a parenthesized group of var s or val s. Destructuring means defining multiple var s or val s and initializing them simultaneously, from the expression on the right side of the assignment. Here’s a review example, showing destructuring used with a custom function: // OperationsOnCollections/PairOfLists.kt package operationsoncollections import atomictest.eq fun createPair () = Pair( 1 , one ) fun main () { val ( i, s) = createPair() i eq 1 s eq one } filterNotNull() produces a new List with the null s removed: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Operations on Collections 248 // OperationsOnCollections/FilterNotNull.kt import atomictest.eq fun main () { val list = listOf( 1 , 2 , null ) list.filterNotNull() eq [1, 2] } In Lists , we saw functions such as sum() , min() or sorted() applied to a list of comparable elements. These functions can’t be called on lists of non-summable or non-comparable elements, but they have counterparts named sumBy() , minBy() and sortedBy() . You pass a function (often a lambda) as an argument, which specifies the attribute to use for the operation: // OperationsOnCollections/ByOperations.kt package operationsoncollections import atomictest.eq data class Product ( val description: String, val price: Double ) fun main () { val products = listOf( Product( bread , 2.0 ), Product( wine , 5.0 ) ) val cheapest = products.minBy { it.price } cheapest eq Product( bread , 2.0 ) val sum = products.sumByDouble { it.price } sum eq 7.0 products.sortedByDescending { it.price } eq [Product(description=wine, price=5.0), +  Product(description=bread, price=2.0)] } Note that we have two functions sumBy() and sumByDouble() to sum integer and double values, respectively. sorted() and sortedBy() sort the collection in Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Operations on Collections 249 ascending order, while sortedDescending() and sortedByDescending() sort the collection in descending order. take() and drop() produce or remove (respectively) the first element, while takeLast() and dropLast() produce or remove the last element. These have counterparts that accept a predicate specifying the elements to take or drop: // OperationsOnCollections/TakeOrDrop.kt import atomictest.eq fun main () { val list = listOf( 'a' , 'b' , 'c' , 'X' , 'Z' ) list.takeLast( 3 ) eq [c, X, Z] list.takeLastWhile { it.isUpperCase() } eq [X, Z] list.drop( 1 ) eq [b, c, X, Z] list.dropWhile { it.isLowerCase() } eq [X, Z] } Operations like those you’ve seen for List s are also available for Set s: // OperationsOnCollections/OperationsOnSets.kt import atomictest.eq fun main () { val set = setOf( a , ab , ac ) set .maxBy { it.length } ?. length eq 2 set .filter { it.contains( 'b' ) } eq listOf( ab ) set .map { it.length } eq listOf( 1 , 2 , 2 ) } maxBy() returns null if a collection is empty, so its result is nullable. Note that filter() and map() , when applied to a Set , return their results in a List . Exercises and solutions for this atom can be found at AtomicKotlin.com ⁷⁶ . ⁷⁶ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Member References You can pass a member reference as a function argument. Member references —function references, property references and constructor references— can replace trivial lambdas that simply call the corresponding function, property or constructor. A member reference uses a double colon to separate the class name from the function or property. Here, Message::isRead is a member reference: // MemberReferences/PropertyReference.kt package memberreferences1 import atomictest.eq data class Message ( val sender: String, val text: String, val isRead: Boolean ) fun main () { val messages = listOf( Message( Kitty , Hey! , true ), Message( Kitty , Where are you? , false )) val unread = messages.filterNot(Message :: isRead) unread.size eq 1 unread.single().text eq Where are you? } To filter for unread messages, we use the library function filterNot() , which takes a predicate. In our case, the predicate indicates whether a message is already read. We could pass a lambda, but instead we pass the property reference Message::isRead , which Kotlin unfolds into the lambda: ","Member References 251 { message: Message -> message.isRead } Property references are useful when specifying a non-trivial sort order: // MemberReferences/SortWith.kt import memberreferences1.Message import atomictest.eq fun main () { val messages = listOf( Message( Kitty , Hey! , true ), Message( Kitty , Where are you? , false ), Message( Boss , Meeting today , false )) messages.sortedWith(compareBy( Message :: isRead, Message :: sender)) eq listOf( // First unread, sorted by sender: Message( Boss , Meeting today , false ), Message( Kitty , Where are you? , false ), // Then read, also sorted by sender: Message( Kitty , Hey! , true )) } The library function sortedWith() sorts a list using a comparator , which is an object used to compare two elements. The library function compareBy() builds a compara-tor based on its parameters, which are a list of predicates. Using compareBy() with a single argument is equivalent to calling sortedBy() . Function References Suppose you want to check whether the list contains any important messages, not just unread messages. You might have a long list of complicated criteria to decide what “important” means. You can put this logic into a lambda, but that lambda could easily become large and complex. The code is more understandable if you extract it into a separate function. In Kotlin you can’t pass a function where a function type is expected, but you can pass a reference to that function: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Member References 252 // MemberReferences/FunctionReference.kt package memberreferences2 import atomictest.eq data class Message ( val sender: String, val text: String, val isRead: Boolean, val attachments: List<Attachment> ) data class Attachment ( val type: String, val name: String ) fun Message .isImportant(): Boolean = text.contains( Salary increase ) || attachments.any { it.type == image && it.name.contains( cat ) } fun main () { val messages = listOf(Message( Boss , Let's discuss goals  + for next year , false , listOf(Attachment( image , cute cats )))) messages.any(Message :: isImportant) eq true } This new Message class adds an attachments property, and the extension function Message.isImportant() uses this information. In the call to messages.any() , we create a reference to an extension function—references are not limited to member functions. Kotlin unfolds the function reference Message::isImportant into the lambda: { message: Message -> message.isImportant() } If you have a top-level function taking Message as its only parameter, you can pass it as a reference. When you create a reference to a top-level function, there’s no class name, so it’s written ::function : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Member References 253 // MemberReferences/TopLevelFunctionRef.kt package memberreferences2 import atomictest.eq fun ignore (message: Message) = !message.isImportant() && message.sender in setOf( Boss , Mom ) fun main () { val text = Let's discuss goals  + for the next year val msgs = listOf( Message( Boss , text, false , listOf()), Message( Boss , text, false , listOf( Attachment( image , cute cats )))) msgs.filter( :: ignore).size eq 1 msgs.filterNot( :: ignore).size eq 1 } Kotlin unfolds the function reference ::ignore into the lambda: { message: Message -> ignore(message) } Constructor References You can also create a reference to a constructor using the class name. Here, names.mapIndexed() takes the constructor reference ::Student : // MemberReferences/ConstructorReference.kt package memberreferences3 import atomictest.eq data class Student ( val id: Int, val name: String ) fun main () { val names = listOf( Alice , Bob ) val students = Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Member References 254 names.mapIndexed { index, name -> Student(index, name) } students eq listOf(Student( 0 , Alice ), Student( 1 , Bob )) names.mapIndexed( :: Student) eq students } Kotlin unfolds the constructor reference ::Student into the lambda: { index, name -> Student(index, name) } mapIndexed() was introduced in Lambdas . It turns each element in names into the index of that element along with the element. In the definition of students , these are explicitly mapped into the constructor, but the identical effect is achieved with names.mapIndexed(::Student) . Thus, function and constructor references can eliminate specifying a long list of parameters that are simply passed into a lambda. Function and constructor references are often more readable than lambdas. Extension Function References To produce a reference to an extension function, prefix the reference with the name of the extended type: // MemberReferences/ExtensionReference.kt package memberreferences import atomictest.eq fun Int .times47() = times( 47 ) class Frog fun Frog .speak() = Ribbit! fun goInt (n: Int, g: (Int) -> Int) = g(n) fun goFrog (frog: Frog, g: (Frog) -> String) = g(frog) fun main () { Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Member References 255 goInt( 12 , Int :: times47) eq 564 goFrog(Frog(), Frog :: speak) eq Ribbit! } In goInt() , g is a function that expects an Int argument and produces an Int . In goFrog() , g expects a Frog and produces a String . Exercises and solutions for this atom can be found at AtomicKotlin.com ⁷⁷ . ⁷⁷ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Higher-Order Functions If functions can accept other functions as arguments and produce func-tions as return values, that language is said to support higher-order functions . Higher-order functions are an essential part of functional programming languages. In previous atoms, we’ve seen higher-order functions such as filter() , map() , and any() . If you declare a function that takes a parameter of a function type, you can pass a function (including a lambda) as an argument. You can also store a lambda. Let’s look at the type of this storage: // HigherOrderFunctions/SimpleOperation.kt import atomictest.eq fun main () { val isPositive: (Int) -> Boolean = { it > 0 } val list = listOf( 1 , 2 ,-3 ) list.any(isPositive) eq true } (Int) -> Boolean is the function type: it starts with parentheses surrounding zero or more parameter types, then an arrow ( -> ), followed by the return type: (Arg1Type, Arg2Type... ArgNType) -> ReturnType The syntax for calling a function through a reference is identical to an ordinary function call. In the following example, helloWorld is a reference to a function that has zero parameters, and sum is a reference to a function that takes two parameters: ","Higher-Order Functions 257 // HigherOrderFunctions/TypeDeclarations.kt import atomictest.eq fun main () { val helloWorld: () -> String = { Hello, world! } helloWorld() eq Hello, world! val sum: (Int, Int) -> Int = {x,y->x+y} sum( 1 , 2 ) eq 3 } When you pass a lambda to a function, that function must accept a parameter of the appropriate function type. Consider how you might define the any() function from the standard library: // HigherOrderFunctions/Any.kt package higherorderfunctions import atomictest.eq fun < T > List<T>.any( // [1] predicate: (T) -> Boolean // [2] ): Boolean { for (element in this ){ if (predicate(element)) // [3] return true } return false } fun main () { val ints = listOf( 1 , 2 ,-3 ) ints.any { it > 0 } eq true // [4] val strings = listOf( abc ,  ) strings.any { it.isBlank() } eq true // [5] strings.any(String :: isNotBlank) eq // [6] true } • [1] Since any() should be available for lists of different types, we define it as an extension to the generic List<T> . Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Higher-Order Functions 258 • [2] predicate must be a function that can be called with a parameter of type T so we can apply it to the elements in the list. • [3] Applying predicate() to element tells us whether that element fits our criteria. The type of the lambda differs from invocation to invocation: it’s Int in [4] and String in [5] . • [6] Member references are another way to pass a function reference. Now recall the repeat() example from Looping & Ranges . You can repeat the action an Int number of times: // HigherOrderFunctions/RepeatByInt.kt fun main () { repeat( 2 ) { println( hi! )} } /* Output: hi! hi! */ repeat() is an ordinary function in the standard library that takes a lambda as its second parameter. You can also pass the lambda inside the parentheses: // HigherOrderFunctions/RepeatVerbose.kt fun main () { repeat( 2 , { println( hi! ) }) } /* Output: hi! hi! */ Let’s explore how repeat() might be defined: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Higher-Order Functions 259 // HigherOrderFunctions/RepeatFun.kt package definingrepeat fun repeat ( times: Int, action: (Int) -> Unit // [1] ){ for (index in 0 until times) { action(index) // [2] } } fun main () { repeat( 3 ) { println( #$it )} // [3] } /* Output: #0 #1 #2 */ • [1] repeat() takes a parameter of the function type action: (Int) -> Unit . • [2] You call action() by passing the current repetition index . • [3] When you call repeat() , you access the repetition index using it inside the lambda. Scope Functions contains examples of other functions from the standard library that look like built-in keywords. A function return type can be nullable: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Higher-Order Functions 260 // HigherOrderFunctions/NullableReturn.kt import atomictest.eq fun main () { val transform: (String) -> Int? = { s: String -> s.toIntOrNull() } transform( 112 ) eq 112 transform( abc ) eq null val list = listOf( 112 , abc ) list.mapNotNull(transform) eq listOf( 112 ) list.mapNotNull { it.toIntOrNull() } eq listOf( 112 ) } toIntOrNull() may return null , so transform() takes a String and returns a nullable Int? . This example also demonstrates mapNotNull() , which converts each element in a list into a nullable value and removes all null s from the result. It has the same effect as first calling map() , then applying filterNotNull() to the resulting list. Note the difference between making the return type nullable versus making the whole function type nullable: // HigherOrderFunctions/NullableFunction.kt import atomictest.eq fun main () { val returnTypeNullable: (String) -> Int? = { null } val mightBeNull: ((String) -> Int)? = null returnTypeNullable( abc ) eq null // Doesn't compile without a null check: // mightBeNull(abc) if (mightBeNull != null ){ mightBeNull( abc ) } } Before calling the function stored in mightBeNull , we must ensure that the reference is not null . Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Higher-Order Functions 261 Exercises and solutions for this atom can be found at AtomicKotlin.com ⁷⁸ . ⁷⁸ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Manipulating Lists Instead of implementing your own operations for manipulating List s, you can use and combine standard library operations. You can combine two List s by “zipping” them, named so because it mimics the behavior of the zipper on your jacket. zip() merges two List s, pairing up their corresponding elements: // ManipulatingLists/Zipper.kt import atomictest.eq fun main () { val left = listOf( a , b , c , d ) val right = listOf( q , r , s , t ) left.zip(right) eq // [1] [(a, q), (b, r), (c, s), (d, t)] left.zip( 0. . 4 ) eq // [2] [(a, 0), (b, 1), (c, 2), (d, 3)] ( 10. . 100 ).zip(right) eq // [3] [(10, q), (11, r), (12, s), (13, t)] } • [1] Zipping left with right results in a List of Pair s, combining each element in left with its corresponding element in right . • [2] You can also zip() a List with a range. • [3] Notice that the range 10..100 is much larger than right , but the zipping process stops when one of the sequences runs out. zip() can also perform a transformation: ","Manipulating Lists 263 // ManipulatingLists/ZipAndTransform.kt package manipulatinglists import atomictest.eq data class Person ( val name: String, val id: Int ) fun main () { val names = listOf( Bob , Jill , Jim ) val ids = listOf( 1731 , 9274 , 8378 ) names.zip(ids) { name, id -> Person(name, id) } eq [Person(name=Bob, id=1731),  + Person(name=Jill, id=9274),  + Person(name=Jim, id=8378)] } names.zip(ids) { ... } produces a sequence of name-id Pair s, and applies a specified transformation to each Pair . The result is a List of initialized Person objects. To zip two adjacent elements from a single List , use zipWithNext() : // ManipulatingLists/ZippingWithNext.kt import atomictest.eq fun main () { val list = listOf( 'a' , 'b' , 'c' , 'd' ) list.zipWithNext() eq listOf( Pair( 'a' , 'b' ), Pair( 'b' , 'c' ), Pair( 'c' , 'd' )) list.zipWithNext { a, b -> $a$b } eq [ab, bc, cd] } The lambda in the second call to zipWithNext() specifies an additional transfor-mation after zipping. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Manipulating Lists 264 Consider flatten() , which takes a List containing elements that are themselves List s—a List of List s—and flattens it into a List of single elements: // ManipulatingLists/Flatten.kt import atomictest.eq fun main () { val list = listOf( listOf( 1 , 2 , 3 ), listOf( 4 , 5 , 6 )) list.flatten() eq listOf( 1 , 2 , 3 , 4 , 5 , 6 ) } flatten() helps us understand another important operation on collections: flatMap() . Let’s produce all possible Pair s of a range of Int s: // ManipulatingLists/FlattenAndFlatMap.kt import atomictest.eq fun main () { val intRange = 1. . 3 intRange.map { a -> // [1] intRange.map { b -> a to b } } eq [ + [(1, 1), (1, 2), (1, 3)],  + [(2, 1), (2, 2), (2, 3)],  + [(3, 1), (3, 2), (3, 3)] + ] intRange.map { a -> // [2] intRange.map { b -> a to b } }.flatten() eq [ + (1, 1), (1, 2), (1, 3),  + (2, 1), (2, 2), (2, 3),  + (3, 1), (3, 2), (3, 3) + ] intRange.flatMap { a -> // [3] intRange.map { b -> a to b } } eq [ + (1, 1), (1, 2), (1, 3),  + Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Manipulating Lists 265 (2, 1), (2, 2), (2, 3),  + (3, 1), (3, 2), (3, 3) + ] } The lambda in each case is identical: every intRange element is combined with every intRange element to produce all possible a to b Pair s. But in [1] , map() helpfully preserves the extra information that we have produced three List s, one for each element in intRange . There are situations where this extra information is essential, but here we don’t want it—we just need a single flat List of all combinations, with no additional structure. There are two options. [2] shows the application of the flatten() function to remove this additional structure and flatten the result into a single List , which is an acceptable approach. However, this is such a common task that Kotlin provides a combined operation called flatMap() , which performs both map() and flatten() with a single call (you’ll find flatMap() in most languages that support functional programming). [3] shows flatMap() in action. Here’s a second example of flatMap() : // ManipulatingLists/WhyFlatMap.kt package manipulatinglists import atomictest.eq class Book ( val title: String, val authors: List<String> ) fun main () { val books = listOf( Book( 1984 , listOf( George Orwell )), Book( Ulysses , listOf( James Joyce )) ) books.map { it.authors }.flatten() eq listOf( George Orwell , James Joyce ) books.flatMap { it.authors } eq listOf( George Orwell , James Joyce ) } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Manipulating Lists 266 We’d like a List of authors. map() produces a List of List of authors, which isn’t very convenient. flatten() takes that and produces a simple List . flatMap() produces the same results in a single step. Mapping works well with enum s. Here, we use map() to combine Suit and Rank to produce a deck of Card s: // ManipulatingLists/PlayingCards.kt package manipulatinglists import kotlin.random.Random import atomictest.* enum class Suit { Spade, Club, Heart, Diamond } enum class Rank ( val faceValue: Int) { Ace( 1 ), Two( 2 ), Three( 3 ), Four( 4 ), Five( 5 ), Six( 6 ), Seven( 7 ), Eight( 8 ), Nine( 9 ), Ten( 10 ), Jack( 10 ), Queen( 10 ), King( 10 ) } class Card ( val rank: Rank, val suit: Suit) { override fun toString () = $rank of ${suit}s } val deck: List<Card> = Suit.values().flatMap { suit -> Rank.values().map { rank -> Card(rank, suit) } } fun main () { val rand = Random( 26 ) repeat( 7 ){ trace( '${deck.random(rand)}' ) } trace eq  ' Jack of Hearts '' Four of Hearts ' ' Five of Clubs '' Seven of Clubs ' Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Manipulating Lists 267 ' Jack of Diamonds '' Ten of Spades ' ' Seven of Spades '  } In deck , the inner Rank.values().map produces four Lists , one for each Suit , so we use flatMap() on the outer loop to produce a List<Card> for deck . Exercises and solutions for this atom can be found at AtomicKotlin.com ⁷⁹ . ⁷⁹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Building Maps Map s are extremely useful programming tools, and there are many ways to construct them. To create a repeatable set of data, we use the technique shown in Manipulating Lists , where two List s are zipped and the result is used in a lambda to call a constructor, producing a List<Person> : // BuildingMaps/People.kt package buildingmaps data class Person ( val name: String, val age: Int ) val names = listOf( Alice , Arthricia , Bob , Bill , Birdperson , Charlie , Crocubot , Franz , Revolio ) val ages = listOf( 21 , 15 , 25 , 25 , 42 , 21 , 42 , 21 , 33 ) fun people (): List<Person> = names.zip(ages) { name, age -> Person(name, age) } A Map uses keys to provide fast access to its values. By building a Map with age as the key, we can quickly look up groups of people by age. The library function groupBy() is one way to create such a Map : ","Building Maps 269 // BuildingMaps/GroupBy.kt import buildingmaps.* import atomictest.eq fun main () { val map: Map<Int, List<Person>> = people().groupBy(Person :: age) map[ 15 ] eq listOf(Person( Arthricia , 15 )) map[ 21 ] eq listOf( Person( Alice , 21 ), Person( Charlie , 21 ), Person( Franz , 21 )) map[ 22 ] eq null map[ 25 ] eq listOf( Person( Bob , 25 ), Person( Bill , 25 )) map[ 33 ] eq listOf(Person( Revolio , 33 )) map[ 42 ] eq listOf( Person( Birdperson , 42 ), Person( Crocubot , 42 )) } groupBy() ’s parameter produces a key. The result is a Map where each key connects to a List of elements. All people of the same age are selected by the age key. You can produce the same groups using the filter() function, but groupBy() is preferable because it only performs the grouping once. With filter() you must repeat the grouping for each new key: // BuildingMaps/GroupByVsFilter.kt import buildingmaps.* import atomictest.eq fun main () { val groups = people().groupBy { it.name.first() } // groupBy() produces map-speed access: groups[ 'A' ] eq listOf(Person( Alice , 21 ), Person( Arthricia , 15 )) groups[ 'Z' ] eq null // Must repeat filter() for each character: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Building Maps 270 people().filter { it.name.first() == 'A' } eq listOf(Person( Alice , 21 ), Person( Arthricia , 15 )) people().filter { it.name.first() == 'F' } eq listOf(Person( Franz , 21 )) people().partition { it.name.first() == 'A' } eq Pair( listOf(Person( Alice , 21 ), Person( Arthricia , 15 )), listOf(Person( Bob , 25 ), Person( Bill , 25 ), Person( Birdperson , 42 ), Person( Charlie , 21 ), Person( Crocubot , 42 ), Person( Franz , 21 ), Person( Revolio , 33 ))) } Here, groupBy() groups people() by their first character, selected by first() . We can also use filter() to produce the same result by repeating the lambda code for each character. If you only need two groups, the partition() function is more direct because it divides the contents into two lists based on a predicate. groupBy() is appropriate when you need more than two resulting groups. associateWith() allows you to take a list of keys and build a Map by associating each of these keys with a value created by its parameter (here, the lambda): Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Building Maps 271 // BuildingMaps/AssociateWith.kt import buildingmaps.* import atomictest.eq fun main () { val map: Map<Person, String> = people().associateWith { it.name } map eq mapOf( Person( Alice , 21 ) to Alice , Person( Arthricia , 15 ) to Arthricia , Person( Bob , 25 ) to Bob , Person( Bill , 25 ) to Bill , Person( Birdperson , 42 ) to Birdperson , Person( Charlie , 21 ) to Charlie , Person( Crocubot , 42 ) to Crocubot , Person( Franz , 21 ) to Franz , Person( Revolio , 33 ) to Revolio ) } associateBy() reverses the order of association produced by associateWith() — the selector (the lambda in the following example) becomes the key: // BuildingMaps/AssociateBy.kt import buildingmaps.* import atomictest.eq fun main () { val map: Map<String, Person> = people().associateBy { it.name } map eq mapOf( Alice to Person( Alice , 21 ), Arthricia to Person( Arthricia , 15 ), Bob to Person( Bob , 25 ), Bill to Person( Bill , 25 ), Birdperson to Person( Birdperson , 42 ), Charlie to Person( Charlie , 21 ), Crocubot to Person( Crocubot , 42 ), Franz to Person( Franz , 21 ), Revolio to Person( Revolio , 33 )) } associateBy() must be used with a unique selection key and returns a Map that pairs each unique key to the single element selected by that key. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Building Maps 272 // BuildingMaps/AssociateByUnique.kt import buildingmaps.* import atomictest.eq fun main () { // associateBy() fails when the key isn't // unique -- values disappear: val ages = people().associateBy { it.age } ages eq mapOf( 21 to Person( Franz , 21 ), 15 to Person( Arthricia , 15 ), 25 to Person( Bill , 25 ), 42 to Person( Crocubot , 42 ), 33 to Person( Revolio , 33 )) } If multiple values are selected by the predicate, as in ages , only the last one appears in the generated Map . getOrElse() tries to look up a value in a Map . Its associated lambda computes a default value when a key is not present. Because it’s a lambda, we compute the default value for the key only when necessary: // BuildingMaps/GetOrPut.kt import atomictest.eq fun main () { val map = mapOf( 1 to one , 2 to two ) map.getOrElse( 0 ){ zero } eq zero val mutableMap = map.toMutableMap() mutableMap.getOrPut( 0 ){ zero } eq zero mutableMap eq {1=one, 2=two, 0=zero} } getOrPut() works on a MutableMap . If a key is present it simply returns the value. If the key isn’t found, it computes the value, puts it into the map and returns that value. Many Map operations duplicate ones in List . For example, you can filter() or map() the contents of a Map . You can filter keys and values separately: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Building Maps 273 // BuildingMaps/FilterMap.kt import atomictest.eq fun main () { val map = mapOf( 1 to one , 2 to two , 3 to three , 4 to four ) map.filterKeys { it % 2 == 1 } eq {1=one, 3=three} map.filterValues { it.contains( 'o' ) } eq {1=one, 2=two, 4=four} map.filter { entry -> entry.key % 2 == 1 && entry.value.contains( 'o' ) } eq {1=one} } All three functions filter() , filterKeys() and filterValues() produce a new map containing only the elements that satisfy the predicate. filterKeys() applies its predicate to the keys, and filterValues() applies its predicate to the values. Applying Operations to Maps To map() a Map sounds like a tautology, like saying “salt is salty.” The word map represents two distinct ideas: • Transforming a collection • The key-value data structure In many programming languages, the word map is used for both concepts. For clarity, we say transform a map when applying map() to a Map . Here we demonstrate map() , mapKeys() and mapValues() : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Building Maps 274 // BuildingMaps/TransformingMap.kt import atomictest.eq fun main () { val even = mapOf( 2 to two , 4 to four ) even.map { // [1] ${it.key}=${it.value} } eq listOf( 2=two , 4=four ) even.map { (key, value) -> // [2] $key=$value } eq listOf( 2=two , 4=four ) even.mapKeys { (num, _) -> -num } // [3] .mapValues { (_, str) -> minus $str } eq mapOf(-2 to minus two , -4 to minus four ) even.map { (key, value) -> -key to minus $value }.toMap() eq mapOf(-2 to minus two , // [4] -4 to minus four ) } • [1] Here, map() takes a predicate with a Map.Entry argument. We access its contents as it.key and it.value . • [2] You can also use a destructuring declaration to place the entry contents into key and value . Destructuring Declarations covers this feature in detail, but for now it’s enough to know that you can say (key, value) -> instead of entry -> . • [3] If a parameter isn’t used, an underscore ( _ ) avoids compiler complaints. mapKeys() and mapValues() return a new map, with all keys or values transformed accordingly. As you can see in [4] , map() returns a list of pairs, so to produce a Map we use the explicit conversion toMap() . Functions like any() and all() can also be applied to Map s: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Building Maps 275 // BuildingMaps/SimilarOperation.kt import atomictest.eq fun main () { val map = mapOf( 1 to one , -2 to minus two ) map.any { (key, _) -> key < 0 } eq true map.all { (key, _) -> key < 0 } eq false map.maxBy { it.key } ?. value eq one } any() checks whether any of the entries in a Map satisfy the given predicate, while all() is true only if all entries in the Map satisfy the predicate. maxBy() finds the maximum entry based on the given criteria. There may not be a maximum entry, so the result is nullable. Creating Immutable Maps Consider the problem of initializing a read-only Map . To demonstrate, we create a Map with keys that are Pair s, to include all possible combinations of color1 to color2 . We want to correlate each key to its value produced by mixing those colors together. We start by creating an enum of Color : // BuildingMaps/PaintColors.kt package buildingmaps enum class Color { Red, Blue, Yellow, Purple, Green, Orange, Brown } Next, blend() takes two colors, mixes them, and produces the resulting color. The final else clause is inaccurate but it keeps the example simple: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Building Maps 276 // BuildingMaps/ColorBlend.kt package buildingmaps import atomictest.eq import buildingmaps.Color.* fun blend (a: Color, b: Color): Color = when { a == b -> a a == Brown || b == Brown -> Brown else -> when (a to b) { Red to Blue, Blue to Red -> Purple Red to Yellow, Yellow to Red -> Orange Blue to Yellow, Yellow to Blue -> Green else -> { // Interesting but not accurate: val values = values() values[ (a.ordinal + b.ordinal) % values.size] } } } fun colorBlendTest ( mix: (a: Color, b: Color) -> Color ){ mix(Red, Red) eq Red mix(Purple, Brown) eq Brown mix(Red, Yellow) eq Orange mix(Yellow, Blue) eq Green mix(Purple, Orange) eq Blue // Not accurate } fun main () { colorBlendTest( :: blend) } This also demonstrates more a complex when expression. We take care of the basics first and the else handles the remaining cases. The tests are placed in colorBlendTest() for later reuse. To produce an immutable Map of all possible color blendings, use buildMap() from the standard library: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Building Maps 277 // BuildingMaps/ImmutableBlendMap.kt @file:OptIn(ExperimentalStdlibApi :: class ) package buildingmaps class BlendMap { val map: Map<Pair<Color, Color>, Color> = buildMap { for (a in Color.values()) { for (b in Color.values()) { this [a to b] = buildingmaps.blend(a, b) } } } fun blend (a: Color, b: Color): Color = map.getOrDefault(a to b, Color.Brown) } fun main () { colorBlendTest(BlendMap() :: blend) } To create a mutable Map , move the initialization code from buildMap into an init clause. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁸⁰ . ⁸⁰ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Sequences A Kotlin Sequence is like a List , but you can only iterate through a Sequence —you cannot index into a Sequence . This restriction produces very efficient chained operations. Operations on List s are performed eagerly —they always happen right away. For a chain of List operations, a result must first be produced before starting the subsequent operation. In this example, every element in list is taken through the entire chain of operations: // Sequences/EagerEvaluation.kt import atomictest.eq fun main () { val list = listOf( 1 , 2 , 3 , 4 ) list.filter { it % 2 == 0 } .map { it * it } .any { it < 10 } eq true // Equivalent to: val mid1 = list.filter { it % 2 == 0 } mid1 eq listOf( 2 , 4 ) val mid2 = mid1.map { it * it } mid2 eq listOf( 4 , 16 ) mid2.any { it < 10 } eq true } Eager evaluation is intuitive and straightforward, but can be suboptimal. In Ea-gerEvaluation.kt , it would make more sense to stop after encountering the first element that satisfies the any() . For a long sequence, this optimization might be much faster than evaluating every element and then searching for a single match. Eager evaluation is sometimes called horizontal evaluation : ","Sequences 279 Horizontal Evaluation The first line contains the initial list contents. Each following line shows the results from the previous operation. Before the next operation is performed, all elements on the current horizontal level are processed. The alternative to eager evaluation is lazy evaluation : a result is computed only when needed. Performing lazy operations on sequences is sometimes called vertical evaluation : Vertical Evaluation With lazy evaluation, an operation is performed on an element only when that element’s associated result is requested. If the final result of a calculation is found before processing the last element, no further elements are processed. Converting List s to Sequence s using asSequence() enables lazy evaluation. All List operations except indexing are also available for Sequence s, so you can usually Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Sequences 280 make this single change and produce the benefits of lazy evaluation. The following example shows the above images turned into code. We perform the identical chain of operations, first on a List , then on a Sequence . We’ve included output to show where each operation is called: // Sequences/EagerVsLazyEvaluation.kt package usingsequences import atomictest.* fun Int .isEven(): Boolean { trace( $this.isEven() ) return this % 2 == 0 } fun Int .square(): Int { trace( $this.square() ) return this * this } fun Int .lessThanTen(): Boolean { trace( ${this}.lessThanTen() ) return this < 10 } fun main () { val list = listOf( 1 , 2 , 3 , 4 ) trace( >>> List: ) trace(list .filter(Int :: isEven) .map(Int :: square) .any(Int :: lessThanTen)) trace( >>> Sequence: ) trace(list.asSequence() .filter(Int :: isEven) .map(Int :: square) .any(Int :: lessThanTen)) trace eq  >>> List: 1. isEven() Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Sequences 281 2. isEven() 3. isEven() 4. isEven() 2. square() 4. square() 4.l essThanTen() true >>> Sequence: 1. isEven() 2. isEven() 2. square() 4.l essThanTen() true  } The only difference between the two approaches is the addition of the asSequence() call, but more elements are processed for the List code than the Sequence code. Calling either filter() or map() on a Sequence produces another Sequence . Nothing happens until you ask for a result from a calculation. Instead, the new Sequence stores all information about postponed operations and will perform these operations only when needed. // Sequences/NoComputationYet.kt import usingsequences.* fun main () { val list = listOf( 1 , 2 , 3 , 4 ) val r = list.asSequence() .filter(Int :: isEven) .map(Int :: square) println(r) } /* Sample output: kotlin.sequences.TransformingSequence@1218025c */ There are two categories of Sequence operations: intermediate and terminal . Inter-mediate operations return another Sequence as a result. filter() and map() are examples of intermediate operations. Terminal operations return a non-Sequence , Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Sequences 282 and therefore execute all stored computations. In the previous examples, any() is a terminal operation because it takes a Sequence and returns a Boolean . In this next example, toList() is terminal because it converts the Sequence to a List , running all stored operations in the process: // Sequences/TerminalOperations.kt import usingsequences.* import atomictest.* fun main () { val list = listOf( 1 , 2 , 3 , 4 ) trace(list.asSequence() .filter(Int :: isEven) .map(Int :: square) .toList()) trace eq  1. isEven() 2. isEven() 2. square() 3. isEven() 4. isEven() 4. square() [4, 16]  } Because a Sequence stores the operations, it can call those operations in any order, resulting in lazy evaluation. In the following example, the standard library function generateSequence() produces an infinite sequence of natural numbers. The first argument is the initial element in the sequence, followed by a lambda defining how the next element is calculated from the previous element: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Sequences 283 // Sequences/NumberSequence1.kt import atomictest.eq fun main () { val naturalNumbers = generateSequence( 1 ){it+ 1 } naturalNumbers.take( 3 ).toList() eq listOf( 1 , 2 , 3 ) naturalNumbers.take( 10 ).sum() eq 55 } Collection s are a known size, indicated by their size property. Sequence s are treated as if they are infinite. Here, we decide how many elements we want using take() , followed a terminal operation ( toList() or sum() ). A terminal operation forces the chain of operations to be performed on the Sequence . The standard library also contains an overloaded version of generateSequence() that doesn’t require the first parameter, only the formula for calculating each element. The lambda must return either the next element or null , when there are no more elements. In the following example we add user input to a Sequence until the user enters XXX as a termination flag: // Sequences/InputLines1.kt fun main () { val lines = generateSequence { val line = readLine() if (line != XXX ) line else null } println(lines.toList()) } /* Input/Output: >>> first >>> second >>> XXX [first, second] */ You can only iterate once through a Sequence . Further attempts produce an exception. To make multiple passes through a Sequence , first convert it to some type of Collection . Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Sequences 284 We can refine the lambda in InputLines1.kt using takeIf() from the standard library: // Sequences/InputLines2.kt fun main () { val lines = generateSequence { readLine() ?. takeIf { it != XXX } } println(lines.toList()) } /* Input/Output: >>> first >>> second >>> XXX [first, second] */ takeIf() returns the receiver (in this case, the input String ) if it satisfies the given predicate, and null if the predicate fails (if the String is XXX ). Using takeIf() , we don’t need to extract the result of readLine() into a separate identifier, as we did with the if expression in InputLines1.kt . Here’s a definition of takeIf() , defined using a generic T so it can work with any type of argument: // Sequences/DefineTakeIf.kt package usingsequences import atomictest.eq fun < T > T.takeIf( predicate: (T) -> Boolean ): T? { return if (predicate( this )) this else null } fun main () { abc .takeIf { it != XXX } eq abc XXX .takeIf { it != XXX } eq null } Used together, generateSequence() and takeIf() can produce a decreasing sequence of numbers: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Sequences 285 // Sequences/NumberSequence2.kt import atomictest.eq fun main () { generateSequence( 6 ){ (it -1 ).takeIf { it > 0 } }.toList() eq listOf( 6 , 5 , 4 , 3 , 2 , 1 ) } An ordinary if expression can always be used instead of takeIf() , but if it needs an extra identifier, that can make the if expression clumsy. The takeIf() version is more functional, especially if it’s used as a part of a chain of calls. If you are familiar with other functional languages, you’ll notice that Kotlin Se-quence s are the same as what are described as streams in those languages. However, Java 8 had already defined a Stream library, so to maintain Java interoperability, a different name was chosen. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁸¹ . ⁸¹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Local Functions Kotlin allows you to define functions anywhere—even inside other func-tions. Named functions defined within other functions are called local functions . Local functions reduce duplication by extracting repetitive code. At the same time, they are only visible within the surrounding function, so they don’t “pollute your namespace.” Here, even though log() is defined just like any other function, it’s nested inside main() : // LocalFunctions/LocalFunctions.kt fun main () { val logMsg = StringBuilder() fun log (message: String) = logMsg.appendln(message) log( Starting computation ) val x= 42 // Imitate computation log( Computation result: $x ) println(logMsg.toString()) } /* Output: Starting computation Computation result: 42 */ Local functions can be closures : they can capture var s or val s from the surrounding environment. These would otherwise have to be passed as additional parameters. log() uses logMsg , which is defined in the outer scope. This way, you don’t repeatedly pass logMsg into log() . You can create local extension functions: ","Local Functions 287 // LocalFunctions/LocalExtensions.kt import atomictest.eq fun main () { fun String .exclaim() = $this! Hello .exclaim() eq Hello! Hallo .exclaim() eq Hallo! Bonjour .exclaim() eq Bonjour! Ciao .exclaim() eq Ciao! } exclaim() is available only inside main() . Here is a demonstration class and example values for use during the remainder of this atom: // LocalFunctions/Session.kt package localfunctions class Session ( val title: String, val speaker: String ) val sessions = listOf(Session( Kotlin Coroutines , Roman Elizarov )) val favoriteSpeakers = setOf( Roman Elizarov ) You can refer to a local function using a function reference: // LocalFunctions/LocalFunctionReference.kt import localfunctions.* import atomictest.eq fun main () { fun interesting (session: Session): Boolean { if (session.title.contains( Kotlin ) && session.speaker in favoriteSpeakers) { return true } // ... more checks Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Local Functions 288 return false } sessions.any( :: interesting) eq true } interesting() is only used once, so we might be inclined to define it as a lambda. As you will see later in this atom, the return expressions within interesting() complicate the task of turning it into a lambda. We can avoid this complication using an anonymous function . Like local functions, anonymous functions are defined within other functions—however, an anonymous function has no name. Anonymous functions are conceptually similar to lambdas, but anonymous functions use the fun keyword and require an explicit return type. Here’s LocalFunctionReference.kt rewritten using an anonymous function: // LocalFunctions/InterestingSessions.kt import localfunctions.* import atomictest.eq fun main () { sessions.any( fun (session: Session): Boolean { // [1] if (session.title.contains( Kotlin ) && session.speaker in favoriteSpeakers) { return true } // ... more checks return false }) eq true } • [1] An anonymous function looks like a regular function without a function name. Here, the anonymous function is passed as an argument to ses-sions.any() . If a lambda becomes too complicated and hard to read, replace it with a local function or an anonymous function. Labels In this example, forEach() acts upon a lambda containing a return : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Local Functions 289 // LocalFunctions/ReturnFromFun.kt fun main () { val list = listOf( 1 , 2 , 3 , 4 , 5 ) val value = 3 list.forEach { if (it == value) return // [1] } println( This line is NOT called ) // [2] } /* Output: */ A return expression exits a function defined using fun (that is, not a lambda). In line [1] this means returning from main() . Line [2] is never called and you see no output. To return only from a lambda, and not from the surrounding function, use a labeled return : // LocalFunctions/LabeledReturn.kt fun main () { val list = listOf( 1 , 2 , 3 , 4 , 5 ) val value = 3 list.forEach { if (it == value) return @forEach } println( This line is called ) } /* Output: This line is called */ Here, the label is the name of the function that called the lambda. The labeled return expression return@forEach tells it to return only until it encounters the name forEach . You can create your own label by preceeding the lambda with label@ , where label can be any name: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Local Functions 290 // LocalFunctions/CustomLabel.kt fun main () { val list = listOf( 1 , 2 , 3 , 4 , 5 ) val value = 3 list.forEach tag @ { // [1] if (it == value) return @tag // [2] } println( This line is called ) } /* Output: This line is called */ • [1] This lambda is labeled tag . • [2] return@tag returns from the lambda, not from main() . Let’s replace the anonymous function in InterestingSessions.kt with a lambda: // LocalFunctions/ReturnInsideLambda.kt import localfunctions.* import atomictest.eq fun main () { sessions.any { session -> if (session.title.contains( Kotlin ) && session.speaker in favoriteSpeakers) { return @any true } // ... more checks false } eq true } We must return to a label so it exits only the lambda and not main() . Manipulating Local Functions You can store a lambda or an anonymous function in a var or val , then use that identifier to call the function. To store a local function, use a function reference (see Member References ). Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Local Functions 291 In the following example, first() creates an anonymous function, second() uses a lambda, and third() returns a reference to a local function: // LocalFunctions/ReturningFunc.kt package localfunctions import atomictest.eq fun first (): (Int) -> Int { val func = fun ( i : Int): Int { return i+ 1 } func( 1 ) eq 2 return func } fun second (): (String) -> String { val func2 = { s: String -> $s! } func2( abc ) eq abc! return func2 } fun third (): () -> String { fun greet () = Hi! return :: greet } fun main () { val firstFun: (Int) -> Int = first() val secondFun: (String) -> String = second() val thirdFun: () -> String = third() firstFun( 42 ) eq 43 secondFun( xyz ) eq xyz! thirdFun() eq Hi! } main() shows how the functions returned by first() , second() and third() are captured and called. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁸² . ⁸² https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Folding Lists fold() combines all elements of a list, in order, to generate a single result. A common exercise is to implement operations such as sum() or reverse() using fold() . Here, fold() sums a sequence: // FoldingLists/SumViaFold.kt import atomictest.eq fun main () { val list = listOf( 1 , 10 , 100 , 1000 ) list.fold( 0 ) { sum, n -> sum + n } eq 1111 } fold() takes the initial value (its argument, 0 in this case) and successively applies the operation (expressed here as a lambda) to combine the current accumulated value with each element. fold() first adds 0 (the initial value) and 1 to get 1 . That becomes the sum , which is then added to the 10 to get 11 , which becomes the new sum . The operation is repeated for two more elements: 100 and 1000 . This produces 111 and 1111 . The fold() will stop when there is nothing else in the list, returning the final sum of 1111 . Of course, fold() doesn’t really know it’s doing a “sum”—the choice of identifier name was ours, to make it easier to understand. To illuminate the steps in a fold() , here’s SumViaFold.kt using an ordinary for loop: ","Folding Lists 293 // FoldingLists/FoldVsForLoop.kt import atomictest.eq fun main () { val list = listOf( 1 , 10 , 100 , 1000 ) val initial = 0 val operation = { sum: Int, i: Int -> sum + i } val s = list.fold(initial) { sum, i -> operation(sum, i) } s eq 1111 var accumulator = initial for (i in list) { accumulator = operation(accumulator, i) } accumulator eq 1111 } We extract initial and operation to illustrate the for -loop syntax, which is analogous to the prior fold() usage. fold() accumulates values starting with the initial value and successively applies operation , combining the current element with the accumulator value. Although fold() is an important concept and the only way to accumulate values in pure functional languages, you may sometimes still use an ordinary for loop in Kotlin. fold() has a relative, foldRight() , which processes the elements starting from right to left, as opposed to fold() which processes the elements from left to right. This example demonstrates the difference: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Folding Lists 294 // FoldingLists/FoldRight.kt import atomictest.eq fun main () { val list = listOf( 'a' , 'b' , 'c' , 'd' ) list.fold( * ) { acc, elem -> ($acc) + $elem } eq ((((*) + a) + b) + c) + d list.foldRight( * ) { elem, acc -> $elem + ($acc) } eq a + (b + (c + (d + (*)))) } fold() first applies the operation to a , as we can see in (*) + a , while foldRight() first processes the last element d , and processes a at the end. fold() and foldRight() take an explicit accumulator value as the first argument. In many cases the first element can act as an initial value. reduce() and reduc-eRight() behave like fold() and foldRight() but use the first and last element, respectively, as the initial value: // FoldingLists/FoldAndReduce.kt import atomictest.eq fun main () { val list = listOf( 1 , 2 , 3 , 4 ) list.fold( 1 ) { acc, elem -> acc * elem } eq 1 * 1 * 2 * 3 * 4 list.reduce { acc, elem -> acc * elem } eq 1 * 2 * 3 * 4 } The product of all the numbers in the list is the same for fold() and reduce() , but the number of operations differs fold() starts by multiplying the initial value 1 by the first element (which also happens to be 1 ), while reduce() doesn’t require an initial value. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁸³ . ⁸³ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Recursion Recursion is the programming technique of calling a function within that same function. Tail recursion is an optimization that can be explicitly applied to some recursive functions. A recursive function uses the result of the previous recursive call. Factorials are a common example— factorial(n) multiplies all numbers from 1 to n , and can be defined like this: • factorial(1) is 1 • factorial(n) is n * factorial(n - 1) factorial() is recursive because it uses the result from the same function applied to its modified argument. Here’s a recursive implementation of factorial() : // Recursion/Factorial.kt package recursion import atomictest.eq fun factorial (n: Long): Long { if (n <= 1 ) return 1 return n * factorial(n -1 ) } fun main () { factorial( 5 ) eq 120 factorial( 17 ) eq 355687428096000 } While this is easy to read, it’s expensive. When calling a function, the information about that function and its arguments are stored in a call stack . You see the call stack when an exception is thrown and Kotlin displays the stack trace: ","Recursion 296 // Recursion/CallStack.kt package recursion fun illegalState () { // throw IllegalStateException() } fun fail () = illegalState() fun main () { fail() } If you uncomment the line containing the exception, you’ll see the following: Exception in thread main java.lang.IllegalStateException at recursion.CallStackKt.illegalState(CallStack.kt:5) at recursion.CallStackKt.fail(CallStack.kt:8) at recursion.CallStackKt.main(CallStack.kt:11) The stack trace displays the state of the call stack at the moment the exception is thrown. For CallStack.kt , the call stack consists of only three functions: The Call Stack We start in main() , which calls fail() . The fail() call is added to the call stack along with its arguments. Next, fail() calls illegalState() , which is also added to the call stack. When you call a recursive function, each recursive invocation adds a frame to the call stack. This can easily produce a StackOverflowError , which means that your call stack became too large and exhausted the available memory. Programmers commonly cause StackOverflowError s by forgetting to terminate the chain of recursive calls—this is infinite recursion .: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Recursion 297 // Recursion/InfiniteRecursion.kt package recursion fun recurse (i: Int): Int = recurse(i + 1 ) fun main () { // println(recurse(1)) } If you uncomment the line in main() , you’ll see a stacktrace with many duplicate calls: Exception in thread main java.lang.StackOverflowError at recursion.InfiniteRecursionKt.recurse(InfiniteRecursion.kt:4) at recursion.InfiniteRecursionKt.recurse(InfiniteRecursion.kt:4) ... at recursion.InfiniteRecursionKt.recurse(InfiniteRecursion.kt:4) The recursive function keeps calling itself (with a different argument each time), and fills up the call stack: Infinite Recursion Infinite recursion always ends with a StackOverflowError , but you can produce the same result without infinite recursion, simply by making enough recursive function calls. For example, let’s sum the integers up to a given number, recursively defining sum(n) as n + sum(n - 1) : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Recursion 298 // Recursion/RecursionLimits.kt package recursion import atomictest.eq fun sum (n: Long): Long { if (n == 0L ) return 0 return n + sum(n -1 ) } fun main () { sum( 2 ) eq 3 sum( 1000 ) eq 500500 // sum(100_000) eq 500050000 // [1] ( 1. . 100 _000L).sum() eq 5000050000 // [2] } This recursion quickly becomes expensive. If you uncomment line [1] , you’ll discover that it takes far too long to complete, and overflows the stack while making all those recursive calls. If sum(100_000) still works on your machine, try a bigger number. When you call sum(100_000) , you add 100_000 sum() function calls to the call stack, causing a StackOverflowError . For comparison, line [2] uses the sum() library function to add the numbers within the range, and this does not fail. To avoid a StackOverflowError , you can use an iterative solution that loops rather than making recursive calls: // Recursion/Iteration.kt package iteration import atomictest.eq fun sum (n: Long): Long { var accumulator = 0L for (i in 1. .n) { accumulator += i } return accumulator } fun main () { sum( 10000 ) eq 50005000 sum( 100000 ) eq 5000050000 } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Recursion 299 There’s no risk of a StackOverflowError because we only make a single sum() call, which calculates the result in a for loop. Although the iterative solution is straightforward, it must use the mutable state variable accumulator to store the changing value. Functional programming attempts to avoid mutation. Traditional functional lan-guages avoid overflowing the call stack by using a technique called tail recursion . Kotlin also supports tail recursion. The goal of tail recursion is to reduce the size of the call stack. In the sum() example, the call stack becomes a single function call, just as it did in Iteration.kt : Regular Recursion vs. Tail Recursion To produce tail recursion, use the tailrec keyword. Under the right conditions, this converts recursive calls into iteration, eliminating call-stack overhead. This is a compiler optimization, but it won’t work for just any recursive call. To use tailrec successfully, recursion must be the final operation. Thus, there can be no extra calculations on the result of the recursive call before it is returned. For ex-ample, if we simply put tailrec before the fun for sum() in RecursionLimits.kt , Kotlin produces the following warning messages: • A function is marked as tail-recursive but no tail calls are found • Recursive call is not a tail call The problem is that n is combined with the result of the recursive sum() call before returning that result. For tailrec to be successful, the result of the recursive call must be returned without doing anything to it during the return. This often requires Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Recursion 300 some work in rearranging the function. For sum() , a successful tailrec looks like this: // Recursion/TailRecursiveSum.kt package tailrecursion import atomictest.eq private tailrec fun sum ( n: Long, accumulator: Long ): Long = if (n == 0L ) accumulator else sum(n -1 , accumulator + n) fun sum (n: Long) = sum(n, 0 ) fun main () { sum( 2 ) eq 3 sum( 10000 ) eq 50005000 sum( 100000 ) eq 5000050000 } By including the accumulator parameter, the addition happens during the recursive call and you don’t do anything to the result except return it. The tailrec keyword is now successful, because the code was rewritten to delegate all activities to the recursive call. In addition, accumulator becomes an immutable value, eliminating the complaint we had for Iteration.kt . factorial() is a common example for demonstrating tail recursion, and is one of the exercises for this atom. Another example is the Fibonacci sequence, where each new Fibonacci number is the sum of the previous two. The first two numbers are 0 and 1 , which produces the following sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21 ... This can be expressed recursively: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Recursion 301 // Recursion/VerySlowFibonacci.kt package slowfibonacci import atomictest.eq fun fibonacci (n: Long): Long { return when (n) { 0L -> 0 1L -> 1 else -> fibonacci(n -1 ) + fibonacci(n -2 ) } } fun main () { fibonacci( 0 ) eq 0 fibonacci( 22 ) eq 17711 // Very time-consuming: // fibonacci(50) eq 12586269025 } This implementation is terribly inefficient because the previously-calculated results are not reused. Thus, the number of operations grows exponentially: Inefficient Computation of Fibonacci Numbers When computing the 50th Fibonacci number, we first compute the 49th and 48th numbers independently, which means we compute the 48th number twice. The 46th number is computed as many as 4 times, and so on. Using tail recursion, the calculations become dramatically more efficient: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Recursion 302 // Recursion/Fibonacci.kt package recursion import atomictest.eq fun fibonacci (n: Int): Long { tailrec fun fibonacci ( n: Int, current: Long, next: Long ): Long { if (n == 0 ) return current return fibonacci( n-1 , next, current + next) } return fibonacci(n, 0L , 1L ) } fun main () { ( 0. . 8 ).map { fibonacci(it) } eq [0, 1, 1, 2, 3, 5, 8, 13, 21] fibonacci( 22 ) eq 17711 fibonacci( 50 ) eq 12586269025 } Note the local fibonacci() function. We can avoid the local function using default arguments for the initial call. However, default arguments imply that the user can put other values in those defaults, which produce incorrect results. Because the auxiliary fibonacci() function is a local function, we don’t expose the additional parameters, and you can only call fibonacci(n) . main() shows the first eight elements of the Fibonacci sequence, the value for 22, and finally the 50th Fibonacci number that is now produced very quickly. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁸⁴ . ⁸⁴ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Section V: Object-Oriented Programming … inheritance is a very flexible mechanism. It’s possible and in fact fairly common to misuse it, but that’s not a reason to distrust it systematically as seems to have become the fashion. — Bertrand Meyer ","Interfaces An interface describes the concept of a type. It says, “All classes that implement this interface look like this.” It describes what a class should do, but not how it should do it. An interface provides a form, but generally no implementation. It specifies an object’s actions without detailing how those actions are performed. The interface describes the mission or goal of an entity, versus a class that contains implementation details. One dictionary definition says that an interface is “The place at which independent and often unrelated systems meet and act on or communicate with each other.” Thus, an interface is a means of communication between different parts of a system. An Application Programming Interface (API) is a set of clearly defined communica-tion paths between various software components. In object-oriented programming, the API of an object is the set of public members it uses to interact with other objects. Code that uses a particular interface only knows what functions might be called for that interface. The interface establishes a “protocol” between classes. (Some object-oriented languages have a keyword called protocol to do the same thing.) To create an interface, use the interface keyword instead of the class keyword. When defining a class that implements an interface, follow the class name with a : (colon) and the name of the interface: ","Interfaces 305 // Interfaces/Computer.kt package interfaces import atomictest.* interface Computer { fun prompt (): String fun calculateAnswer (): Int } class Desktop : Computer { override fun prompt () = Hello! override fun calculateAnswer () = 11 } class DeepThought : Computer { override fun prompt () = Thinking... override fun calculateAnswer () = 42 } class Quantum : Computer { override fun prompt () = Probably... override fun calculateAnswer () = -1 } fun main () { val computers = listOf( Desktop(), DeepThought(), Quantum() ) computers.map { it.calculateAnswer() } eq [11, 42, -1] computers.map { it.prompt() } eq [Hello!, Thinking..., Probably...] } Computer declares prompt() and calculateAnswer() but provides no implemen-tations. A class that implements the interface must provide bodies for all the declared functions, making those functions concrete . In main() you see that different imple-mentations of an interface express different behaviors via their function definitions. When implementing a member of an interface, you must use the override modifier. override tells Kotlin you are intentionally using the same name that appears in the interface (or base class)—that is, you aren’t accidentally overriding. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Interfaces 306 An interface can declare properties. These must be overridden in all classes imple-menting that interface: // Interfaces/PlayerInterface.kt package propertiesininterfaces import atomictest.eq interface Player { val symbol: Char } class Food : Player { override val symbol = '.' } class Robot : Player { override val symbol get () = 'R' } class Wall ( override val symbol: Char) : Player fun main () { listOf(Food(), Robot(), Wall( '|' )).map { it.symbol } eq [., R, |] } Each subclass overrides the symbol property in a different way: • Food directly replaces the symbol value. • Robot has a custom getter that returns the value (see Property Accessors ). • Wall overrides symbol inside the constructor argument list (see Constructors ) An enumeration can implement an interface : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Interfaces 307 // Interfaces/Hotness.kt package interfaces import atomictest.* interface Hotness { fun feedback (): String } enum class SpiceLevel : Hotness { Mild { override fun feedback () = It adds flavor! }, Medium { override fun feedback () = Is it warm in here? }, Hot { override fun feedback () = I'm suddenly sweating a lot. }, Flaming { override fun feedback () = I'm in pain. I am suffering. } } fun main () { SpiceLevel.values().map { it.feedback() } eq [It adds flavor!,  + Is it warm in here?,  + I'm suddenly sweating a lot.,  + I'm in pain. I am suffering.] } The compiler ensures that each enum element provides a definition for feedback() . SAM Conversions The Single Abstract Method (SAM) interface comes from Java, where they call member functions “methods.” Kotlin has a special syntax for defining SAM interfaces: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Interfaces 308 fun interface . Here we show SAM interfaces with different parameter lists: // Interfaces/SAM.kt package interfaces fun interface ZeroArg { fun f (): Int } fun interface OneArg { fun g (n: Int): Int } fun interface TwoArg { fun h (i: Int, j: Int): Int } When you say fun interface , the compiler ensures there is only a single member function. You can implement a SAM interface in the ordinary verbose way, or by passing it a lambda; the latter is called a SAM conversion . In a SAM conversion, the lambda becomes the implementation for the single method in the interface. Here we show both ways to implement the three interfaces: // Interfaces/SAMImplementation.kt package interfaces import atomictest.eq class VerboseZero : ZeroArg { override fun f () = 11 } val verboseZero = VerboseZero() val samZero = ZeroArg { 11 } class VerboseOne : OneArg { override fun g (n: Int) = n + 47 } val verboseOne = VerboseOne() Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Interfaces 309 val samOne = OneArg { it + 47 } class VerboseTwo : TwoArg { override fun h (i: Int, j: Int) = i + j } val verboseTwo = VerboseTwo() val samTwo = TwoArg { i, j -> i + j } fun main () { verboseZero.f() eq 11 samZero.f() eq 11 verboseOne.g( 92 ) eq 139 samOne.g( 92 ) eq 139 verboseTwo.h( 11 , 47 ) eq 58 samTwo.h( 11 , 47 ) eq 58 } Comparing the “verbose” implementations to the “sam” implementations you can see that SAM conversions produce much more succinct syntax for a commonly-used idiom, and you aren’t forced to define a class to create a single object. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁸⁵ . ⁸⁵ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Complex Constructors You must properly initialize your objects so your code will work correctly. A constructor is a special function that creates a new object. In Constructors , we saw simple constructors that only initialize their arguments. Using var or val in the parameter list makes those parameters properties, accessible from outside the object: // ComplexConstructors/SimpleConstructor.kt package complexconstructors import atomictest.eq class Alien ( val name: String) fun main () { val alien = Alien( Pencilvester ) alien.name eq Pencilvester } In these cases, we don’t write constructor code—Kotlin does it for us. For more customization, add constructor code in the class body. Code inside the init section is executed during object creation: // ComplexConstructors/InitSection.kt package complexconstructors import atomictest.eq private var counter = 0 class Message (text: String) { private val content: String init { counter += 10 content = [$counter] $text } override fun toString () = content ","Complex Constructors 311 } fun main () { val m1 = Message( Big ba-da boom! ) m1 eq [10] Big ba-da boom! val m2 = Message( Bzzzzt! ) m2 eq [20] Bzzzzt! } Constructor parameters are accessible inside the init section even if they aren’t marked as properties using var or val . Although defined as val , content is not initialized at the point of definition. In this case, Kotlin ensures that initialization occurs at one (and only one) point during construction. Either reassigning content or forgetting to initialize it produces an error message. The constructor is the combination of the constructor parameter list—initialized before entering the class body—and the init section(s), executed during object creation. Kotlin allows multiple init sections, which are executed in definition order. How-ever, in a large and complex class, spreading out the init sections may produce maintenance issues for programmers who are accustomed to a single init section. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁸⁶ . ⁸⁶ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Secondary Constructors When you require several ways to construct an object, named and default arguments are usually the easiest approach. Sometimes, however, you must create multiple overloaded constructors. The constructor is “overloaded” because you’re making different ways to create objects of the same class. In Kotlin, overloaded constructors are called secondary constructors . The constructor parameter list (directly after the class name) combined with property initializations and the init block is called the primary constructor . To create a secondary constructor, use the constructor keyword followed by a parameter list that’s distinct from all other primary and secondary parameter lists. Within a secondary constructor, the this keyword calls either the primary constructor or another secondary constructor: // SecondaryConstructors/WithSecondary.kt package secondaryconstructors class WithSecondary (i: Int) { init { println( Primary: $i ) } constructor (c: Char) : this (c -'A' ){ println( Secondary: '$c' ) } constructor (s: String) : this (s.first()) { // [1] println( Secondary: $s ) } /* Doesn't compile without a call to the primary constructor: constructor(f: Float) { // [2] println(Secondary: $f) ","Secondary Constructors 313 } */ } fun main () { fun sep () = println( - .repeat( 10 )) WithSecondary( 1 ) sep() WithSecondary( 'D' ) sep() WithSecondary( Last Constructor ) } /* Output: Primary: 1 ----------Primary: 3 Secondary: 'D' ----------Primary: 11 Secondary: 'L' Secondary: Last Constructor */ Calling another constructor from a secondary constructor (using this ) must happen before additional constructor logic, because the constructor body may depend on those other initializations. Thus it syntactically precedes the constructor body. The argument list determines which constructor is called. WithSecondary(1) matches the primary constructor, WithSecondary('D') matches the first secondary constructor, and WithSecondary(Last Constructor) matches the second sec-ondary constructor. The this() call in [1] matches the first secondary constructor, and you can see the chain of calls in the output. The primary constructor must always be called, either directly or through a call to a secondary constructor. Otherwise, Kotlin generates a compile-time error, as in [2] . Thus, all common initialization logic that can be shared between constructors should be placed in the primary constructor. An init section is not required when using secondary constructors, as shown here: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Secondary Constructors 314 // SecondaryConstructors/GardenItem.kt package secondaryconstructors import atomictest.eq import secondaryconstructors.Material.* enum class Material { Ceramic, Metal, Plastic } class GardenItem ( val name: String) { var material: Material = Plastic constructor ( name: String, material: Material // [1] ): this (name) { // [2] this .material = material // [3] } constructor ( material: Material ): this ( Strange Thing , material) // [4] override fun toString () = $material $name } fun main () { GardenItem( Elf ).material eq Plastic GardenItem( Snowman ).name eq Snowman GardenItem( Gazing Ball , Metal) eq // [5] Metal Gazing Ball GardenItem(material = Ceramic) eq Ceramic Strange Thing } • [1] Only the parameters of the primary constructor can be declared as proper-ties via val or var . • [2] You cannot declare a return type for a secondary constructor. • [3] The material parameter has the same name as a property, so we disam-biguate it using this . • [4] The secondary constructor body is optional (although you must still include an explicit this() call). When calling the first secondary constructor in line [5] , the property material is assigned twice. First, the Plastic value is assigned during the call to the primary Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Secondary Constructors 315 constructor (in [2] ) and initialization of all the class properties, then it’s changed to the material parameter at [3] . The GardenItem class can be simplified using default arguments, replacing the secondary constructors with a single primary constructor. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁸⁷ . ⁸⁷ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inheritance Inheritance is a mechanism for reusing and modifying the behavior of an existing class inside a new class. Objects store data in properties and perform actions via member functions. Each object occupies a unique place in storage so one object’s properties can have different values from every other object. An object also belongs to a category called a class, which determines the form for its objects: its properties and functions. Thus, an object looks like the class that formed it. Creating and debugging a class can require extensive work. What if you want to make a class that’s similar to an existing class, but with some variations? It seems wasteful to build a new class from scratch. Object-oriented languages provide a mechanism for reuse called inheritance . Inheritance follows the concept of biological inheritance. You say, “I want to make a new class from an existing class, but with some additions and modifications.” The syntax for inheritance is similar to implementing an interface. To inherit a new class Derived from an existing class Base , use a : (colon): // Inheritance/BasicInheritance.kt package inheritance open class Base class Derived : Base() The terms base class and derived class (or parent class and child class , or superclass and subclass ) are often used to describe the inheritance relationship. The subsequent atom will explain the reason for the parentheses after Base during inheritance. The base class must be open . Without specifying open , a class doesn’t allow inheritance—it is closed by default. This differs from most other object-oriented ","Inheritance 317 languages. In Java, for example, a class is automatically inheritable unless you explicitly forbid inheritance by declaring that class to be final . Although Kotlin allows it, the final modifier is redundant because every class is effectively final by default: // Inheritance/OpenAndFinalClasses.kt package inheritance // This class can be inherited: open class Parent class Child : Parent() // Child is not open, so this fails: // class GrandChild : Child() // This class can't be inherited: final class Single // The same as using 'final': class AnotherSingle Kotlin forces you to specify that a class is designed for inheritance, to clarify and enforce the author’s intent. In the following example, GreatApe is a base class, and has two properties with fixed values. The derived classes Bonobo , Chimpanzee and BonoboB are new types that are identical to their parent class: // Inheritance/GreatApe.kt package inheritance.ape1 import atomictest.eq open class GreatApe { val weight = 100.0 val age = 12 } open class Bonobo : GreatApe() class Chimpanzee : GreatApe() class BonoboB : Bonobo() Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inheritance 318 fun info (ape: GreatApe) = weight: ${ape.weight} age: ${ape.age} fun main () { info(GreatApe()) eq weight: 100.0 age: 12 info(Bonobo()) eq weight: 100.0 age: 12 info(Chimpanzee()) eq weight: 100.0 age: 12 info(BonoboB()) eq weight: 100.0 age: 12 } info() takes a GreatApe parameter, so naturally you can call it with a GreatApe . But notice that you can also call info() with a Bonobo ,a Chimpanzee , or a BonoboB ! Even though the latter three are distinct types, Kotlin happily accepts them as if they were the same type as GreatApe . This works at any level of inheritance— BonoboB is two inheritance levels away from GreatApe . Inheritance guarantees that anything inheriting from GreatApe is a GreatApe . All code that acts upon objects of the derived classes knows that GreatApe is at their core, so any functions and properties in GreatApe will also be available in its child classes. Inheritance enables you to write a single piece of code (the info() function) that works not just with one class, but also with every class that inherits that class. Thus, inheritance creates opportunities for code simplification and reuse. GreatApe.kt is a bit too simple because all the classes are identical. Inheritance gets interesting when you start overriding functions, which means redefining a function from a base class to do something different in a derived class. Let’s look at another version of GreatApe.kt . This time we include member functions that are modified in the subclasses: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inheritance 319 // Inheritance/GreatApe2.kt package inheritance.ape2 import atomictest.eq open class GreatApe { protected var energy = 0 open fun call () = Hoo! open fun eat () { energy += 10 } fun climb (x: Int) { energy -= x } fun energyLevel () = Energy: $energy } class Bonobo : GreatApe() { override fun call () = Eep! override fun eat () { // Modify the base-class var: energy += 10 // Call the base-class version: super .eat() } // Add a function: fun run () = Bonobo run } class Chimpanzee : GreatApe() { // New property val additionalEnergy = 20 override fun call () = Yawp! override fun eat () { energy += additionalEnergy super .eat() } // Add a function: fun jump () = Chimp jump } fun talk (ape: GreatApe): String { // ape.run() // Not an ape function Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inheritance 320 // ape.jump() // Nor this ape.eat() ape.climb( 10 ) return ${ape.call()} ${ape.energyLevel()} } fun main () { // Cannot access 'energy': // GreatApe().energy talk(GreatApe()) eq Hoo! Energy: 0 talk(Bonobo()) eq Eep! Energy: 10 talk(Chimpanzee()) eq Yawp! Energy: 20 } Every GreatApe has a call() . They store energy when they eat() and they expend energy when they climb() . As described in Constraining Visibility , the derived class can’t access the private members of the base class. Sometimes the creator of the base class would like to take a particular member and grant access to derived classes but not to the world in general. That’s what protected does: protected members are closed to the outside world, but can be accessed or overridden in subclasses. If we declare energy as private , it won’t be possible to change it whenever GreatApe is used, which is good, but we also can’t access it in subclasses. Making it protected allows us to keep it accessible to subclasses but invisible to the outside world. Notice that call() is defined the same way in Bonobo and Chimpanzee as it is in GreatApe : It has no parameters and type inference determines that it returns a String . Both Bonobo and Chimpanzee should have different behaviors for call() than GreatApe , so we want to change their definitions of call() . If you create an identical function signature in a derived class as in a base class, you substitute the behavior defined in the base class with your new behavior. This is called overriding . When Kotlin sees an identical function signature in the derived class as in the base class, it decides that you’ve made a mistake, called an accidental override . If you write a function that has the same name as a function in the base class, you get an error message saying you forgot the override keyword (try it!). Kotlin assumes you’ve Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inheritance 321 unintentionally chosen the same name, parameters and return type unless you use the override keyword (which you first saw in Constructors ) to say “yes, I mean to do this.” The override keyword also helps when reading the code, so you don’t have to compare signatures to notice the overrides. Kotlin imposes an additional constraint when overriding functions. Just as you cannot inherit from a base class unless that base class is open , you cannot override a function from a base class unless that function is defined as open in the base class. Inheritance and overriding cannot be accomplished in Kotlin without clear intentions. It’s especially interesting to take a Bonobo or a Chimpanzee and treat it as an ordinary GreatApe . Inside talk() , call() produces the correct behavior in each case. talk() somehow knows the exact type of the object and produces the appropriate variation of call() . This is Polymorphism . Inside talk() , you can only call GreatApe member functions because talk() ’s parameter is a GreatApe . Even though Bonobo defines run() and Chimpanzee defines jump() , neither function is part of GreatApe . Often when you override a function, you want to call the base-class version of that function (for one thing, to reuse the code), as seen in the overrides for eat() . This produces a conundrum: If you simply call eat() , you call the same function you’re currently inside (as we’ve seen in Recursion ). To call the base-class version of eat() , use the super keyword, short for “superclass.” Exercises and solutions for this atom can be found at AtomicKotlin.com ⁸⁸ . ⁸⁸ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Base Class Initialization When a class inherits another class, Kotlin guarantees that both classes are properly initialized. Kotlin creates valid objects by ensuring that constructors are called: • Constructors for member objects. • Constructors for new objects added in the derived class. • The constructor for the base class. In our Inheritance examples, the base classes didn’t have constructor parameters. If a base class does have constructor parameters, a derived class must provide those arguments during construction. Here’s the first GreatApe example, rewritten with constructor parameters: // BaseClassInit/GreatApe3.kt package baseclassinit import atomictest.eq open class GreatApe ( val weight: Double, val age: Int ) open class Bonobo (weight: Double, age: Int) : GreatApe(weight, age) class Chimpanzee (weight: Double, age: Int) : GreatApe(weight, age) class BonoboB (weight: Double, age: Int) : Bonobo(weight, age) fun info (ape: GreatApe) = ","Base Class Initialization 323 weight: ${ape.weight} age: ${ape.age} fun main () { info(GreatApe( 100.0 , 12 )) eq weight: 100.0 age: 12 info(Bonobo( 110.0 , 13 )) eq weight: 110.0 age: 13 info(Chimpanzee( 120.0 , 14 )) eq weight: 120.0 age: 14 info(BonoboB( 130.0 , 15 )) eq weight: 130.0 age: 15 } When we inherit from GreatApe , Kotlin forces us to pass the necessary constructor arguments to the GreatApe base class, otherwise you get a compile-time error message. After Kotlin creates memory for your object, it calls the base-class constructor first, then the constructor for the next-derived class, and so on until it reaches the most-derived constructor. This way, all constructor calls can rely on the validity of all the sub-objects created before them. Indeed, those are the only things it knows about; a Bonobo knows that it inherits from GreatApe and the Bonobo constructor can call functions in the GreatApe class, but a GreatApe cannot know whether it’s a Bonobo or a Chimpanzee , or call functions specific to those subclasses. When you inherit, the derived-class constructor must call the primary base-class constructor, unless there are secondary constructors in the base class, in which case you may call one of those instead. The derived-class constructor must pass the appropriate arguments to the base-class constructor: // BaseClassInit/House.kt package baseclassinit import atomictest.eq open class House ( val address: String, val state: String, val zip: String ){ constructor (fullAddress: String) : this (fullAddress.substringBefore( ,  ), Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Base Class Initialization 324 fullAddress.substringAfter( ,  ) .substringBefore(  ), fullAddress.substringAfterLast(  )) val fullAddress: String get () = $address, $state $zip } class VacationHouse ( address: String, state: String, zip: String, val startMonth: String, val endMonth: String ): House(address, state, zip) { override fun toString () = Vacation house at $fullAddress  + from $startMonth to $endMonth } class TreeHouse ( val name: String ): House( Tree Street, TR 00000 ){ override fun toString () = $name tree house at $fullAddress } fun main () { val vacationHouse = VacationHouse( address = 8 Target St. , state = KS , zip = 66632 , startMonth = May , endMonth = September ) vacationHouse eq Vacation house at 8 Target St.,  + KS 66632 from May to September val tree = TreeHouse( Oak ) tree eq Oak tree house at Tree Street, TR 00000 } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Base Class Initialization 325 When VacationHouse inherits from House it passes the appropriate arguments to the primary House constructor. It also adds its own parameters startMonth and endMonth —you aren’t limited by the number, type or order of the parameters in the base class. Your only responsibility is to provide the correct arguments in the call to the base-class constructor. In a derived class, you call an overloaded base-class constructor by passing the necessary constructor arguments in the base-class constructor call. You see this in the definitions of VacationHouse and TreeHouse . Each calls a different base-class constructor. Inside a secondary constructor of a derived class you can either call the base-class constructor or a different derived-class constructor: // BaseClassInit/OtherConstructors.kt package baseclassinit import atomictest.eq open class Base ( val i: Int) class Derived : Base { constructor (i: Int) : super (i) constructor () : this ( 9 ) } fun main () { val d1 = Derived( 11 ) d1.i eq 11 val d2 = Derived() d2.i eq 9 } To call the base-class constructor, use the super keyword, passing the constructor arguments as if it is a function call. Use this to call another constructor of the same class. If you inherit from a class and don’t provide any secondary constructors, you must call a constructor of a base class after the base class name: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Base Class Initialization 326 // BaseClassInit/NoArgConstructor.kt package baseclassinit open class SuperClass1 ( val i: Int) class SubClass1 (i: Int) : SuperClass1(i) open class SuperClass2 class SubClass2 : SuperClass2() When you don’t pass any constructor arguments, Kotlin still requires empty paren-theses after the base class name, to call that constructor without arguments. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁸⁹ . ⁸⁹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Abstract Classes An abstract class is like an ordinary class except one or more functions or properties is incomplete—a function lacks a definition or a property is declared without initialization. An interface is like an abstract class but without state . Kotlin insists that you use the abstract modifier to mark class members that have missing definitions. Any class that contains abstract functions or properties must also be marked abstract . Try removing any of the abstract modifiers below and see what message you get: // Abstract/AbstractKeyword.kt package abstractclasses abstract class WithProperty { abstract val x: Int } abstract class WithFunctions { abstract fun f (): Int abstract fun g (n: Double) } WithProperty declares x with no initialization value (a declaration describes something without providing a definition to create storage for a value or code for a function). If there isn’t an initializer, Kotlin requires references to be abstract , and expects the abstract modifier on the class. Without an initializer, Kotlin cannot infer the type, so it also requires type information for an abstract reference. WithFunctions declares f() and g() but provides no function definitions, again forcing you to add the abstract modifier to the functions and the containing class. If you don’t give a return type for the function, as with g() , Kotlin assumes it returns Unit . ","Abstract Classes 328 Abstract functions and properties must somehow exist (be made concrete ) in the class that you ultimately create from the abstract class. All functions and properties declared in an interface are abstract by default, which makes an interface similar to an abstract class. When an interface contains a function or property declaration the abstract modifier is redundant and can be removed. These two interfaces are equivalent: // Abstract/Redundant.kt package abstractclasses interface Redundant { abstract val x: Int abstract fun f (): Int abstract fun g (n: Double) } interface Removed { val x: Int fun f (): Int fun g (n: Double) } The difference between interfaces and abstract classes is that an abstract class can contain state , while an interface cannot. State is the data stored inside properties. In the following, the state of IntList consists of the values stored in the properties name and list . // Abstract/StateOfAClass.kt package abstractstate import atomictest.eq class IntList ( val name: String) { val list = mutableListOf<Int>() } fun main () { val ints = IntList( numbers ) ints.name eq numbers ints.list += 7 ints.list eq listOf( 7 ) } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Abstract Classes 329 An interface may declare properties, but the actual data is only stored in subclasses. An interface isn’t allowed to store values in its properties: // Abstract/NoStateInInterfaces.kt package abstractclasses interface IntList { val name: String // Doesn't compile: // val list = listOf(0) } Both interfaces and abstract classes can contain functions with implementations. You can call other abstract members from such functions: // Abstract/Implementations.kt package abstractclasses import atomictest.eq interface Parent { val ch: Char fun f (): Int fun g () = ch = $ch; f() = ${f()} } class Actual ( override val ch: Char // [1] ): Parent { override fun f () = 17 // [2] } class Other : Parent { override val ch: Char // [3] get () = 'B' override fun f () = 34 // [4] } fun main () { Actual( 'A' ).g() eq ch = A; f() = 17 // [5] Other().g() eq ch = B; f() = 34 // [6] } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Abstract Classes 330 Parent declares an abstract property ch and an abstract function f() that must be overridden in any implementing classes. Lines [1] -[4] show different implementa-tions of these members in subclasses. g() uses abstract members even though those have no definitions at that point. Interfaces and abstract classes guarantee that all abstract properties and functions are implemented before any objects can be created—and you can’t call a member function unless you’ve got an object. Lines [5] and [6] demonstrate that different actual implementations of ch and f() are called. Since an interface can contain function implementations, it also can contain custom property accessors if the corresponding property doesn’t change state: // Abstract/WithPropertyAccessor.kt package abstractclasses import atomictest.eq interface WithPropertyAccessor { val a: Int get () = 11 } class Impl : WithPropertyAccessor fun main () { Impl().a eq 11 } Although an interface can implement functions and properties via property ac-cessors, it’s considered good style to provide only simple implementations of the auxiliary functions that may depend on the declared properties and functions. You might wonder why we need interfaces when we have these more powerful abstract classes. To understand the importance of “a class without state,” let’s look at the concept of multiple inheritance, which Kotlin doesn’t support. In Kotlin, a class can inherit from no more than one class: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Abstract Classes 331 // Abstract/NoMultipleInheritance.kt package multipleinheritance1 open class Animal open class Mammal : Animal() open class AquaticAnimal : Animal() // More than one base class doesn't compile: // class Dolphin : Mammal(), AquaticAnimal() If you try to compile the commented code, Kotlin emits an error: Only one class may appear in a supertype list . Java works the same way. The original Java designers decided that multiple inheri-tance in C++ was a bad idea. The main complexity and dissatisfaction at that time came from multiple state inheritance. The rules managing inheritance of multiple states are complicated and can easily cause confusion and surprising behavior. Java added an elegant solution to this problem by introducing interfaces, which can’t contain state. Java forbids multiple state inheritance, but allows multiple interface inheritance, and Kotlin follows this design: // Abstract/MultipleInterfaceInheritance.kt package multipleinheritance2 interface Animal interface Mammal : Animal interface AquaticAnimal : Animal class Dolphin : Mammal, AquaticAnimal Note that, just like classes, interfaces can inherit from each other. When inheriting from several interfaces, it’s possible to simultaneously override two or more functions with the same signature (the name combined with the parameters and return type). If function or property signatures collide, you must resolve the collisions by hand, as seen in class C : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Abstract Classes 332 // Abstract/InterfaceCollision.kt package collision import atomictest.eq interface A { fun f () = 1 fun g () = A.g val n: Double get () = 1.1 } interface B { fun f () = 2 fun g () = B.g val n: Double get () = 2.2 } class C :A,B{ override fun f () = 0 override fun g () = super <A>.g() override val n: Double get () = super <A>.n + super <B>.n } fun main () { val c = C() c.f() eq 0 c.g() eq A.g c.n eq 3.3 } The functions f() and g() and the property n have identical signatures in interfaces A and B , so Kotlin doesn’t know what to do and produces an error message if you don’t resolve the issue (try individually commenting the definitions in C ). Member functions and properties can be overridden with new definitions as in f() , but functions can also access the base versions of themselves using the super keyword, specifying the base class in angle brackets, as in the definition of C.g() and C.n . Collisions where the identifier is the same but the type is different are not allowed in Kotlin, so you cannot resolve them. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Abstract Classes 333 Exercises and solutions for this atom can be found at AtomicKotlin.com ⁹⁰ . ⁹⁰ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Upcasting Taking an object reference and treating it as a reference to its base type is called upcasting . The term upcast refers to the traditional way inheritance hierarchies are drawn, with the base class at the top and derived classes fanning out below. The approach of inheriting and adding new member functions comes from one of the first successful object-oriented languages, Smalltalk, in which everything was an object and the only way to create new classes was to inherit from an existing class and (often) add new member functions. Smalltalk was one of the main influences on the design of Java, which also required everything to be an object. Kotlin frees us from these constraints. We have stand-alone functions so everything doesn’t need to be contained within classes. Extension functions allow us to add functionality without inheritance. Indeed, the requirement that we use the open keyword to allow inheritance and overriding makes inheritance a very conscious and intentional choice, not something to use all the time. More precisely, it narrows inheritance to a very specific use, an abstraction that allows us to write code that can be reused across multiple classes within a single hierarchy. Polymorphism explores these mechanics, but first you must understand upcasting. Consider some shapes that can be drawn and erased: ","Upcasting 335 // Upcasting/Shapes.kt package upcasting interface Shape { fun draw (): String fun erase (): String } class Circle : Shape { override fun draw () = Circle.draw override fun erase () = Circle.erase } class Square : Shape { override fun draw () = Square.draw override fun erase () = Square.erase fun color () = Square.color } class Triangle : Shape { override fun draw () = Triangle.draw override fun erase () = Triangle.erase fun rotate () = Triangle.rotate } The show() function accepts any Shape : // Upcasting/Drawing.kt package upcasting import atomictest.* fun show (shape: Shape) { trace( Show: ${shape.draw()} ) } fun main () { listOf(Circle(), Square(), Triangle()) .forEach( :: show) trace eq  Show: Circle.draw Show: Square.draw Show: Triangle.draw Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Upcasting 336  } In main() , show() is called with three different types: Circle , Square , and Triangle . The show() parameter is of the base class Shape , so show() accepts all three types. Each of those types is treated as a basic Shape —we say that the specific types are upcast to the basic type. When we pass a Circle , Square , or Triangle as an argument of type Shape in show() , we cast up the inheritance hierarchy. In the process of upcasting, we lose the specific information about whether an object is of type Circle , Square , or Triangle . In each case, it becomes nothing more than a Shape object. Treating specific types as the more general type is the entire point of inheritance. The mechanics of inheritance exist solely to fulfill the goal of upcasting to the base type. Because of this abstraction (“everything is a Shape ”), we can write a single show() function instead of writing one for every type of element. Upcasting is where code reuse happens for objects. Indeed, in virtually every case where there’s inheritance without upcasting, inheri-tance is being misused—it’s unnecessary, and it makes the code needlessly compli-cated. This misuse is the reason for the maxim prefer composition to inheritance . If the point of inheritance is the ability to substitute a derived type for a base type, what happens to the extra member functions: color() in Square and rotate() in Triangle ? Substitutability , also called the Liskov Substitution Principle , says that, after up-casting, the derived type can be treated exactly like the base type—no more and no less. This means that any member functions added to the derived class are, in effect, “trimmed off.” They still exist, but because they are not part of the base-class interface, they are unavailable within show() : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Upcasting 337 // Upcasting/TrimmedMembers.kt package upcasting import atomictest.* fun trim (shape: Shape) { trace(shape.draw()) trace(shape.erase()) // Doesn't compile: // shape.color() // [1] // shape.rotate() // [2] } fun main () { trim(Square()) trim(Triangle()) trace eq  Square.draw Square.erase Triangle.draw Triangle.erase  } You can’t call color() in line [1] because the Square instance was upcast to a Shape , and you can’t call rotate() in line [2] because the Triangle instance is also upcast to a Shape . The only member functions available are the ones that are common to all Shape s—those defined in the base type Shape . Note that the same applies when you directly assign a subtype of Shape to a general Shape . The specified type determines the available members: // Upcasting/Assignment.kt import upcasting.* fun main () { val shape1: Shape = Square() val shape2: Shape = Triangle() // Doesn't compile: // shape1.color() // shape2.rotate() } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Upcasting 338 After an upcast, you can only call members of the base type. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁹¹ . ⁹¹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Polymorphism Polymorphism is an ancient Greek term meaning “many forms.” In pro-gramming, polymorphism means an object or its members have multiple implementations. Consider a simple hierarchy of Pet types. The Pet class says that all Pet s can speak() . Dog and Cat override the speak() member function: // Polymorphism/Pet.kt package polymorphism import atomictest.eq open class Pet { open fun speak () = Pet } class Dog : Pet() { override fun speak () = Bark! } class Cat : Pet() { override fun speak () = Meow } fun talk (pet: Pet) = pet.speak() fun main () { talk(Dog()) eq Bark! // [1] talk(Cat()) eq Meow // [2] } Notice the talk() function parameter. When passing a Dog or a Cat to talk() , the specific type is forgotten and becomes a plain Pet —both Dog s and Cat s are upcast to Pet . Since the objects are now treated as plain Pet s, shouldn’t the output for both lines [1] and [2] be Pet ? ","Polymorphism 340 talk() doesn’t know the exact type of Pet it receives. Despite that, when you call speak() through a reference to the base-class Pet , the correct subclass implemen-tation is called, and you get the desired behavior. Polymorphism occurs when a parent class reference contains a child class instance. When you call a member on that parent class reference, polymorphism produces the correct overridden member from the child class. Connecting a function call to a function body is called binding . Ordinarily, you don’t think much about binding because it happens statically, at compile time. With polymorphism, the same operation must behave differently for different types—but the compiler cannot know in advance which function body to use. The function body must be determined dynamically, at run time, using dynamic binding . Dynamic binding is also called late binding or dynamic dispatch . Only at run time can Kotlin determine the exact speak() function to call. Thus we say that the binding for the polymorphic call pet.speak() occurs dynamically. Now suppose we want to create a fantasy game. Each Character in the game has a name and can play() . We combine Fighter and Magician to build specific characters: // Polymorphism/FantasyGame.kt package polymorphism import atomictest.* abstract class Character ( val name: String) { abstract fun play (): String } interface Fighter { fun fight () = Fight! } interface Magician { fun doMagic () = Magic! } class Warrior : Character( Warrior ), Fighter { override fun play () = fight() } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Polymorphism 341 open class Elf (name: String = Elf ): Character(name), Magician { override fun play () = doMagic() } class FightingElf : Elf( FightingElf ), Fighter { override fun play () = super .play() + fight() } fun Character .playTurn() = // [1] trace(name + :  + play()) // [2] fun main () { val characters: List<Character> = listOf( Warrior(), Elf(), FightingElf() ) characters.forEach { it.playTurn() } // [3] trace eq  Warrior: Fight! Elf: Magic! FightingElf: Magic!Fight!  } In main() we create a List<Character> . The objects are upcast to Character as they are placed into the List . Then we call playTurn() on each Character in the List . The trace shows that calling playTurn() on different objects produces different output. playTurn() is an extension function on the base type Character . When called in line [3] , it is statically bound, which means the exact function to be called is determined at compile time. In line [3] , the compiler determines that there is only one playTurn() function implementation—the one defined on line [1] . When the compiler analyzes the play() function call on line [2] , it doesn’t know which function implementation to use. If the Character is an Elf , it must call Elf ’s play() . If the Character is a FightingElf , it must call FightingElf ’s play() . It might also need to call a function from an as-yet-undefined subclass. The function Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Polymorphism 342 binding differs from invocation to invocation. At compile time, the only certainty is that play() on line [2] is a member function of one of the Character subclasses. The specific subclass can only be known at runtime, based on the actual Character type. Dynamic binding isn’t free. The additional logic that determines the runtime type slightly impacts the performance compared to static binding. To force clarity when using inheritance, Kotlin defaults to closed classes and member functions. To inherit and override, you must be explicit. A language feature such as the when statement can be learned in isolation. Poly-morphism cannot—it only works in concert, as part of the larger picture of class relationships. To use object-oriented techniques effectively in your programs, you must expand your perspective to include not just members of an individual class, but also the commonality among classes and their relationships with each other. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁹² . ⁹² https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Composition One of the most compelling arguments for object-oriented programming is code reuse. You may first think of “reuse” as “copying code.” Copying seems like an easy solution, but it doesn’t work very well. As time passes, your needs evolve. If you apply changes to only one common place instead of duplicating them to every copied piece of code, you avoid maintenance nightmares. In object-oriented programming you reuse code by creating new classes, but instead of creating them from scratch, you use existing classes that someone has already built and debugged. The trick is to use the classes without soiling the existing code. Inheritance is one way to achieve this. Inheritance creates a new class as a type of an existing class. You add code to the form of the existing class without modifying the original. Inheritance is a cornerstone of object-oriented programming. You can also choose a more straightforward approach, by creating objects of existing classes inside your new class. This is called composition , because the new class is composed of objects of existing classes. You’re reusing the functionality of the code, not its form. You’ve seen composition used frequently in this book. Composition is often over-looked because it seems so simple—you just put an object inside a class. Composition is a has-a relationship. We can take the phrase, “A house is a building and has a kitchen” and express it in code: ","Composition 344 // Composition/House1.kt package composition1 interface Building interface Kitchen interface House : Building { val kitchen: Kitchen } Inheritance describes an is-a relationship, and it’s often helpful to read the descrip-tion aloud: “A house is a building.” That sounds right, doesn’t it? When the is-a relationship makes sense, inheritance usually makes sense. If your house has two kitchens, composition yields an easy solution: // Composition/House2.kt package composition2 interface Building interface Kitchen interface House : Building { val kitchen1: Kitchen val kitchen2: Kitchen } To allow any number of kitchens, use composition with a collection: // Composition/House3.kt package composition3 interface Building interface Kitchen interface House : Building { val kitchens: List<Kitchen> } We spend time and effort understanding inheritance because it’s more complex, and that complexity might give the impression that it’s somehow more important. On the contrary: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Composition 345 Prefer composition to inheritance Composition produces simpler designs and implementations. This doesn’t mean you should avoid inheritance. It’s just that we tend to get bound up in those more complicated relationships. The maxim prefer composition to inheritance is a reminder to step back, look at your design, and wonder whether you can simplify it with composition. The ultimate goal is to properly apply your tools and produce a good design. Composition appears trivial, but is powerful. When a class grows and becomes responsible for different unrelated things, composition helps pull them apart. Use composition to simplify the complicated logic of a class. Choosing Between Composition and Inheritance Both composition and inheritance place subobjects inside your new class—composition has explicit subobjects while inheritance has implicit subjobjects. When do you choose one over the other? Composition provides the functionality of an existing class, but not its interface. You embed an object to use its features in your new class, but the user sees the interface you’ve defined for the new class rather than the interface of the embedded object. To hide the object completely, embed it privately: // Composition/Embedding.kt package composition class Features { fun f1 () = feature1 fun f2 () = feature2 } class Form { private val features = Features() fun operation1 () = features.f2() + features.f1() Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Composition 346 fun operation2 () = features.f1() + features.f2() } Features provide implementations for the operations of Form , but the client pro-grammer who uses Form has no access to Features —indeed, the user is effectively unaware of how Form is implemented. This means that if you find a better way to implement Form , you can remove Features and use the better approach without any impact on code that calls Form . If Form inherited Features , the client programmer could expect to upcast Form to Features . The inheritance relationship is then part of Form —the connection is explicit. If you change this, you’ll break code that relies upon it. Sometimes it makes sense to allow the class user to directly access the composition of your new class; that is, to make the member objects public. This is relatively safe, assuming the member objects use appropriate implementation hiding. For some systems, this approach can make the interface easier to understand. Consider a Car : // Composition/Car.kt package composition import atomictest.* class Engine { fun start () = trace( Engine start ) fun stop () = trace( Engine stop ) } class Wheel { fun inflate (psi: Int) = trace( Wheel inflate($psi) ) } class Window ( val side: String) { fun rollUp () = trace( $side Window roll up ) fun rollDown () = trace( $side Window roll down ) } class Door ( val side: String) { Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Composition 347 val window = Window(side) fun open () = trace( $side Door open ) fun close () = trace( $side Door close ) } class Car { val engine = Engine() val wheel = List( 4 ) { Wheel() } // Two door: val leftDoor = Door( left ) val rightDoor = Door( right ) } fun main () { val car = Car() car.leftDoor. open () car.rightDoor.window.rollUp() car.wheel[ 0 ].inflate( 72 ) car.engine.start() trace eq  left Door open right Window roll up Wheel inflate( 72 ) Engine start  } The composition of a Car is part of the analysis of the problem, and not simply part of the underlying implementation. This assists the client programmer’s understanding of how to use the class and requires less code complexity for the creator of the class. This is a special case; you’ll typically use private member objects. When you inherit, you take an existing class and make a special version of it. This specializes a general-purpose class for a particular need. In this example, it would make no sense to compose a car using a vehicle object—a car doesn’t contain a vehicle, it is a vehicle. The is-a relationship is expressed with inheritance, and the has-a relationship is expressed with composition. The cleverness of polymorphism can make it can seem that everything ought to be inherited. This will burden your designs. In fact, if you choose inheritance first when you’re using an existing class to build a new class, things can become needlessly Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Composition 348 complicated. A better approach is to try composition first, especially when it’s not obvious which approach works best. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁹³ . ⁹³ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inheritance & Extensions Inheritance is sometimes used to add functions to a class as a way to reuse it for a new purpose. This can lead to code that is difficult to understand and maintain. Suppose someone has created a Heater class along with functions that act upon a Heater : // InheritanceExtensions/Heater.kt package inheritanceextensions import atomictest.eq open class Heater { fun heat (temperature: Int) = heating to $temperature } fun warm (heater: Heater) { heater.heat( 70 ) eq heating to 70 } For the sake of argument, imagine that Heater is far more complex than this, and that there are many adjunct functions such as warm() . We don’t want to modify this library—we want to reuse it as-is. If what we actually want is an HVAC (Heating Ventilation and Air Conditioning) system, we can inherit Heater and add a cool() function. The existing warm() function, and all other functions that act upon a Heater , still work with our new HVAC type—which would not be true if we had used composition: ","Inheritance & Extensions 350 // InheritanceExtensions/InheritAdd.kt package inheritanceextensions import atomictest.eq class HVAC : Heater() { fun cool (temperature: Int) = cooling to $temperature } fun warmAndCool (hvac: HVAC) { hvac.heat( 70 ) eq heating to 70 hvac.cool( 60 ) eq cooling to 60 } fun main () { val heater = Heater() val hvac = HVAC() warm(heater) warm(hvac) warmAndCool(hvac) } This seems reasonable and expedient. Heater didn’t do everything we wanted, so we inherited HVAC from Heater and tacked on another function. As you saw in Upcasting , object-oriented languages have a mechanism to deal with member functions added during inheritance: the added functions are trimmed off during upcasting and are unavailable to the base class. This is the Liskov Substitution Principle , aka “Substitutability,” which says functions that accept a base class must be able to use objects of derived classes without knowing it. Substitutability is why warm() still works on an HVAC . Although modern OO programming allows the addition of functions during inheri-tance, this can be a “code smell”—it seems expedient but can lead you into trouble. Just because it seems to work doesn’t mean it’s a good idea. In particular, it might negatively impact a later maintainer of the code (which might be you). This kind of problem is called technical debt . Adding functions during inheritance can be useful when the new class is rigorously treated as a base class throughout your system, ignoring the fact that it has its own bases. In Type Checking you’ll see more examples where adding functions during Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inheritance & Extensions 351 inheritance can be a viable technique. What we really wanted when creating the HVAC class was a Heater class with an added cool() function so it works with warmAndCool() . This is exactly what an extension function does, without inheritance: // InheritanceExtensions/ExtensionFuncs.kt package inheritanceextensions2 import inheritanceextensions.Heater import atomictest.eq fun Heater .cool(temperature: Int) = cooling to $temperature fun warmAndCool (heater: Heater) { heater.heat( 70 ) eq heating to 70 heater.cool( 60 ) eq cooling to 60 } fun main () { val heater = Heater() warmAndCool(heater) } Instead of inheriting to extend the base class interface, extension functions extend the base class interface directly, without inheritance. If we had control over the Heater library, we could design it differently, to be more flexible: // InheritanceExtensions/TemperatureDelta.kt package inheritanceextensions import atomictest.* class TemperatureDelta ( val current: Double, val target: Double ) fun TemperatureDelta .heat() { if (current < target) trace( heating to $target ) Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inheritance & Extensions 352 } fun TemperatureDelta .cool() { if (current > target) trace( cooling to $target ) } fun adjust (deltaT: TemperatureDelta) { deltaT.heat() deltaT.cool() } fun main () { adjust(TemperatureDelta( 60.0 , 70.0 )) adjust(TemperatureDelta( 80.0 , 60.0 )) trace eq  heating to 70.0 cooling to 60.0  } In this approach, we control the temperature by choosing among multiple strategies. We could also have made heat() and cool() member functions instead of extension functions. Interface by Convention An extension function can be thought of as creating an interface containing a single function: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inheritance & Extensions 353 // InheritanceExtensions/Convention.kt package inheritanceextensions class X fun X .f() {} class Y fun Y .f() {} fun callF (x: X) = x.f() fun callF (y: Y) = y.f() fun main () { val x = X() val y = Y() x.f() y.f() callF(x) callF(y) } Both X and Y now appear to have a member function called f() , but we don’t get polymorphic behavior so we must overload callF() to make it work for both types. This “interface by convention” is used extensively in the Kotlin libraries, especially when dealing with collections. Although these are predominantly Java collections, the Kotlin library turns them into functional-style collections by adding a large number of extension functions. For example, on virtually any collection-like object, you can expect to find map() and reduce() , among many others. Because the programmer comes to expect this convention, it makes programming easier. The Kotlin standard library Sequence interface contains a single member function. The other Sequence functions are all extensions⁹⁴ —there are well over one hundred. Initially, this approach was used for compatibility with Java collections, but now it’s part of the Kotlin philosophy: Create a simple interface containing only the methods that define its essence, then create all auxiliary operations as extensions. ⁹⁴ https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inheritance & Extensions 354 The Adapter Pattern A library often defines a type and provides functions that accept parameters of that type and/or return that type: // InheritanceExtensions/UsefulLibrary.kt package usefullibrary interface LibType { fun f1 () fun f2 () } fun utility1 (lt: LibType) { lt.f1() lt.f2() } fun utility2 (lt: LibType) { lt.f2() lt.f1() } To use this library, you must somehow convert your existing class to LibType . Here, we inherit from an existing MyClass to produce MyClassAdaptedForLib , which implements LibType and can thus be passed to the UsefulLibrary functions: // InheritanceExtensions/Adapter.kt package inheritanceextensions import usefullibrary.* import atomictest.* open class MyClass { fun g () = trace( g() ) fun h () = trace( h() ) } fun useMyClass (mc: MyClass) { mc.g() mc.h() } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inheritance & Extensions 355 class MyClassAdaptedForLib : MyClass(), LibType { override fun f1 () = h() override fun f2 () = g() } fun main () { val mc = MyClassAdaptedForLib() utility1(mc) utility2(mc) useMyClass(mc) trace eq  h() g() g() h() g() h()  } Although this does extend a class during inheritance, the new member functions are used only for the purpose of adapting to UsefulLibrary . Note that everywhere else, objects of MyClassAdaptedForLib can be treated as MyClass objects, as in the call to useMyClass() . There’s no code that uses the extended MyClassAdaptedForLib where users of the base class must know about the derived class. Adapter.kt relies on MyClass being open for inheritance. What if you don’t control MyClass and it’s not open ? Fortunately, adapters can also be built using composition. Here, we add a MyClass field inside MyClassAdaptedForLib : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inheritance & Extensions 356 // InheritanceExtensions/ComposeAdapter.kt package inheritanceextensions2 import usefullibrary.* import atomictest.* class MyClass { // Not open fun g () = trace( g() ) fun h () = trace( h() ) } fun useMyClass (mc: MyClass) { mc.g() mc.h() } class MyClassAdaptedForLib : LibType { val field = MyClass() override fun f1 () = field.h() override fun f2 () = field.g() } fun main () { val mc = MyClassAdaptedForLib() utility1(mc) utility2(mc) useMyClass(mc.field) trace eq  h() g() g() h() g() h()  } This is not quite as clean as Adapter.kt —you must explicitly access the MyClass object as seen in the call to useMyClass(mc.field) . But it still handily solves the problem of adapting to a library. Extension functions seem like they might be very useful for creating adapters. Unfortunately, you cannot implement an interface by collecting extension functions. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inheritance & Extensions 357 Members versus Extensions There are cases where you are forced to use member functions rather than extensions. If a function must access a private member, you have no choice but to make it a member function: // InheritanceExtensions/PrivateAccess.kt package inheritanceextensions import atomictest.eq class Z ( var i: Int = 0 ){ private var j= 0 fun increment () { i++ j++ } } fun Z .decrement() { i--// j -- // Cannot access } The member function increment() can manipulate j , but the extension function decrement() doesn’t have access to j because j is private . The most significant limitation to extension functions is that they cannot be overrid-den: // InheritanceExtensions/NoExtOverride.kt package inheritanceextensions import atomictest.* open class Base { open fun f () = Base.f() } class Derived : Base() { override fun f () = Derived.f() } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inheritance & Extensions 358 fun Base .g() = Base.g() fun Derived .g() = Derived.g() fun useBase (b: Base) { trace( Received ${b::class.simpleName} ) trace(b.f()) trace(b.g()) } fun main () { useBase(Base()) useBase(Derived()) trace eq  Received Base Base.f() Base.g() Received Derived Derived.f() Base.g()  } The trace output shows that polymorphism works with the member function f() but not the extension function g() . When a function doesn’t need overriding and you have adequate access to the members of a class, you can define it as either a member function or an extension function—a stylistic choice that should maximize code clarity. A member function reflects the essence of a type; you can’t imagine the type without that function. Extension functions indicate “auxiliary” or “convenience” operations that support or utilize the type, but are not necessarily essential to that type’s existence. Including auxiliary functions inside a type makes it harder to reason about, while defining some functions as extensions keeps the type clean and simple. Consider a Device interface. The model and productionYear properties are in-trinsic to Device because they describe key features. Functions like overpriced() and outdated() can be defined either as members of the interface or as extension functions. Here they are member functions: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inheritance & Extensions 359 // InheritanceExtensions/DeviceMembers.kt package inheritanceextensions1 import atomictest.eq interface Device { val model: String val productionYear: Int fun overpriced () = model.startsWith( i ) fun outdated () = productionYear < 2050 } class MyDevice ( override val model: String, override val productionYear: Int ): Device fun main () { val gadget: Device = MyDevice( my first phone , 2000 ) gadget.outdated() eq true gadget.overpriced() eq false } If we assume overpriced() and outdated() will not be overridden in subclasses, they can be defined as extensions: // InheritanceExtensions/DeviceExtensions.kt package inheritanceextensions2 import atomictest.eq interface Device { val model: String val productionYear: Int } fun Device .overpriced() = model.startsWith( i ) fun Device .outdated() = productionYear < 2050 class MyDevice ( Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inheritance & Extensions 360 override val model: String, override val productionYear: Int ): Device fun main () { val gadget: Device = MyDevice( my first phone , 2000 ) gadget.outdated() eq true gadget.overpriced() eq false } Interfaces that only contain descriptive members are easier to comprehend and reason about, so the Device interface in the second example is probably a better choice. Ultimately, however, it’s a design decision. Summary Languages like C++ and Java allow inheritance unless you specifically disallow it. Kotlin assumes that you won’t be using inheritance—it actively prevents inheritance and polymorphism unless they are intentionally allowed using the open keyword. This provides insight into Kotlin’s orientation: Often, functions are all you need. Sometimes objects are very useful. Objects are one tool among many, but they’re not for everything. If you’re pondering how to use inheritance in a particular situation, consider whether you need inheritance at all, and apply the maxim Prefer extension functions and composition to inheritance (modified from the book Design Patterns⁹⁵ ). Exercises and solutions for this atom can be found at AtomicKotlin.com ⁹⁶ . ⁹⁵ https://en.wikipedia.org/wiki/Design_Patterns ⁹⁶ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Class Delegation Both composition and inheritance place subobjects inside your new class. Composition places a subobject explicitly while inheritance does it implic-itly. Composition embeds the functionality of an existing class inside your new class, but does not expose its interface. For a class to reuse an existing implementation and implement an interface, you have two options: inheritance and class delegation . Class delegation is midway between inheritance and composition. Like composition, you place a member object in the class you’re building. Like inheritance, your new class exposes the interface of the member object. You cannot inherit a class when the superclass is not open , or if your new class is already extending another class. Delegation solves this by adding interface exposure to composition. For code reuse, class delegation makes composition as powerful as inheritance. To understand how it works, consider implementing class delegation without using Kotlin’s language support. In this example, a spaceship needs a control module: // ClassDelegation/SpaceShipControls.kt package classdelegation interface ShipControls { fun up (velocity: Int): String fun down (velocity: Int): String fun left (velocity: Int): String fun right (velocity: Int): String fun forward (velocity: Int): String fun back (velocity: Int): String fun turboBoost (): String } class SpaceShipControls : ShipControls { ","Class Delegation 362 override fun up (velocity: Int) = up $velocity override fun down (velocity: Int) = down $velocity override fun left (velocity: Int) = left $velocity override fun right (velocity: Int) = right $velocity override fun forward (velocity: Int) = forward $velocity override fun back (velocity: Int) = back $velocity override fun turboBoost () = turbo boost } To expand the functionality of the controls or adjust some commands, we might try inheriting from SpaceShipControls —except that SpaceShipControls is not open . To expose the member functions in ShipControls , you can create an instance of SpaceShipControls as a property and explicitly delegate all the exposed member functions to that instance: // ClassDelegation/ExplicitDelegation.kt package classdelegation import atomictest.eq class ExplicitControls : ShipControls { private val controls = SpaceShipControls() // Delegated members: override fun up (velocity: Int) = controls.up(velocity) override fun back (velocity: Int) = controls.back(velocity) override fun down (velocity: Int) = controls.down(velocity) override fun forward (velocity: Int) = controls.forward(velocity) override fun left (velocity: Int) = controls.left(velocity) override fun right (velocity: Int) = controls.right(velocity) // Modified implementation: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Class Delegation 363 override fun turboBoost (): String = controls.turboBoost() + ... boooooost! } fun main () { val controls = ExplicitControls() controls.forward( 100 ) eq forward 100 controls.turboBoost() eq turbo boost... boooooost! } The functions are forwarded to the underlying controls object, and the resulting interface is the same as if you had used regular inheritance. You can also provide implementation changes, as with turboBoost() . Kotlin supports class delegation, so instead of writing explicit function implementa-tions as in the example above, you can simply specify an object to use as a delegate. To delegate to a class, place the by keyword after the interface name, followed by the member property to use as the delegate: class A ( val b: BImpl) : B by b Read this as “class A implements interface B by using the b member object.” The object you want to use as a delegate must be a constructor argument. ExplicitDelegation.kt can now be rewritten using by : // ClassDelegation/DelegatedControls.kt package classdelegation import atomictest.eq class DelegatedControls ( private val controls: SpaceShipControls = SpaceShipControls() ): ShipControls by controls { override fun turboBoost (): String = ${controls.turboBoost()}... boooooost! } fun main () { val controls = DelegatedControls() Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Class Delegation 364 controls.forward( 100 ) eq forward 100 controls.turboBoost() eq turbo boost... boooooost! } When Kotlin sees the by keyword, it generates code similar to what we wrote for ExplicitDelegation.kt . Now all the functions of the member object are accessible via the outer object, but without writing all that extra code. Kotlin doesn’t support multiple class inheritance, but you can simulate it using class delegation. In general, multiple inheritance is used to combine classes that have completely different functionality. For example, suppose you want to produce a button by combining a class that draws a rectangle on the screen with a class that manages mouse events: // ClassDelegation/ModelingMI.kt package classdelegation import atomictest.eq interface Rectangle { fun paint (): Int } class ButtonImage ( val width: Int, val height: Int ): Rectangle { override fun paint () = width * height } interface MouseManager { fun clicked (): Boolean fun hovering (): Boolean } class UserInput : MouseManager { override fun clicked () = true override fun hovering () = true } // Even if we make the classes open, we Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Class Delegation 365 // get an error because only one class may // appear in a supertype list: // class Button : ButtonImage(), UserInput() class Button ( val width: Int, val height: Int, val image: Rectangle = ButtonImage(width, height), val input: MouseManager = UserInput() ): Rectangle by image, MouseManager by input fun main () { val button = Button( 10 , 5 ) button.paint() eq 50 button.clicked() eq true button.hovering() eq true // Can upcast to both delegated types: val rectangle: Rectangle = button val mouseManager: MouseManager = button } The class Button implements two interfaces: Rectangle and MouseManager . It can’t inherit from implementations of both ButtonImage and UserInput , but it can delegate to both of them. Notice that a Button can be upcast to both of its delegated types. This was the goal of multiple inheritance, so delegation effectively solves the need for multiple inheritances. Use class delegation with care. Among the three choices—inheritance, composition and class delegation—try composition first. It’s the simplest approach and serves the majority of use cases. Inheritance is necessary when you need a hierarchy of types, to create relationships between those types. Class delegation can work when those options don’t. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁹⁷ . ⁹⁷ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Downcasting Downcasting discovers the specific type of a previously-upcast object. Upcasts are always safe because the base class cannot have a bigger interface than the derived class. Every base-class member is guaranteed to exist and is therefore safe to call. Although object-oriented programming is primarily focused on upcasting, there are situations where downcasting can be a useful and expedient approach. Downcasting happens at runtime, and is also called run-time type identification (RTTI). Consider a class hierarchy where the base type has a narrower interface than the derived types. If you upcast an object to the base type, the compiler no longer knows the specific type. In particular, it cannot know what extended functions are safe to call: // DownCasting/NarrowingUpcast.kt package downcasting interface Base { fun f () } class Derived1 : Base { override fun f () {} fun g () {} } class Derived2 : Base { override fun f () {} fun h () {} } fun main () { val b1: Base = Derived1() // Upcast ","Downcasting 367 b1.f() // Part of Base // b1.g() // Not part of Base val b2: Base = Derived2() // Upcast b2.f() // Part of Base // b2.h() // Not part of Base } To solve this problem, there must be some way to guarantee that a downcast is correct, so you don’t accidentally cast to the wrong type and call a non-existent member. Smart Casts Smart casts in Kotlin are automatic downcasts. The is keyword checks whether an object is a particular type. Any code within the scope of that check assumes that it is that type: // DownCasting/IsKeyword.kt import downcasting.* fun main () { val b1: Base = Derived1() // Upcast if (b1 is Derived1) b1.g() // Within scope of is check val b2: Base = Derived2() // Upcast if (b2 is Derived2) b2.h() // Within scope of is check } If b1 is of type Derived1 , you can call g() . If b2 is of type Derived2 , you can call h() . Smart casts are especially useful inside when expressions that use is to search for the type of the when argument. Note that, in main() , each specific type is first upcast to a Creature , then passed to what() : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Downcasting 368 // DownCasting/Creature.kt package downcasting import atomictest.eq interface Creature class Human : Creature { fun greeting () = I'm Human } class Dog : Creature { fun bark () = Yip! } class Alien : Creature { fun mobility () = Three legs } fun what (c: Creature): String = when (c) { is Human -> c.greeting() is Dog -> c.bark() is Alien -> c.mobility() else -> Something else } fun main () { val c: Creature = Human() what(c) eq I'm Human what(Dog()) eq Yip! what(Alien()) eq Three legs class Who : Creature what(Who()) eq Something else } In main() , upcasting happens when assigning a Human to Creature , passing a Dog to what() , passing an Alien to what() , and passing a Who to what() . Class hierarchies are traditionally drawn with the base class at the top and derived classes fanning down below it. what() takes a previously-upcast Creature and discovers its exact type, thus casting that Creature object down the inheritance hierarchy, from the more-general base class to a more-specific derived class. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Downcasting 369 A when expression that produces a value requires an else branch to capture all remaining possibilities. In main() , the else branch is tested using an instance of the local class Who . Each branch of the when uses c as if it is the type we checked for: calling greeting() if c is Human , bark() if it’s a Dog and mobility() if it’s an Alien . The Modifiable Reference Automatic downcasts are subject to a special constraint. If the base-class reference to the object is modifiable (a var ), then there’s a possibility that this reference could be assigned to a different object between the instant that the type is detected and the instant when you call specific functions on the downcast object. That is, the specific type of the object might change between type detection and use. In the following, c is the argument to when , and Kotlin insists that this argument be immutable so that it cannot change between the is expression and the call made after the -> : // DownCasting/MutableSmartCast.kt package downcasting class SmartCast1 ( val c: Creature) { fun contact () { when (c) { is Human -> c.greeting() is Dog -> c.bark() is Alien -> c.mobility() } } } class SmartCast2 ( var c: Creature) { fun contact () { when ( val c=c){ // [1] is Human -> c.greeting() // [2] is Dog -> c.bark() is Alien -> c.mobility() } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Downcasting 370 } } The c constructor argument is a val in SmartCast1 and a var in SmartCast2 . In both cases c is passed into the when expression, which uses a series of smart casts. In [1] , the expression val c = c is odd, and only used here for convenience—we don’t recommend “shadowing” identifier names in normal code. val c creates a new local identifier c that is assigned to the property c . However, the property c is a var while the local (shadowed) c is a val . Try removing the val c = . This means that the c will now be the property, which is a var . This produces an error message for line [2] : • Smart cast to ‘Human’ is impossible, because ‘c’ is a mutable property that could have been changed by this time is Dog and is Alien produce similar messages. This is not limited to while expressions; there are other situations that can produce the same error message. The change described in the error message typically happens through concurrency , when multiple independent tasks have the opportunity to change c at unpredictable times. (Concurrency is an advanced topic that we do not cover in this book). Kotlin forces us to ensure that c will not change from the time that the is check is performed and the time that c is used as the downcast type. SmartCast1 does this by making the c property a val , and SmartCast2 does it by introducing the local val c . Similarly, complex expressions cannot be smart-cast because the expression might be re-evaluated. Properties that are open for inheritance can’t be smart-cast because their value might be overridden in subclasses, so there’s no guarantee the value will be the same on the next access. The as Keyword The as keyword forcefully casts a general type to a specific type: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Downcasting 371 // DownCasting/Unsafe.kt package downcasting import atomictest.* fun dogBarkUnsafe (c: Creature) = (c as Dog).bark() fun dogBarkUnsafe2 (c: Creature): String { c as Dog c.bark() return c.bark() + c.bark() } fun main () { dogBarkUnsafe(Dog()) eq Yip! dogBarkUnsafe2(Dog()) eq Yip!Yip! (capture { dogBarkUnsafe(Human()) }).startsWith( ClassCastException ) eq true } dogBarkUnsafe2() shows a second form of as : if you say c as Dog , then c is treated as a Dog throughout the rest of the scope. A failing as cast throws a ClassCastException . A plain as is called an unsafe cast . When a safe cast as? fails, it doesn’t throw an exception, but instead returns null . You must then do something reasonable with that null to prevent a later NullPointerException . The Elvis operator (described in Safe Calls & the Elvis Operator ) is usually the most straightforward approach: // DownCasting/Safe.kt package downcasting import atomictest.eq fun dogBarkSafe (c: Creature) = (c as ? Dog) ?. bark() ?: Not a Dog fun main () { dogBarkSafe(Dog()) eq Yip! dogBarkSafe(Human()) eq Not a Dog } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Downcasting 372 If c is not a Dog , as? produces a null . Thus, (c as? Dog) is a nullable expression and we must use the safe call operator ?. to call bark() . If as? produces a null , then the whole expression (c as? Dog)?.bark() will also produce a null , which the Elvis operator handles by producing Not a Dog . Discovering Types in Sequences When used in a predicate, is finds objects of a given type within a sequence: // DownCasting/FindType.kt package downcasting import atomictest.eq val group: List<Creature> = listOf( Human(), Human(), Dog(), Alien(), Dog() ) fun main () { val dog = group .find { it is Dog } as Dog? // [1] dog ?. bark() eq Yip! // [2] } Because group contains Creature s, find() returns a Creature . We want to treat it as a Dog , so we explicitly cast it at the end of line [1] . If there are no Dog s in group , find() returns a null , so we must cast the result to a nullable Dog? . Because dog is nullable, we use the safe call operator in line [2] . You can usually avoid the code in line [1] by using filterIsInstance() , which produces all the elements of a specific type from a collection: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Downcasting 373 // DownCasting/FilterIsInstance.kt import downcasting.* import atomictest.eq fun main () { val humans1 = group.filter { it is Human } humans1.size eq 2 val humans2 = group.filterIsInstance<Human>() humans2 eq humans1 } Here, filterIsInstance() produces the same result as filter() , but in a more readable form. We’ve also eliminated the nullability issues seen in FindType.kt . Exercises and solutions for this atom can be found at AtomicKotlin.com ⁹⁸ . ⁹⁸ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Sealed Classes To constrain a class hierarchy, declare the superclass sealed . Consider a trip taken by travelers using different modes of transportation: // SealedClasses/UnSealed.kt package withoutsealedclasses import atomictest.eq open class Transport data class Train ( val line: String ): Transport() data class Bus ( val number: String, val capacity: Int ): Transport() fun travel (transport: Transport) = when (transport) { is Train -> Train ${transport.line} is Bus -> Bus ${transport.number}:  + size ${transport.capacity} else -> $transport is in limbo! } fun main () { listOf(Train( S1 ), Bus( 11 , 90 )) .map( :: travel) eq [Train S1, Bus 11: size 90] } ","Sealed Classes 375 Train and Bus each contain different details about their Transport mode. travel() contains a when expression that discovers the exact type of the transport parameter. Kotlin requires the default else branch, because there might be other subclasses of Transport . travel() shows downcasting’s inherent trouble spot. Suppose you inherit Tram as a new type of Transport . If you do this, travel() continues to compile and run, giving you no clue that you should modify it to detect Tram . If you have many instances of downcasting scattered throughout your code, this becomes a maintenance problem. We can improve the situation using the sealed keyword. When defining Transport , replace open class with sealed class : // SealedClasses/SealedClasses.kt package sealedclasses import atomictest.eq sealed class Transport data class Train ( val line: String ) : Transport() data class Bus ( val number: String, val capacity: Int ) : Transport() fun travel (transport: Transport) = when (transport) { is Train -> Train ${transport.line} is Bus -> Bus ${transport.number}:  + size ${transport.capacity} } fun main () { listOf(Train( S1 ), Bus( 11 , 90 )) .map( :: travel) eq Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Sealed Classes 376 [Train S1, Bus 11: size 90] } All direct subclasses of a sealed class must be located in the same file as the base class. Although Kotlin forces you to exhaustively check all possible types in a when clause, the when expression in travel() no longer requires an else branch. Because Transport is sealed , Kotlin knows that no additional subclasses of Transport exist other than the ones present in this file. The when expression is now exhaustive without an else branch. sealed hierarchies discover errors when adding new subclasses. When you intro-duce a new subclass, you must update all the code that uses the existing hierarchy. The travel() function in UnSealed.kt will continue to work because the else branch produces $transport is in limbo! on unknown types of transporta-tion. However, that’s probably not the behavior you want. A sealed class tell us all the places we must modify when we add a new subclass such as Tram . The travel() function in SealedClasses.kt won’t compile if we introduce the Tram class without making additional changes. The sealed keyword makes it impossible to ignore the problem, because you get a compilation error. The sealed keyword makes downcasting more palatable, but you should still be suspicious of designs that make excessive use of downcasting. There is often a better and cleaner way to write that code using polymorphism. sealed vs. abstract Here we show that both abstract and sealed classes allow identical types of functions, properties, and constructors: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Sealed Classes 377 // SealedClasses/SealedVsAbstract.kt package sealedclasses abstract class Abstract ( val av: String) { open fun concreteFunction () {} open val concreteProperty =  abstract fun abstractFunction (): String abstract val abstractProperty: String init {} constructor (c: Char) : this (c.toString()) } open class Concrete () : Abstract(  ){ override fun concreteFunction () {} override val concreteProperty =  override fun abstractFunction () =  override val abstractProperty =  } sealed class Sealed ( val av: String) { open fun concreteFunction () {} open val concreteProperty =  abstract fun abstractFunction (): String abstract val abstractProperty: String init {} constructor (c: Char) : this (c.toString()) } open class SealedSubclass () : Sealed(  ){ override fun concreteFunction () {} override val concreteProperty =  override fun abstractFunction () =  override val abstractProperty =  } fun main () { Concrete() SealedSubclass() } A sealed class is basically an abstract class with the extra constraint that all direct subclasses must be defined in the same file. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Sealed Classes 378 Indirect subclasses of a sealed class can be defined in a different file: // SealedClasses/ThirdLevelSealed.kt package sealedclasses class ThirdLevel : SealedSubclass() Since ThirdLevel doesn’t directly inherit from Sealed , it doesn’t need to reside in SealedVsAbstract.kt . Notice that SealedSubclass is open so ThirdLevel can inherit it. Although a sealed interface seems like it would be a useful construct, Kotlin doesn’t provide it because Java classes cannot be prevented from implementing the same interface. Enumerating Subclasses When a class is sealed , you can easily iterate through its subclasses: // SealedClasses/SealedSubclasses.kt package sealedclasses import atomictest.eq sealed class Top class Middle1 : Top() class Middle2 : Top() open class Middle3 : Top() class Bottom3 : Middle3() fun main () { Top :: class .sealedSubclasses .map { it.simpleName } eq [Middle1, Middle2, Middle3] } Creating a class generates a class object for that class. You can access properties and member functions of that class object to discover information, and to create and manipulate objects of that class. ::class produces a class object, so Top::class produces the class object for Top . Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Sealed Classes 379 One of the properties of class objects is sealedSubclasses , which expects that Top is a sealed class (otherwise it produces an empty list). sealedSubclasses produces all the class objects of those subclasses. Notice that only the immediate subclasses of Top appear in the result. The toString() for a class object is slightly verbose. We produce the class name alone by using the simpleName property. Using sealedSubclasses requires that kotlin-reflection.jar be in the class-path. sealedSubclasses is an important tool when building polymorphic systems. It can ensure that new classes will automatically be included in all appropriate operations. Note, however, that it discovers the subclasses at runtime so you should avoid sealedSubclasses inside loops or anywhere it can cause a performance impact when speed is an issue. Exercises and solutions for this atom can be found at AtomicKotlin.com ⁹⁹ . ⁹⁹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Type Checking In Kotlin you can easily act on an object based on its type. Normally this activity is the domain of polymorphism, so type checking enables interesting design choices. Traditionally, type checking is used for special cases. For example, the majority of insects can fly, but there are a tiny number that cannot. It doesn’t make sense to burden the Insect interface with the few insects that are unable to fly, so in basic() we use type checking to pick those out: // TypeChecking/Insects.kt package typechecking import atomictest.eq interface Insect { fun walk () = ${this.name}: walk fun fly () = ${this.name}: fly } class HouseFly : Insect class Flea : Insect { override fun fly () = throw Exception( Flea cannot fly ) fun crawl () = Flea: crawl } fun Insect .basic() = this .walk() +  + if ( this is Flea) this .crawl() else this .fly() interface SwimmingInsect : Insect { ","Type Checking 381 fun swim () = ${this.name}: swim } interface WaterWalker : Insect { fun walkWater () = ${this.name}: walk on water } class WaterBeetle : SwimmingInsect class WaterStrider : WaterWalker class WhirligigBeetle : SwimmingInsect, WaterWalker fun Insect .water() = when ( this ){ is SwimmingInsect -> this .swim() is WaterWalker -> this .walkWater() else -> ${this.name}: drown } fun main () { val insects = listOf( HouseFly(), Flea(), WaterStrider(), WaterBeetle(), WhirligigBeetle() ) insects.map { it.basic() } eq [HouseFly: walk HouseFly: fly,  + Flea: walk Flea: crawl,  + WaterStrider: walk WaterStrider: fly,  + WaterBeetle: walk WaterBeetle: fly,  + WhirligigBeetle: walk  + WhirligigBeetle: fly] insects.map { it.water() } eq [HouseFly: drown, Flea: drown,  + WaterStrider: walk on water,  + WaterBeetle: swim,  + WhirligigBeetle: swim] } There are also a very small number of insects that can walk on water or swim underwater. Again, it doesn’t make sense to put those special-case behaviors in the base class to support such a small fraction of types. Instead, Insect.water() Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Type Checking 382 contains a when expression that selects those subtypes for special behavior and assumes standard behavior for everything else. Selecting a few isolated types for special treatment is the typical use case for type checking. Notice that adding new types to the system doesn’t impact the existing code (unless a new type also requires special treatment). To simplify the code, name produces the type of the object pointed to by the this under question: // TypeChecking/AnyName.kt package typechecking val Any.name get () = this :: class .simpleName name takes an Any and gets the associated class reference using ::class , then produces the simpleName of that class. Now consider a variation of the “shape” example: // TypeChecking/TypeCheck1.kt package typechecking import atomictest.eq interface Shape { fun draw (): String } class Circle : Shape { override fun draw () = Circle: Draw } class Square : Shape { override fun draw () = Square: Draw fun rotate () = Square: Rotate } fun turn (s: Shape) = when (s) { is Square -> s.rotate() else ->  } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Type Checking 383 fun main () { val shapes = listOf(Circle(), Square()) shapes.map { it.draw() } eq [Circle: Draw, Square: Draw] shapes.map { turn(it) } eq [, Square: Rotate] } There are several reasons why you might add rotate() to Square instead of Shape : • The Shape interface is not in your control, so you cannot modify it. • Rotating Square seems like a special case that shouldn’t burden and/or com-plicate the Shape interface. • You’re just trying to quickly solve a problem by adding Square and you don’t want to take the trouble of putting rotate() in Shape and implementing it in all the subtypes. There are certainly situations when this solution doesn’t negatively impact your design, and Kotlin’s when produces clean and straightforward code. If, however, you must evolve your system by adding more types, it begins to get messy: // TypeChecking/TypeCheck2.kt package typechecking import atomictest.eq class Triangle : Shape { override fun draw () = Triangle: Draw fun rotate () = Triangle: Rotate } fun turn2 (s: Shape) = when (s) { is Square -> s.rotate() is Triangle -> s.rotate() else ->  } fun main () { val shapes = Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Type Checking 384 listOf(Circle(), Square(), Triangle()) shapes.map { it.draw() } eq [Circle: Draw, Square: Draw,  + Triangle: Draw] shapes.map { turn(it) } eq [, Square: Rotate, ] shapes.map { turn2(it) } eq [, Square: Rotate, Triangle: Rotate] } The polymorphic call in shapes.map { it.draw() } adapts to the new Triangle class without any changes or errors. Also, the compiler will correct us if we try to write Triangle without an implementation for draw() . The original turn() doesn’t break when we add Triangle , but it also doesn’t produce the result we want. turn() must become turn2() to generate the desired behavior. Suppose your system begins to accumulate more functions like turn() . The Shape logic is now distributed across all these functions, rather than being centralized within the Shape hierarchy. If you add more new types of Shape , you must find by inspection every function containing a when that switches on a Shape type, and modify it to include the new case. If you miss any of these functions, the compiler doesn’t catch it. turn() and turn2() exhibit what is often called type-check coding : Testing for every type in your system. (If you are only looking for one or a few special types it is not usually considered type-check coding). In traditional object-oriented languages, type-check coding is usually considered an antipattern because it invites the creation of one or more pieces of code that must be vigilantly maintained and updated whenever you add or change types in your system. Polymorphism, on the other hand, encapsulates those changes into the types that you add or modify, and those changes are then transparently propagated through your system. Note that the problem only occurs when the system needs to evolve by adding more Shape types. If that’s not how your system evolves, you won’t encounter the issue. Even if it is a problem, it’s usually not sudden, but something that becomes steadily more difficult as you continue evolving your system. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Type Checking 385 We shall see that Kotlin significantly mitigates this problem through the use of sealed classes. The solution isn’t perfect, but it’s an important enough improvement that it becomes a much more reasonable design choice. Type Checking in Auxiliary Functions The essence of a BeverageContainer is that it holds and delivers beverages. It seems to make sense to treat recycling as an auxiliary function: // TypeChecking/BeverageContainer.kt package typechecking import atomictest.eq interface BeverageContainer { fun open (): String fun pour (): String } class Can : BeverageContainer { override fun open () = Pop Top override fun pour () = Can: Pour } open class Bottle : BeverageContainer { override fun open () = Remove Cap override fun pour () = Bottle: Pour } class GlassBottle : Bottle() class PlasticBottle : Bottle() fun BeverageContainer .recycle() = when ( this ){ is Can -> Recycle Can is GlassBottle -> Recycle Glass else -> Landfill } fun main () { val refrigerator = listOf( Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Type Checking 386 Can(), GlassBottle(), PlasticBottle() ) refrigerator.map { it. open () } eq [Pop Top, Remove Cap, Remove Cap] refrigerator.map { it.recycle() } eq [Recycle Can, Recycle Glass,  + Landfill] } By defining recycle() as an auxiliary function it captures the different recycling behaviors in a single place, rather than having them distributed throughout the BeverageContainer hierarchy by making recycle() a member function. Acting on types with when is clean and straightforward, but the design is still problematic. When you add a new type, recycle() quietly defaults to using the else clause. Because of this, necessary changes to type-checking functions like recycle() might be missed. What we’d like is for the compiler to tell us that we’ve forgotten a type check, just as it does when we add a subclass and it tells us we’ve forgotten to override a function. sealed classes provide a significant improvement here. Making Shape a sealed class means that the when in turn() (after removing the else ) requires that each type be checked. (Because interfaces cannot be sealed , we must rewrite Shape into a class): // TypeChecking/TypeCheck3.kt package typechecking3 import atomictest.eq import typechecking.name sealed class Shape { fun draw () = ${this.name}: Draw } class Circle : Shape() class Square : Shape() { fun rotate () = Square: Rotate } class Triangle : Shape() { Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Type Checking 387 fun rotate () = Triangle: Rotate } fun turn (s: Shape) = when (s) { is Circle ->  is Square -> s.rotate() is Triangle -> s.rotate() } fun main () { val shapes = listOf(Circle(), Square()) shapes.map { it.draw() } eq [Circle: Draw, Square: Draw] shapes.map { turn(it) } eq [, Square: Rotate] } If we add a new Shape , the compiler tells us to add a new type-check path in turn() —just as it does if we forget to override a function in a new subclass of an interface or abstract class. But let’s look at what happens when we try to apply sealed to the BeverageCon-tainer problem. In the process, we create additional Can and Bottle subtypes: // TypeChecking/BeverageContainer2.kt package typechecking2 import atomictest.eq sealed class BeverageContainer { abstract fun open (): String abstract fun pour (): String } sealed class Can : BeverageContainer() { override fun open () = Pop Top override fun pour () = Can: Pour } class SteelCan : Can() class AluminumCan : Can() sealed class Bottle : BeverageContainer() { Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Type Checking 388 override fun open () = Remove Cap override fun pour () = Bottle: Pour } class GlassBottle : Bottle() sealed class PlasticBottle : Bottle() class PETBottle : PlasticBottle() class HDPEBottle : PlasticBottle() fun BeverageContainer .recycle() = when ( this ){ is Can -> Recycle Can is Bottle -> Recycle Bottle } fun BeverageContainer .recycle2() = when ( this ){ is Can -> when ( this ){ is SteelCan -> Recycle Steel is AluminumCan -> Recycle Aluminum } is Bottle -> when ( this ){ is GlassBottle -> Recycle Glass is PlasticBottle -> when ( this ){ is PETBottle -> Recycle PET is HDPEBottle -> Recycle HDPE } } } fun main () { val refrigerator = listOf( SteelCan(), AluminumCan(), GlassBottle(), PETBottle(), HDPEBottle() ) refrigerator.map { it. open () } eq [Pop Top, Pop Top, Remove Cap,  + Remove Cap, Remove Cap] refrigerator.map { it.recycle() } eq [Recycle Can, Recycle Can,  + Recycle Bottle, Recycle Bottle,  + Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Type Checking 389 Recycle Bottle] refrigerator.map { it.recycle2() } eq [Recycle Steel, Recycle Aluminum,  + Recycle Glass,  + Recycle PET, Recycle HDPE] } Note that the intermediate classes Can and Bottle must also be sealed in order for this approach to work. As long as the classes are direct subclasses of BeverageContainer , the compiler guarantees that the when in recycle() is exhaustive. But subclasses like Glass-Bottle and AluminumCan are not checked. To solve the problem we must explicitly include the nested when expressions seen in recycle2() , at which point the compiler does require exhaustive type checks (try commenting one of the specific Can or Bottle types to verify this). Thus, it is possible to create a robust type-checking solution as long as we rigorously use sealed at each intermediate level of the class hierarchy, while ensuring that each level of subclasses has a corresponding nested when . In this case, if you add a new subtype of Can or Bottle the compiler ensures that recycle2() tests for each subtype. Although not as clean as polymorphism, this is a significant improvement over prior object-oriented languages, and allows you to choose whether to write a polymorphic member function or auxiliary function. For comparison, let’s rewrite BeverageContainer2.kt by bringing recycle() into BeverageContainer , which can again be an interface : // TypeChecking/BeverageContainer3.kt package typechecking3 import atomictest.eq import typechecking.name interface BeverageContainer { fun open (): String fun pour () = ${this.name}: Pour fun recycle (): String } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Type Checking 390 abstract class Can : BeverageContainer { override fun open () = Pop Top } class SteelCan : Can() { override fun recycle () = Recycle Steel } class AluminumCan : Can() { override fun recycle () = Recycle Aluminum } abstract class Bottle : BeverageContainer { override fun open () = Remove Cap } class GlassBottle : Bottle() { override fun recycle () = Recycle Glass } abstract class PlasticBottle : Bottle() class PETBottle : PlasticBottle() { override fun recycle () = Recycle PET } class HDPEBottle : PlasticBottle() { override fun recycle () = Recycle HDPE } fun main () { val refrigerator = listOf( SteelCan(), AluminumCan(), GlassBottle(), PETBottle(), HDPEBottle() ) refrigerator.map { it. open () } eq [Pop Top, Pop Top, Remove Cap,  + Remove Cap, Remove Cap] refrigerator.map { it.recycle() } eq [Recycle Steel, Recycle Aluminum,  + Recycle Glass,  + Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Type Checking 391 Recycle PET, Recycle HDPE] } Now the behavior of recycle() is distributed among the classes, which might be fine—it’s a design decision. If you decide that recycling behavior changes often and you’d like to have it all in one place, then using the auxiliary type-checked recycle2() from BeverageContainer2.kt might be a better choice for your needs, and Kotlin’s features make that a reasonable choice. By making Can and Bottle abstract classes, we can force their subclasses to override recycle() in the same way that the compiler forces each type to be checked inside recycle2() in BeverageContainer2.kt . Exercises and solutions for this atom can be found at AtomicKotlin.com ¹⁰⁰ . ¹⁰⁰ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Nested Classes Nested classes enable more refined structures within your objects. A nested class is simply a class within the namespace of the outer class. The implication is that the outer class “owns” the nested class. This feature is not essential, but nesting a class can clarify your code. Here, Plane is nested within Airport : // NestedClasses/Airport.kt package nestedclasses import atomictest.eq import nestedclasses.Airport.Plane class Airport ( private val code: String) { open class Plane { // Can access private properties: fun contact (airport: Airport) = Contacting ${airport.code} } private class PrivatePlane : Plane() fun privatePlane (): Plane = PrivatePlane() } fun main () { val denver = Airport( DEN ) var plane = Plane() // [1] plane.contact(denver) eq Contacting DEN // Can't do this: // val privatePlane = Airport.PrivatePlane() val frankfurt = Airport( FRA ) plane = frankfurt.privatePlane() // Can't do this: // val p = plane as PrivatePlane // [2] plane.contact(frankfurt) eq Contacting FRA } ","Nested Classes 393 In contact() , the nested class Plane has access to the private property code in the airport argument, whereas an ordinary class would not have this access. Other than that, Plane is simply a class inside the Airport namespace. Creating a Plane object does not require an Airport object, but if you create it outside the Airport class body, you must ordinarily qualify the constructor call in [1] . By importing nestedclasses.Airport.Plane we avoid this qualification. A nested class can be private , as with PrivatePlane . Making it private means that PrivatePlane is completely invisible outside the body of Airport , so you cannot call the PrivatePlane constructor outside of Airport . If you define and return a PrivatePlane from a member function, as seen in privatePlane() , the result must be upcast to a public type (assuming it extends a public type), and cannot be downcast to the private type, as seen in [2] . Here’s an example of nesting where Cleanable is a base class for both the enclosing class House and all the nested classes. clean() goes through a List of parts and calls clean() for each one, producing a kind of recursion: // NestedClasses/NestedHouse.kt package nestedclasses import atomictest.* abstract class Cleanable ( val id: String) { open val parts: List<Cleanable> = listOf() fun clean (): String { val text = $id clean if (parts.isEmpty()) return text return ${parts.joinToString(  , ( , ) , transform = Cleanable :: clean)} $ text  n  } } class House : Cleanable( House ){ override val parts = listOf( Bedroom( Master Bedroom ), Bedroom( Guest Bedroom ) ) class Bedroom (id: String) : Cleanable(id) { override val parts = Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Nested Classes 394 listOf(Closet(), Bathroom()) class Closet : Cleanable( Closet ){ override val parts = listOf(Shelf(), Shelf()) class Shelf : Cleanable( Shelf ) } class Bathroom : Cleanable( Bathroom ){ override val parts = listOf(Toilet(), Sink()) class Toilet : Cleanable( Toilet ) class Sink : Cleanable( Sink ) } } } fun main () { House().clean().trim() eq  (((Shelf clean Shelf clean) Closet clean (Toilet clean Sink clean) Bathroom clean ) Master Bedroom clean ((Shelf clean Shelf clean) Closet clean (Toilet clean Sink clean) Bathroom clean ) Guest Bedroom clean ) House clean  } Notice the multiple levels of nesting. For example, Bedroom contains Bathroom which contains Toilet and Sink . Local Classes Classes that are nested inside functions are called local classes: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Nested Classes 395 // NestedClasses/LocalClasses.kt package nestedclasses fun localClasses () { open class Amphibian class Frog : Amphibian() val amphibian: Amphibian = Frog() } Amphibian looks like a candidate to be an interface rather than an open class . However, local interfaces are not allowed. Local open classes should be rare; if you need one, what you’re trying to make is probably significant enough to create a regular class. Amphibian and Frog are invisible outside localClasses() , so you can’t return them from the function. To return objects of local classes, you must upcast them to a class or interface defined outside the function: // NestedClasses/ReturnLocal.kt package nestedclasses interface Amphibian fun createAmphibian (): Amphibian { class Frog : Amphibian return Frog() } fun main () { val amphibian = createAmphibian() // amphibian as Frog } Frog is still invisible outside createAmphibian() —in main() , you cannot cast amphibian to a Frog because Frog isn’t available, so Kotlin reports the attempt to use Frog as an “unresolved reference.” Classes Inside Interfaces Classes can be nested within interfaces: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Nested Classes 396 // NestedClasses/WithinInterface.kt package nestedclasses import atomictest.eq interface Item { val type: Type data class Type ( val type: String) } class Bolt (type: String) : Item { override val type = Item.Type(type) } fun main () { val items = listOf( Bolt( Slotted ), Bolt( Hex ) ) items.map(Item :: type) eq [Type(type=Slotted), Type(type=Hex)] } In Bolt , the val type must be overridden and assigned using the qualified class name Item.Type . Nested Enumerations Enumerations are classes, so they can be nested inside other classes: // NestedClasses/Ticket.kt package nestedclasses import atomictest.eq import nestedclasses.Ticket.Seat.* class Ticket ( val name: String, val seat: Seat = Coach ){ enum class Seat { Coach, Premium, Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Nested Classes 397 Business, First } fun upgrade (): Ticket { val newSeat = values()[ (seat.ordinal + 1 ) .coerceAtMost(First.ordinal) ] return Ticket(name, newSeat) } fun meal () = when (seat) { Coach -> Bag Meal Premium -> Bag Meal with Cookie Business -> Hot Meal First -> Private Chef } override fun toString () = $seat } fun main () { val tickets = listOf( Ticket( Jerry ), Ticket( Summer , Premium), Ticket( Squanchy , Business), Ticket( Beth , First) ) tickets.map(Ticket :: meal) eq [Bag Meal, Bag Meal with Cookie,  + Hot Meal, Private Chef] tickets.map(Ticket :: upgrade) eq [Premium, Business, First, First] tickets eq [Coach, Premium, Business, First] tickets.map(Ticket :: meal) eq [Bag Meal, Bag Meal with Cookie,  + Hot Meal, Private Chef] } upgrade() adds one to the ordinal value of the seat , then uses the library function coerceAtMost() to ensure the new value does not exceed First.ordinal before indexing into values() to produce the new Seat type. Following functional programming principles, upgrading a Ticket produces a new Ticket rather than Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Nested Classes 398 modifying the old one. meal() uses when to test every type of Seat and this suggests we could use polymorphism instead. Enumerations cannot be nested within functions, and cannot inherit from other classes (including other enumerations). Interfaces can contain nested enumerations. FillIt is a game-like simulation that fills a square grid with randomly-chosen X and O marks: // NestedClasses/FillIt.kt package nestedclasses import nestedclasses.Game.State.* import nestedclasses.Game.Mark.* import kotlin.random.Random import atomictest.* interface Game { enum class State { Playing, Finished } enum class Mark { Blank, X ,O } } class FillIt ( val side: Int = 3 , randomSeed: Int = 0 ): Game { val rand = Random(randomSeed) private var state = Playing private val grid = MutableList(side * side) { Blank } private var player = X fun turn () { val blanks = grid.withIndex() .filter { it.value == Blank } if (blanks.isEmpty()) { state = Finished } else { grid[blanks.random(rand).index] = player player = if (player == X) O else X } } fun play () { while (state != Finished) Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Nested Classes 399 turn() } override fun toString () = grid.chunked(side).joinToString( n ) } fun main () { val game = FillIt( 8 , 17 ) game.play() game eq  [O, X, O, X, O, X, X, X] [X, O, O, O, O, O, X, X] [O, O, X, O, O, O, X, X] [X, O, O, O, O, O, X, O] [X, X, O, O, X, X, X, O] [X, X, O, O, X, X, O, X] [O, X, X, O, O, O, X, O] [X, O, X, X, X, O, X, X]  } For testability, we seed a Random object with randomSeed to produce identical output each time the program runs. Each element of grid is initialized with Blank . In turn() , we first find all the cells containing Blank , along with their indices. If there are no more Blank cells then the simulation is complete. Otherwise, we use random() with our seeded generator to select one of the Blank cells. Because we used withIndex() earlier, we must select the index property to produce the location of the cell we want to change. To display the List in the form of a two-dimensional grid, toString() uses the chunked() library function to break the List into pieces, each of length side , then joins these together with newlines. Try experimenting with FillIt using different side s and randomSeed s. Exercises and solutions for this atom can be found at AtomicKotlin.com ¹⁰¹ . ¹⁰¹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Objects The object keyword defines something that looks roughly like a class. However, you can’t create instances of an object —there’s only one. This is sometimes called the Singleton pattern. An object is a way to combine functions and properties that logically belong together, but this combination doesn’t require multiple instances. Thus, you never create any instances of an object —there’s only one and it’s available once the object has been defined: // Objects/ObjectKeyword.kt package objects import atomictest.eq object JustOne { val n= 2 fun f ()=n* 10 fun g () = this .n * 20 // [1] } fun main () { // val x = JustOne() // Error JustOne.n eq 2 JustOne.f() eq 20 JustOne.g() eq 40 } Here, you can’t say JustOne() to create a new instance of a class JustOne . That’s because the object keyword defines the structure and creates the object at the same time. In addition, it places the elements inside the object ’s namespace. If you only want the object to be visible within the current file, you can make it private . You cannot provide an argument list for an object . Naming conventions are slightly different when using object . Typically, when we create an instance of a class, we lower-case the first letter of the instance name. ","Objects 401 When you create an object , however, Kotlin defines the class and creates a single instance of that class. We capitalize the first letter of the object name because it also represents a class. • [1] The this keyword refers to the single object instance. An object can inherit from a regular class or interface: // Objects/ObjectInheritance.kt package objects import atomictest.eq open class Paint ( val color: String) { open fun apply () = Applying $color } object Acrylic : Paint( Blue ){ override fun apply () = Acrylic, ${super.apply()} } interface PaintPreparation { fun prepare (): String } object Prepare : PaintPreparation { override fun prepare () = Scrape } fun main () { Prepare.prepare() eq Scrape Paint( Green ).apply() eq Applying Green Acrylic.apply() eq Acrylic, Applying Blue } There’s only a single instance of an object , so that instance is shared across all code that uses it. Here’s an object in its own package : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Objects 402 // Objects/GlobalSharing.kt package objectsharing object Shared { var i: Int = 0 } We can now use Shared in a different package: // Objects/Share1.kt package objectshare1 import objectsharing.Shared fun f () { Shared.i += 5 } And within a third package: // Objects/Share2.kt package objectshare2 import objectsharing.Shared import objectshare1.f import atomictest.eq fun g () { Shared.i += 7 } fun main () { f() g() Shared.i eq 12 } You can see from the results that Shared is the same object in all the packages, which makes sense because object creates a single instance. If you make Shared private , you’ll see that it’s not available in the other files. object s can’t be placed inside functions, but they can be nested inside other object s or classes (as long as those classes are not themselves nested within other classes): Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Objects 403 // Objects/ObjectNesting.kt package objects import atomictest.eq object Outer { object Nested { val a= Outer.Nested.a } } class HasObject { object Nested { val a= HasObject.Nested.a } } fun main () { Outer.Nested.a eq Outer.Nested.a HasObject.Nested.a eq HasObject.Nested.a } There’s another way to put an object inside a class: a companion object , which you’ll see in the Companion Objects atom. Exercises and solutions for this atom can be found at AtomicKotlin.com ¹⁰² . ¹⁰² https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inner Classes Inner classes are like nested classes, but an object of an inner class maintains a reference to the outer class. An inner class has an implicit link to the outer class. In the following example, Hotel is like Airport from Nested Classes , but it uses inner classes instead of nested classes. Note that reception is part of Hotel , but callReception() , which is a member of the nested class Room , accesses it without qualification: // InnerClasses/Hotel.kt package innerclasses import atomictest.eq class Hotel ( private val reception: String) { open inner class Room ( val id: Int = 0 ){ // Uses 'reception' from outer class: fun callReception () = Room $id Calling $reception } private inner class Closet : Room() fun closet (): Room = Closet() } fun main () { val nycHotel = Hotel( 311 ) // You need an outer object to // create an instance of the inner class: val room = nycHotel.Room( 319 ) room.callReception() eq Room 319 Calling 311 val sfHotel = Hotel( 0 ) val closet = sfHotel.closet() closet.callReception() eq Room 0 Calling 0 } ","Inner Classes 405 Because Closet inherits the inner class Room , Closet must also be an inner class. Nested classes cannot inherit from inner classes. Closet is private , so it is only visible within the scope of Hotel . An inner object keeps a reference to its associated outer object. Thus, when creating an inner object you must first have an outer object. You cannot create a Room object without a Hotel object, as you see with nycHotel.Room() . inner data classes are not allowed. Qualified this One of the benefits of classes is the this reference. You don’t have to explicitly say “the current object” when you access a property or member function. With a simple class, the meaning of this is obvious, but when we have inner classes, this could refer to either the inner object or an outer object. To resolve this issue, Kotlin provides the qualified this syntax: this followed by @ and the name of the target class. Consider three levels of classes: an outer class Fruit containing an inner class Seed , which itself contains an inner class DNA : // InnerClasses/QualifiedThis.kt package innerclasses import atomictest.eq import typechecking.name class Fruit { // implicit label @Fruit fun changeColor (color: String) = Fruit $color fun absorbWater (amount: Int) {} inner class Seed { // implicit label @Seed fun changeColor (color: String) = Seed $color fun germinate () {} fun whichThis () { // Defaults to the current class: this .name eq Seed Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inner Classes 406 // To clarify, you can redundantly // qualify the default this: this @Seed.name eq Seed // Must explicitly access Fruit: this @Fruit.name eq Fruit // Cannot access a further-inner class: // this@DNA.name } inner class DNA { // implicit label @DNA fun changeColor (color: String) { // changeColor(color) // Recursive this @Seed.changeColor(color) this @Fruit.changeColor(color) } fun plant () { // Call outer-class functions // Without qualification: germinate() absorbWater( 10 ) } // Extension function: fun Int .grow() { // Implicit label @grow // Default is the Int.grow() receiver: this .name eq Int // Redundant qualification: this @grow.name eq Int // You can still access everything: this @DNA.name eq DNA this @Seed.name eq Seed this @Fruit.name eq Fruit } // Extension functions on outer classes: fun Seed .plant() {} fun Fruit .plant() {} fun whichThis () { // Defaults to the current class: this .name eq DNA // Redundant qualification: this @DNA.name eq DNA // The others must be explicit: this @Seed.name eq Seed this @Fruit.name eq Fruit Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inner Classes 407 } } } } // Extension function: fun Fruit .grow(amount: Int) { absorbWater(amount) // Calls Fruit's version of changeColor(): changeColor( Red ) eq Fruit Red } // Inner-class extension function: fun Fruit .Seed.grow(n: Int) { germinate() // Calls Seed's version of changeColor(): changeColor( Green ) eq Seed Green } // Inner-class extension function: fun Fruit .Seed.DNA.grow(n: Int) = n.grow() fun main () { val fruit = Fruit() fruit.grow( 4 ) val seed = fruit.Seed() seed.grow( 9 ) seed.whichThis() val dna = seed.DNA() dna.plant() dna.grow( 5 ) dna.whichThis() dna.changeColor( Purple ) } Fruit , Seed and DNA all have functions called changeColor() , but there’s no overriding—this is not an inheritance relationship. Because they have the same name and signature, the only way to distinguish them is with a qualified this , as you see in DNA ’s changeColor() . Inside plant() , functions in either of the two outer classes can be called without qualification if there are no name collisions. Even though it’s an extension function, grow() can still access all the objects in the Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inner Classes 408 outer class. grow() can be called anywhere the Fruit.Seed.DNA implicit receiver is available; for example, inside an extension function for DNA . Inner Class Inheritance An inner class can inherit another inner class from a different outer class. Here, Yolk in BigEgg is derived from Yolk in Egg : // InnerClasses/InnerClassInheritance.kt package innerclasses import atomictest.* open class Egg { private var yolk = Yolk() open inner class Yolk { init { trace( Egg.Yolk() )} open fun f () { trace( Egg.Yolk.f() )} } init { trace( New Egg() )} fun insertYolk (y: Yolk) { yolk = y } fun g () { yolk.f() } } class BigEgg : Egg() { inner class Yolk : Egg.Yolk() { init { trace( BigEgg.Yolk() )} override fun f () { trace( BigEgg.Yolk.f() ) } } init { insertYolk(Yolk()) } } fun main () { BigEgg().g() trace eq  Egg.Yolk() New Egg() Egg.Yolk() BigEgg.Yolk() Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inner Classes 409 BigEgg.Yolk.f()  } BigEgg.Yolk explicitly names Egg.Yolk as its base class, and overrides its f() member function. The function insertYolk() allows BigEgg to upcast one of its own Yolk objects into the yolk reference in Egg , so when g() calls yolk.f() , the overridden version of f() is used. The second call to Egg.Yolk() is the base-class constructor call of the BigEgg.Yolk constructor. You can see that the overridden version of f() is used when g() is called. As a review of object construction, study the trace output until it makes sense to you. Local & Anonymous Inner Classes Classes defined inside member functions are called local inner classes . These can also be created anonymously, using an object expression , or using a SAM conversion . In all cases, the inner keyword is not used, but is implied: // InnerClasses/LocalInnerClasses.kt package innerclasses import atomictest.eq fun interface Pet { fun speak (): String } class PetCreator { fun home () =  home! fun dog (): Pet { val say = Bark // Local inner class: class Dog : Pet { override fun speak () = say + home() } return Dog() } fun cat (): Pet { Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inner Classes 410 val emit = Meow // Anonymous inner class: return object : Pet { override fun speak () = emit + home() } } fun hamster (): Pet { val squeak = Squeak // SAM conversion: return Pet { squeak + home() } } } fun main () { val create = PetCreator() create.dog().speak() eq Bark home! create.cat().speak() eq Meow home! create.hamster().speak() eq Squeak home! } A local inner class has access to other elements in the function as well as elements in the outer-class object, thus say , emit , squeak and home() are available within speak() . You can identify an anonymous inner class because it uses an object expression, which you see in cat() . It returns an object of a class inherited from Pet that overrides speak() . Anonymous inner classes are smaller and more straightforward and do not create a named class that will only be used in one place. Even more compact is a SAM conversion , as seen in hamster() . Because inner classes keep a reference to the outer-class object, local inner classes can access all members of the enclosing class: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inner Classes 411 // InnerClasses/CounterFactory.kt package innerclasses import atomictest.* fun interface Counter { fun next (): Int } class CounterFactory { private var count = 0 fun new (name: String): Counter { // Local inner class: class Local : Counter { init { trace( Local() )} override fun next (): Int { // Access local identifiers: trace( $name $count ) return count++ } } return Local() } fun new2 (name: String): Counter { // Instance of an anonymous inner class: return object : Counter { init { trace( Counter() )} override fun next (): Int { trace( $name $count ) return count++ } } } fun new3 (name: String): Counter { trace( Counter() ) return Counter { // SAM conversion trace( $name $count ) count++ } } } fun main () { Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Inner Classes 412 fun test (counter: Counter) { ( 0. . 3 ).forEach { counter.next() } } val cf = CounterFactory() test(cf.new( Local )) test(cf.new2( Anon )) test(cf.new3( SAM )) trace eq  Local() Local 0 Local 1 Local 2 Local 3 Counter() Anon 4 Anon 5 Anon 6 Anon 7 Counter() SAM 8 SAM 9 SAM 10 SAM 11  } A Counter keeps track of a count and returns the next Int value. new() , new2() and new3() each create a different implementation of the Counter interface. new() returns an instance of a named inner class, new2() returns an instance of an anonymous inner class, and new3() uses a SAM conversion to create an anonymous object. All the resulting Counter objects have implicit access to the elements of the outer object, thus they are inner classes and not just nested classes. You can see from the output that count in CounterFactory is shared by all Counter objects. SAM conversions are limited—for example, they do not support init clauses. In Kotlin, files can contain multiple top-level classes and functions. Because of this, there’s rarely a need for local classes, so if you do need them they should be basic and straightforward. For example, it’s reasonable to create a simple data class that’s only used inside a function. If a local class becomes complex, you should probably take it out of the function and make it a regular class. Exercises and solutions for this atom can be found at AtomicKotlin.com ¹⁰³ . ¹⁰³ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Companion Objects Member functions act on particular instances of a class. Some functions aren’t “about” an object, so they don’t need to be tied to that object. Functions and fields inside companion object s are about the class. Regular class elements can access the elements of the companion object, but the companion object elements cannot access the regular class elements. As you saw in Objects , it’s possible to define a regular object inside a class, but that doesn’t provide an association between the object and the class. In particular, you’re forced to explicitly name the nested object when you refer to its members. If you define a companion object inside a class, its elements become transparently available to that class: // CompanionObjects/CompanionObject.kt package companionobjects import atomictest.eq class WithCompanion { companion object { val i= 3 fun f ()=i* 3 } fun g () = i + f() } fun WithCompanion .Companion.h() = f() * i fun main () { val wc = WithCompanion() wc.g() eq 12 WithCompanion.i eq 3 WithCompanion.f() eq 9 WithCompanion.h() eq 27 } ","Companion Objects 414 Outside the class, you access members of the companion object using the class name, as in WithCompanion.i and WithCompanion.f() . Other members of the class can access the companion object elements without qualification, as you see in the definition of g() . h() is an extension function to the companion object. If a function doesn’t require access to private class members, you can simply define it at file scope rather than putting it in a companion object. Only one companion object is allowed per class. For clarity, you can give the companion object a name: // CompanionObjects/NamingCompanionObjects.kt package companionobjects import atomictest.eq class WithNamed { companion object Named { fun s () = from Named } } class WithDefault { companion object { fun s () = from Default } } fun main () { WithNamed.s() eq from Named WithNamed.Named.s() eq from Named WithDefault.s() eq from Default // The default name is Companion: WithDefault.Companion.s() eq from Default } Even when you name the companion object you can still access its elements without using the name. If you don’t give the companion object a name, Kotlin assigns it the name Companion . If you create a property inside a companion object, it produces a single piece of storage for that field, shared with all instances of the associated class: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Companion Objects 415 // CompanionObjects/ObjectProperty.kt package companionobjects import atomictest.eq class WithObjectProperty { companion object { private var n: Int = 0 // Only one } fun increment () = ++n } fun main () { val a = WithObjectProperty() val b = WithObjectProperty() a.increment() eq 1 b.increment() eq 2 a.increment() eq 3 } The tests in main() show that n has only a single piece of storage, no matter how many instances of WithObjectProperty are created. a and b both access the same memory for n . increment() shows that you can access private members of the companion object from its surrounding class. When a function is only accessing properties in the companion object, it makes sense to move that function inside the companion object: // CompanionObjects/ObjectFunctions.kt package companionobjects import atomictest.eq class CompanionObjectFunction { companion object { private var n: Int = 0 fun increment () = ++n } } fun main () { CompanionObjectFunction.increment() eq 1 Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Companion Objects 416 CompanionObjectFunction.increment() eq 2 } You no longer need a CompanionObjectFunction instance to call increment() . Suppose you’d like to keep a count of every object you create, to give each one a unique readable identifier: // CompanionObjects/ObjectCounter.kt package companionobjects import atomictest.eq class Counted { companion object { private var count = 0 } private val id = count++ override fun toString () = #$id } fun main () { List( 4 ) { Counted() } eq [#0, #1, #2, #3] } A companion object can be an instance of a class defined elsewhere: // CompanionObjects/CompanionInstance.kt package companionobjects import atomictest.* interface ZI { fun f (): String fun g (): String } open class ZIOpen : ZI { override fun f () = ZIOpen.f() override fun g () = ZIOpen.g() } class ZICompanion { companion object : ZIOpen() Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Companion Objects 417 fun u () = trace( ${f()} ${g()} ) } class ZICompanionInheritance { companion object : ZIOpen() { override fun g () = ZICompanionInheritance.g() fun h () = ZICompanionInheritance.h() } fun u () = trace( ${f()} ${g()} ${h()} ) } class ZIClass { companion object : ZI { override fun f () = ZIClass.f() override fun g () = ZIClass.g() } fun u () = trace( ${f()} ${g()} ) } fun main () { ZIClass.f() ZIClass.g() ZIClass().u() ZICompanion.f() ZICompanion.g() ZICompanion().u() ZICompanionInheritance.f() ZICompanionInheritance.g() ZICompanionInheritance().u() trace eq  ZIClass.f() ZIClass.g() ZIOpen.f() ZIOpen.g() ZIOpen.f() ZICompanionInheritance.g() ZICompanionInheritance.h()  } ZICompanion uses a ZIOpen object as its companion object, and ZICompanion-Inheritance creates a ZIOpen object while overriding and extending the class. ZIClass shows that you can implement an interface while creating the companion Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Companion Objects 418 object. If the class you want to use as a companion object is not open , you cannot use it directly as we did above. However, if that class implements an interface you can still use it via delegation: // CompanionObjects/CompanionDelegation.kt package companionobjects import atomictest.* class ZIClosed : ZI { override fun f () = ZIClosed.f() override fun g () = ZIClosed.g() } class ZIDelegation { companion object : ZI by ZIClosed() fun u () = trace( ${f()} ${g()} ) } class ZIDelegationInheritance { companion object : ZI by ZIClosed() { override fun g () = ZIDelegationInheritance.g() fun h () = ZIDelegationInheritance.h() } fun u () = trace( ${f()} ${g()} ${h()} ) } fun main () { ZIDelegation.f() ZIDelegation.g() ZIDelegation().u() ZIDelegationInheritance.f() ZIDelegationInheritance.g() ZIDelegationInheritance().u() trace eq  ZIClosed.f() ZIClosed.g() ZIClosed.f() ZIDelegationInheritance.g() ZIDelegationInheritance.h() Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Companion Objects 419  } ZIDelegationInheritance shows that you can take the non-open class ZIClosed , delegate it, then override and extend that delegate . Delegation forwards the methods of an interface to the instance that provides an implementation. Even if the class of that instance is final , we can still override and add methods to the delegation receiver. Here’s a small brain-teaser: // CompanionObjects/DelegateAndExtend.kt package companionobjects import atomictest.eq interface Extended : ZI { fun u (): String } class Extend : ZI by Companion, Extended { companion object : ZI { override fun f () = Extend.f() override fun g () = Extend.g() } override fun u () = ${f()} ${g()} } private fun test (e: Extended): String { e.f() e.g() return e.u() } fun main () { test(Extend()) eq Extend.f() Extend.g() } In Extend , the ZI interface is implemented using its own companion object , which has the default name Companion . But we are also implementing the Extended interface, which is the ZI interface plus an extra function u() . The ZI portion of Extended is already implemented, via Companion , so we only need to override the Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Companion Objects 420 additional function u() to complete Extend . Now an Extend object can be upcast to Extended as the argument to test() . A common use for a companion object is controlling object creation—this is the Factory Method pattern. Suppose you’d like to only allow the creation of List s of Numbered2 objects, and not individual Numbered2 objects: // CompanionObjects/CompanionFactory.kt package companionobjects import atomictest.eq class Numbered2 private constructor ( private val id: Int) { override fun toString (): String = #$id companion object Factory { fun create (size: Int) = List(size) { Numbered2(it) } } } fun main () { Numbered2.create( 0 ) eq [] Numbered2.create( 5 ) eq [#0, #1, #2, #3, #4] } The Numbered2 constructor is private . This means there’s only one way to create an instance—via the create() factory function. A factory function can sometimes solve problems that regular constructors cannot. Constructors in companion objects are initialized when the enclosing class is instantiated for the first time in a program: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Companion Objects 421 // CompanionObjects/Initialization.kt package companionobjects import atomictest.* class CompanionInit { companion object { init { trace( Companion Constructor ) } } } fun main () { trace( Before ) CompanionInit() trace( After 1 ) CompanionInit() trace( After 2 ) CompanionInit() trace( After 3 ) trace eq  Before Companion Constructor After 1 After 2 After 3  } You can see from the output that the companion object is constructed only once, the first time a CompanionInit() object is created. Exercises and solutions for this atom can be found at AtomicKotlin.com ¹⁰⁴ . ¹⁰⁴ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Section VI: Preventing Failure If debugging is the process of removing software bugs, then programming must be the process of putting them in. — Edsger Dijkstra ","Exception Handling Errors are inevitable. Kotlin finds basic errors when it analyzes your program. Errors that cannot be detected at compile time must be handled at run time. In Exceptions , you learned to throw exceptions. In this atom, we catch exceptions. Historically, failures were often disastrous. For example, programs written in the C language would simply stop working, lose their data, and potentially crash the operating system. Improved error handling is a powerful way to increase code reliability. Error handling is especially important when creating reusable program components. To create a robust system, each component must be robust. With consistent error handling, components can reliably communicate problems to client code. Modern applications often use concurrency, and a concurrent program must survive non-critical exceptions. A server, for example, should recover when an open session is terminated via an exception. Exceptions conflate three activities: 1. Error reporting 2. Recovery 3. Resource cleanup Let’s consider each one. Reporting Standard library exceptions are often adequate. For more specific exception handling, you can inherit new exception types from Exception or a subtype: ","Exception Handling 424 // ExceptionHandling/DefiningExceptions.kt package exceptionhandling import atomictest.* class Exception1 ( val value: Int ): Exception( wrong value: $value ) open class Exception2 ( message: String ): Exception(message) class Exception3 ( message: String ): Exception2(message) fun main () { capture { throw Exception1( 13 ) } eq Exception1: wrong value: 13 capture { throw Exception3( error ) } eq Exception3: error } A throw expression, as in main() , requires an instance of a Throwable subtype. To define new exception types, inherit Exception (which extends Throwable ). Both Exception1 and Exception2 inherit Exception , while Exception3 inherits Exception2 . Recovery The ambition of exception handling is recovery. This means that you fix the problem, return the program to a stable state, and resume execution. Recovery often includes Logging information about the error. Quite often, recovery isn’t possible. An exception might represent an unrecoverable program failure, either a coding error or something uncontrollable in the environ-ment. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Exception Handling 425 When an exception is thrown, the exception-handling mechanism looks for an appropriate place to continue execution. An exception keeps moving out to higher levels, from a current function1() , to function2() that calls function1() , to function3() that calls function2() , and so on until reaching main() . A matching handler catches the exception. This stops the search and runs that handler. If the program never finds a matching handler, it terminates with a console stack trace: // ExceptionHandling/Stacktrace.kt package stacktrace import exceptionhandling.Exception1 fun function1 (): Int = throw Exception1(-52 ) fun function2 () = function1() fun function3 () = function2() fun main () { // function3() } Uncommenting the call to function3() produces the following stack trace: Exception in thread main exceptionhandling.Exception1: wrong value: - 52 at stacktrace.StacktraceKt.function1(Stacktrace.kt:6) at stacktrace.StacktraceKt.function2(Stacktrace.kt:8) at stacktrace.StacktraceKt.function3(Stacktrace.kt:10) at stacktrace.StacktraceKt.main(Stacktrace.kt:13) at stacktrace.StacktraceKt.main(Stacktrace.kt) Any of function1() , function2() or function3() can “catch” this exception and handle it, preventing that exception from terminating the program. An exception handler is the catch keyword followed by a parameter list containing the exception you’re handling. This is followed by a block of code implementing the recovery. In the following example, the function toss() produces different exceptions for arguments 1-3, and “OK” otherwise. test() contains a complete set of handlers for the toss() function: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Exception Handling 426 // ExceptionHandling/Handlers.kt package exceptionhandling import atomictest.eq fun toss (which: Int) = when (which) { 1 -> throw Exception1( 1 ) 2 -> throw Exception2( Exception 2 ) 3 -> throw Exception3( Exception 3 ) else -> OK } fun test (which: Int): Any? = try { toss(which) } catch (e: Exception1) { e.value } catch (e: Exception3) { e.message } catch (e: Exception2) { e.message } fun main () { test( 0 ) eq OK test( 1 ) eq 1 test( 2 ) eq Exception 2 test( 3 ) eq Exception 3 } When you call toss() you must catch all relevant toss() exceptions, allowing non-relevant exceptions to “bubble up” and be caught elsewhere. The entire try -catch in test() is a single expression: it returns either the last expression of the try body or the last expression of the catch clause matching an exception. If no catch handles the exception, that exception is thrown further up the stack. If uncaught, it generates a stack trace. Because Exception3 extends Exception2 , an Exception3 is handled as an Ex-ception2 if Exception2 ’s catch appears in the sequence of handlers before Exception3 ’s catch : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Exception Handling 427 // ExceptionHandling/Hierarchy.kt package exceptionhandling import atomictest.eq fun testCatchOrder (which: Int) = try { toss(which) } catch (e: Exception2) { // [1] Handler for Exception2 got ${e.message} } catch (e: Exception3) { // [2] Handler for Exception3 got ${e.message} } fun main () { testCatchOrder( 2 ) eq Handler for Exception2 got Exception 2 testCatchOrder( 3 ) eq Handler for Exception2 got Exception 3 } The catch -clause order means an Exception3 is caught by line [1] , despite the more specific type of exception handler in line [2] . Exception Subtypes In testCode() , an incorrect code argument throws an IllegalArgumentExcep-tion : // ExceptionHandling/LibraryException.kt package exceptionhandling import atomictest.* fun testCode (code: Int) { if (code <= 1000 ){ throw IllegalArgumentException( Code must be > 1000: $code ) } } fun main () { try { Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Exception Handling 428 // A1 is 161 in base-16 (hex) notation: testCode( A1 .toInt( 16 )) } catch (e: IllegalArgumentException) { e.message eq Code must be > 1000: 161 } try { testCode( 0 .toInt( 1 )) } catch (e: IllegalArgumentException) { e.message eq radix 1 was not in valid range 2..36 } } Both handlers catch IllegalArgumentException , which is thrown by both test-Code() and the library function toInt(radix) . This results in the somewhat confusing error messages in main() . The problem is that we are using the same exception to represent two different issues. We solve it by throwing a new exception type called IncorrectInputException for our error: // ExceptionHandling/NewException.kt package exceptionhandling import atomictest.eq class IncorrectInputException ( message: String ): Exception(message) fun checkCode (code: Int) { if (code <= 1000 ){ throw IncorrectInputException( Code must be > 1000: $code ) } } fun main () { try { checkCode( A1 .toInt( 16 )) } catch (e: IncorrectInputException) { e.message eq Code must be > 1000: 161 } catch (e: IllegalArgumentException) { println( Shouldn't get here ) Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Exception Handling 429 } try { checkCode( 1 .toInt( 1 )) } catch (e: IncorrectInputException) { println( Shouldn't get here ) } catch (e: IllegalArgumentException) { e.message eq radix 1 was not in valid range 2..36 } } Now each issue has its own handler. Resist creating too many exception types. As a rule of thumb, use different excep-tion types to distinguish different handling schemes, and use different constructor parameters to provide details for a particular handling scheme. Resource Cleanup When failure is inevitable, automatic resource cleanup allows other parts of the program to continue running safely. finally ensures resource cleanup during exception handling. A finally clause always runs, regardless of whether you leave a try block normally or exceptionally: // ExceptionHandling/TryFinally.kt package exceptionhandling import atomictest.* fun checkValue (value: Int) { try { trace(value) if (value <= 0 ) throw IllegalArgumentException( value must be positive: $value ) } finally { trace( In finally clause for $value ) } } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Exception Handling 430 fun main () { listOf( 10 ,-10 ).forEach { try { checkValue(it) } catch (e: IllegalArgumentException) { trace( In catch clause for main() ) trace(e.message) } } trace eq  10 In finally clause for 10 -10 In finally clause for -10 In catch clause for main() value must be positive: -10  } finally works even with intermediate catch clauses. For example, suppose a switch must be turned off when you’re done with it: // ExceptionHandling/GuaranteedCleanup.kt package exceptionhandling import atomictest.eq data class Switch ( var on: Boolean = false , var result: String = OK ) fun testFinally (i: Int): Switch { val sw = Switch() try { sw.on = true when (i) { 0 -> throw IllegalStateException() 1 -> return sw // [1] } } catch (e: IllegalStateException) { sw.result = exception } finally { Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Exception Handling 431 sw.on = false } return sw } fun main () { testFinally( 0 ) eq Switch(on=false, result=exception) testFinally( 1 ) eq Switch(on=false, result=OK) // [2] testFinally( 2 ) eq Switch(on=false, result=OK) } Even if we return inside a try ( [1] ), the finally clause still runs ( [2] ). Whether testFinally() completes normally or with an exception, the finally clause always executes. Exception Handling in AtomicTest In the book examples, we use AtomicTest’s capture() to ensure that the expected exceptions are thrown. Using capture() rather than try-catch keeps AtomicTest simple. capture() is a higher-order function that takes a lambda as an argument and returns a String that contains either an exception description or a statement that an exception was expected: // ExceptionHandling/CaptureImplementation.kt package exceptionhandling import atomictest.eq fun capture (f: () -> Unit): String = // [1] try { // [2] f() Error: Expected an exception // [3] } catch (e: Throwable) { // [4] ${e::class.simpleName}: ${e.message} } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Exception Handling 432 fun main () { capture { throw Exception( !!! ) } eq Exception: !!! capture { 1 } eq Error: Expected an exception } capture() takes a function argument ( [1] ) and runs it within a try block ( [2] ), handling all possible exceptions ( [4] ) by catching Throwable . If no exception is thrown, capture() returns a String indicating that an exception was expected ( [3] ). If the catch clause catches an exception, capture() returns a String containing the exception name and a message. capture() is a special case because you don’t normally catch Throwable . Instead, you process each specific type of exception. Guidelines Recovering from exceptions turns out to be remarkably rare, considering that was their original intent. The primary purpose of exceptions in Kotlin is to discover program bugs, not recovery. Catching exceptions in ordinary Kotlin code is thus a “code smell.” Here are guidelines for programming with exceptions: 1. Logic Errors : These are bugs in your code. Either don’t catch them at all (and let them produce a stack trace), or catch them at the top level of your application to report the bugs, possibly restarting the affected operation if that’s possible. 2. Data Errors : These are errors from bad data that the programmer cannot control. The application must somehow deal with the problem without blaming it on program logic. For example, Kotlin’s String.toInt() that we’ve been using in this atom throws an exception for an inappropriate String , but it has a companion String.toIntOrNull() that instead produces a null upon failure so you can use it in an expression: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Exception Handling 433 val n = string.toIntOrNull() ?: default The Kotlin library is designed around this idea, so operations that are expected to sometimes fail will usually have “OrNull” versions that you can use instead of the exception version, which generally exists for Java compatibility. 3. Don’t throw exceptions from your own functions unless they indicate logic errors. Kotlin provides Check Instructions for this purpose. 4. Input/Output Errors : These are external conditions that you can’t control and you can’t ignore. However, using the “OrNull” approach rapidly obscures the understandability of the code. More importantly, you often can recover from I/O errors, typically by retrying the operation. Thus, I/O operations in Kotlin throw exceptions, and you’ll places in your application that handle those and attempt to recover from them. Exercises and solutions for this atom can be found at AtomicKotlin.com ¹⁰⁵ . ¹⁰⁵ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Check Instructions Check instructions assert that constraints are satisfied. They are com-monly used, for example, to validate function arguments. Check instructions discover programming errors by expressing non-obvious require-ments. They can also act as documentation for future readers of that code. You’ll usually find check instructions at the beginning of a function, to ensure that the arguments are legitimate, and at the end, to check the function’s calculations. Check instructions typically throw exceptions when they fail. You can usually use check instructions instead of explicitly throwing exceptions. Check instructions are easier to write and think about, and produce more comprehensible code. They should be used whenever possible to test and illuminate your programs. require() Design By Contract¹⁰⁶ uses preconditions to guarantee initialization constraints. Kotlin’s require() is normally used to validate function arguments, so it typically appears at the beginning of function bodies. These tests cannot be checked at compile time. Preconditions are relatively easy to include in your code, but sometimes they can be turned into Unit Tests . Consider a numerical field representing a month on the Julian calendar. You know this value must always be in the range 1..12 . A precondition reports an error if the value falls outside that range: ¹⁰⁶ https://en.wikipedia.org/wiki/Design_by_contract ","Check Instructions 435 // CheckInstructions/JulianMonth.kt package checkinstructions import atomictest.* data class Month ( val monthNumber: Int) { init { require(monthNumber in 1. . 12 ){ Month out of range: $monthNumber } } } fun main () { Month( 1 ) eq Month(monthNumber=1) capture { Month( 13 ) } eq IllegalArgumentException:  + Month out of range: 13 } We perform the require() inside the constructor. require() throws an Ille-galArgumentException if its condition (the argument) isn’t satisfied. You can always use require() instead of throwing IllegalArgumentException . The second parameter for require() is a lambda that produces a String . If the String requires construction, that overhead doesn’t occur unless require() fails. When the arguments for Quadratic.kt from Summary 2 are inappropriate, it throws IllegalArgumentException . We can simplify the code using require() : // CheckInstructions/QuadraticRequire.kt package checkinstructions import kotlin.math.sqrt import atomictest.* class Roots ( val root1: Double, val root2: Double ) fun quadraticZeroes ( a: Double, b: Double, Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Check Instructions 436 c: Double ): Roots { require(a != 0.0 ){ a is zero } val underRadical = b * b -4 *a*c require(underRadical >= 0 ){ Negative underRadical: $underRadical } val squareRoot = sqrt(underRadical) val root1 = (-b - squareRoot) / 2 *a val root2 = (-b + squareRoot) / 2 *a return Roots(root1, root2) } fun main () { capture { quadraticZeroes( 0.0 , 4.0 , 5.0 ) } eq IllegalArgumentException:  + a is zero capture { quadraticZeroes( 3.0 , 4.0 , 5.0 ) } eq IllegalArgumentException:  + Negative underRadical: -44.0 val roots = quadraticZeroes( 3.0 , 8.0 , 5.0 ) roots.root1 eq -15.0 roots.root2 eq -9.0 } Notice how much clearer and cleaner this code is compared to the original Quadratic.kt . The following DataFile class allows us to work with files regardless of whether the examples run in the IDE via the AtomicKotlin course or in the standalone build for the book. All DataFile objects store their files in the targetDir subdirectory: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Check Instructions 437 // CheckInstructions/DataFile.kt package checkinstructions import atomictest.eq import java.io.File import java.nio.file.Paths val targetDir = File( DataFiles ) class DataFile ( val fileName: String) : File(targetDir, fileName) { init { if (!targetDir.exists()) targetDir.mkdir() } fun erase () { if (exists()) delete() } fun reset (): File { erase() createNewFile() return this } } fun main () { DataFile( Test.txt ) eq Paths. get ( DataFiles , Test.txt ) .toString() } A DataFile is used to manipulate the underlying file in the operating system; for example, to write and read that file.The base class for DataFile is java.io.File , which is one of the oldest classes in the Java library; it appeared in the first version of the language, back when they thought it was a great idea to use the same class ( File ) to represent both files and directories. Despite its antiquity, Kotlin can effortlessly inherit File . During construction, we create targetDir if it doesn’t exist. The erase() function deletes the file, while reset() deletes the file and creates a new, empty file. The Java standard library Paths class contains only an overloaded get() . The Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Check Instructions 438 version of get() we want takes any number of String s and builds a Path object, representing a directory path that is independent of the operating system. In the return statement, resolve() adds its parameter name to the end of the targetDir path. Opening a file often has a number of preconditions, usually involving file paths, naming, and contents. Consider a function that opens and reads a file with a name beginning with file_ . Using require() , we verify that the file name is correct and that the file exists and is not empty: // CheckInstructions/GetTrace.kt package checkinstructions import atomictest.* fun getTrace (fileName: String): List<String> { require(fileName.startsWith( file_ )) { $fileName must start with 'file_' } val file = DataFile(fileName) require(file.exists()) { $fileName doesn't exist } val lines = file.readLines() require(lines.isNotEmpty()) { $fileName is empty } return lines } fun main () { DataFile( file_empty.txt ).writeText(  ) DataFile( file_real.txt ).writeText( wubba lubba dub dub ) capture { getTrace( wrong_name.txt ) } eq IllegalArgumentException:  + wrong_name.txt must start with 'file_' capture { getTrace( file_nonexistent.txt ) } eq IllegalArgumentException:  + file_nonexistent.txt doesn't exist capture { Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Check Instructions 439 getTrace( file_empty.txt ) } eq IllegalArgumentException:  + file_empty.txt is empty getTrace( file_real.txt ) eq [wubba lubba dub dub] } We’ve been using the two-parameter version of require() , but there’s also a single-parameter version that produces a default message: // CheckInstructions/SingleArgRequire.kt package checkinstructions import atomictest.* fun singleArgRequire (arg: Int): Int { require(arg > 5 ) return arg } fun main () { capture { singleArgRequire( 5 ) } eq IllegalArgumentException:  + Failed requirement. singleArgRequire( 6 ) eq 6 } The failure message is not as explicit as the two-parameter version, but in some cases it is sufficient. requireNotNull() requireNotNull() tests its first argument and returns that argument if it is non-null . Otherwise, it produces an IllegalArgumentException . Upon success, requireNotNull() ’s argument is automatically smart-cast to a non-null type. Thus, you usually don’t need requireNotNull() ’s return value: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Check Instructions 440 // CheckInstructions/RequireNotNull.kt package checkinstructions import atomictest.* fun notNull (n: Int?): Int { requireNotNull(n) { // [1] notNull() argument cannot be null } return n* 9 // [2] } fun main () { val n: Int? = null capture { notNull(n) } eq IllegalArgumentException:  + notNull() argument cannot be null capture { requireNotNull(n) // [3] } eq IllegalArgumentException:  + Required value was null. notNull( 11 ) eq 99 } • [2] Notice that n no longer requires a null check, because the call to re-quireNotNull() has made it non-nullable. As with require() , there’s a two-parameter version with a message you can craft yourself ( [1] ), and a single-parameter version with a default message ( [3] ). Because requireNotNull() tests for a specific issue (nullity), the single-parameter version is more useful than it is with require() . check() A design-by-contract postcondition tests the results of a function. Postconditions are important for long, complex functions where you might not trust the results. Whenever you can describe constraints on the results of a function, it’s wise to express them as a postcondition. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Check Instructions 441 check() is identical to require() except that it throws IllegalStateException . It is typically used at the end of a function, to verify that the results (or the fields in the function’s object) are valid—that things haven’t somehow gotten into a bad state. Suppose a complex function writes to a file, and you are unsure whether all execution paths will create that file. Adding a postcondition at the end of the function helps ensure correctness: // CheckInstructions/Postconditions.kt package checkinstructions import atomictest.* val resultFile = DataFile( Results.txt ) fun createResultFile (create: Boolean) { if (create) resultFile.writeText( Resultsn# ok ) // ... other execution paths check(resultFile.exists()) { ${resultFile.name} doesn't exist! } } fun main () { resultFile.erase() capture { createResultFile( false ) } eq IllegalStateException:  + Results.txt doesn't exist! createResultFile( true ) } Assuming your preconditions ensure valid arguments, a postcondition failure almost always indicates a programming error. For this reason, you’ll see postconditions less often because, once the programmer is convinced the code is correct, the postcondition can be commented or removed if it impacts performance. Of course, it’s always best to leave such tests in place so problems caused by future code changes are immediately detected. One way to do this is by moving postconditions into Unit Tests . Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Check Instructions 442 assert() To avoid commenting and uncommenting check() statements, assert() allows you to enable and disable assert() checks. assert() comes from Java. Assertions are disabled by default, and are only engaged if you explicitly turn them on using a command-line flag. In Kotlin, this flag is -ea JVM . We recommend using require() and check() , which are always available without special configuration. Exercises and solutions for this atom can be found at AtomicKotlin.com ¹⁰⁷ . ¹⁰⁷ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","The Nothing Type Nothing represents “a value that never exists.” A Nothing return type indicates a function that never returns—usually a function that always throws an exception. The following infinite() function produces an infinite loop (avoid these). Because it never returns, its return type is Nothing : // NothingType/InfiniteLoop.kt package nothingtype fun infinite (): Nothing { while ( true ) {} } Nothing is a built-in Kotlin type with no instances. A practical example is the built-in TODO() , which has a return type of Nothing and throws NotImplementedError : // NothingType/Todo.kt package nothingtype import atomictest.* fun later (s: String): String = TODO( later() ) fun later2 (s: String): Int = TODO() fun main () { capture { later( Hello ) } eq NotImplementedError:  + An operation is not implemented: later() capture { later2( Hello! ) ","The Nothing Type 444 } eq NotImplementedError:  + An operation is not implemented. } later() and later2() compile successfully. If you call either one, an exception reminds you to write implementations. TODO() is a useful tool for “sketching” a code framework to verify that everything fits together before filling in the details. Both later() and later2() return non-Nothing types even though TODO() returns Nothing . Nothing is compatible with any type. Here, fail() always throws an Exception , so it returns Nothing . Notice that a call to fail() is more readable and compact than explicitly throwing an exception: // NothingType/Fail.kt package nothingtype import atomictest.* fun fail (i: Int): Nothing = throw Exception( fail($i) ) fun main () { capture { fail( 1 ) } eq Exception: fail(1) capture { fail( 2 ) } eq Exception: fail(2) } fail() allows you to easily change the error-handling strategy. For example, you can change the exception type or log an additional message before throwing an exception. Here, we throw a BadData exception if the argument is not a String : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","The Nothing Type 445 // NothingType/CheckObject.kt package nothingtype import atomictest.* class BadData (m: String) : Exception(m) fun checkObject (obj: Any?): String = if (obj is String) obj else throw BadData( Need String, got $obj ) fun test (checkObj: (obj: Any?) -> String) { checkObj( abc ) eq abc capture { checkObj( null ) } eq BadData: Need String, got null capture { checkObj( 123 ) } eq BadData: Need String, got 123 } fun main () { test( :: checkObject) } checkObject() ’s return type is the return type of the if expression. Kotlin treats a throw as type Nothing , and Nothing can be assigned to any type. In checkOb-ject() , String takes priority over Nothing , so the type of the if expression is String . test() prevents duplication across CheckObject.kt and CheckObject2.kt . We can rewrite checkObject() using a safe cast and the Elvis operator . checkOb-ject2() casts obj to a String if it can be cast, otherwise it throws an exception: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","The Nothing Type 446 // NothingType/CheckObject2.kt package nothingtype fun failWithBadData (obj: Any?): Nothing = throw BadData( Need String, got $obj ) fun checkObject2 (obj: Any?): String = (obj as ? String) ?: failWithBadData(obj) fun main () { test( :: checkObject2) } failWithBadData() is evaluated for the right-hand side of the Elvis operator. As before, the result is interpreted as type String . Nothing is also useful when working with null : // NothingType/ListOfNothing.kt fun main () { val none: Nothing? = null val listNone: List<Nothing?> = listOf( null ) } Without explicit type definitions, the compiler’s type inference produces the same results. Exercises and solutions for this atom can be found at AtomicKotlin.com ¹⁰⁸ . ¹⁰⁸ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Resource Cleanup Using try -finally blocks for resource cleanup is tedious and error-prone. Kotlin’s library functions manage cleanup for you. As you learned in Exception Handling , the finally clause cleans up resources regardless of how the try block exits. But what if an exception can happen while closing a resource? You end up with another try inside the finally clause. On top of that, if one exception is thrown inside try and another while closing the resource, the latter shouldn’t conceal the former. Ensuring proper cleanup becomes very messy. To reduce this complexity, Kotlin’s use() guarantees proper cleanup of closeable resources, liberating you from handwritten cleanup code. use() works with any object that implements Java’s AutoCloseable interface. It executes the code within the block, then calls close() on the object, regardless of how you exit the block—either normally (including via return ), or through an exception. use() rethrows all exceptions, so you must still deal with those exceptions. Predefined classes that work with use() are found in the Java documentation for AutoCloseable . For example, to read lines from a File we apply use() to a BufferedReader ( DataFile from Check Instructions inherits java.io.File ): // ResourceCleanup/AutoCloseable.kt import atomictest.eq import checkinstructions.DataFile fun main () { DataFile( Results.txt ) .bufferedReader() .use { it.readLines().first() } eq Results } useLines() opens a File object, extracts all its lines, and passes those lines to a target function (typically a lambda): ","Resource Cleanup 448 // ResourceCleanup/UseLines.kt import atomictest.eq import checkinstructions.DataFile fun main () { DataFile( Results.txt ).useLines { it.filter { # in it }.first() // [1] } eq # ok DataFile( Results.txt ).useLines { lines -> lines.filter { line -> // [2] # in line }.first() } eq # ok } • [1] The left-hand it refers to the collection of lines in the file, while the right-hand it refers to each individual line. To reduce confusion, avoid writing code with two different nearby it s. • [2] Named arguments prevent confusion from too many it s. Everything happens within the useLines() lambda; outside the lambda the file contents are unavailable (unless you explicitly return them). As it closes the file, useLines() returns the result of the lambda. forEachLine() makes it easy to apply an action to each line in a file: // ResourceCleanup/ForEachLine.kt import checkinstructions.DataFile import atomictest.* fun main () { DataFile( Results.txt ).forEachLine { if (it.startsWith( # )) trace( $it ) } trace eq # ok } The lambda in forEachLine() returns Unit , which means that anything you do with the lines must be achieved through side effects. In functional programming, we prefer returning results over side effects, and thus useLines() is a more functional Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Resource Cleanup 449 approach than forEachLine() . However, forEachLine() is a quick solution for simple utilities. You can create your own class that works with use() by implementing the Auto-Closeable interface, which contains only the close() function: // ResourceCleanup/Usable.kt package resourcecleanup import atomictest.* class Usable () : AutoCloseable { fun func () = trace( func() ) override fun close () = trace( close() ) } fun main () { Usable().use { it.func() } trace eq  func() close()  } use() ensures resource cleanup at the point the resource is created, instead of forcing you to write code when you’re finished with it. Exercises and solutions for this atom can be found at AtomicKotlin.com ¹⁰⁹ . ¹⁰⁹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Logging Logging captures information from a running program. For example, an installation program might log: • The steps taken during setup • The directories for file storage • Startup values for the program A web server might log the origin address and status of each request. Logging is also helpful during debugging. Without logging, you might decipher the behavior of a program using println() statements. For simplicity, some examples in this book use the println() technique, and it can be helpful in the absence a debugger (such as the one built into JetBrains IDEA). However, once you decide the program is working properly, you’ll probably take the println() statements out. Later, if you run into more bugs, you might put them back in. In contrast, logging statements can be dynamically enabled when you need them, and turned off otherwise. For some failures you can only report the issue. A program that recovers from some types of errors (as shown in Exception Handling ) can log details about those errors for later analysis. In a web application, for example, you don’t terminate the program if something goes wrong. Logging captures these events, giving programmers and administrators a way to discover the problems. Meanwhile, the application continues running. We use an open-source logging package designed for Kotlin called Kotlin-logging¹¹⁰ , which has the feel and simplicity of Kotlin. Note that there are other logging packages to choose from. You must create a logger before using it. You’ll almost always want to create it at file scope so it’s available to all components in that file: ¹¹⁰ https://github.com/MicroUtils/kotlin-logging ","Logging 451 // Logging/BasicLogging.kt package logging import mu.KLogging private val log = KLogging().logger fun main () { val msg = Hello, Kotlin Logging! log.trace(msg) log.debug(msg) log.info(msg) log.warn(msg) log.error(msg) } main() shows the different logging levels : trace() , debug() and info() capture behavioral information, while warn() and error() indicate problems. To determine the logging levels that are actually reported, configuration occurs when the program is invoked and can be modified during execution. This way, operators of long-running applications can change the logging level without restarting the program (which is often unacceptable). Logging libraries have a rather odd history. People were dissatisfied with the original logging library distributed with Java, so they created other libraries. In an attempt to unify logging, designers began developing common logging interfaces. Acknowledging that organizations may be invested in existing logging libraries, those interfaces were created as facades for multiple different logging libraries. Later, other programmers created (presumably improved) facades over those facades. Utilizing a logging system often means choosing a facade, then choosing one or more underlying implementations. The kotlin-logging library is a facade over the Simple Logging Facade for Java (SLF4J)¹¹¹ , which is an abstraction over multiple logging frameworks. You choose the framework that meets your needs—although it is more likely that the operations group in your company will make that decision, as they are the ones that usually manage logging and analyze the resulting log files. For this example we use slf4j-simple as our implementation. This comes as part ¹¹¹ https://www.slf4j.org/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Logging 452 of SLF4J and thus we are not required to install or configure an additional library— some libraries have an annoying amount of setup complexity. slf4j-simple sends its output to the console error stream. When you run the program, you see: [main] INFO mu.KLogging - Hello, Kotlin Logging! [main] WARN mu.KLogging - Hello, Kotlin Logging! [main] ERROR mu.KLogging - Hello, Kotlin Logging! trace() and debug() produce no output; the default configuration doesn’t report those levels. To get different reporting levels, change your logging configuration—a task we don’t talk about here, because it varies depending on the logging package you’re using. Logging implementations that log to files often manage those log files by automati-cally discarding the oldest parts when files get too large. There are additional tools designed to read and analyze log files. The practice of logging can require fairly involved research. For basic problems, the work of installing, configuring, and using a logging system might tempt you back to println() statements. Fortunately, there are easier strategies. The quick-and-dirty approach is to define a global function. This can easily be disabled when you don’t need it: // Logging/SimpleLoggingStrategy.kt package logging import checkinstructions.DataFile val logFile = // Reset ensures an empty file: DataFile( simpleLogFile.txt ).reset() fun debug (msg: String) = System.err.println( Debug: $msg ) // To disable: // fun debug(msg: String) { /* do nothing */ } fun trace (msg: String) = logFile.appendText( Trace: $msgn ) fun main () { Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Logging 453 debug( Simple Logging Strategy ) trace( Line 1 ) trace( Line 2 ) println(logFile.readText()) } /* Sample Output: Debug: Simple Logging Strategy Trace: Line 1 Trace: Line 2 */ debug() sends its output to the console error stream. It can easily be disabled by replacing its definition with an empty body. trace() sends its output to a log file. You can also create your own simple logging class: // Logging/AtomicLog.kt package atomiclog import checkinstructions.DataFile class Logger (fileName: String) { val logFile = DataFile(fileName).reset() private fun log (type: String, msg: String) = logFile.appendText( $type: $msgn ) fun trace (msg: String) = log( Trace , msg) fun debug (msg: String) = log( Debug , msg) fun info (msg: String) = log( Info , msg) fun warn (msg: String) = log( Warn , msg) fun error (msg: String) = log( Error , msg) // Added for basic testing: fun report (msg: String) { trace(msg) debug(msg) info(msg) warn(msg) error(msg) } } You can add support for other features like logging levels and time stamps. Using the library is straightforward: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Logging 454 // Logging/UseAtomicLog.kt package useatomiclog import atomiclog.Logger import atomictest.eq private val logger = Logger( AtomicLog.txt ) fun main () { logger.report( Hello, Atomic Log! ) logger.logFile.readText().trim() eq Trace: Hello, Atomic Log! Debug: Hello, Atomic Log! Info: Hello, Atomic Log! Warn: Hello, Atomic Log! Error: Hello, Atomic Log!  } It’s tempting to create yet another logging library. This is probably not a good use of time. Logging is not as simple as calling library functions—there’s a significant run-time component. Logging is typically included in the deliverable product, and operations people must be able to turn logging on and off, dynamically adjust logging levels, and control the logfiles. For long-running programs such as servers, this last issue is particularly important because it includes strategies to prevent logfiles from filling up. Exercises and solutions for this atom can be found at AtomicKotlin.com ¹¹² . ¹¹² https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Unit Testing Unit testing is the practice of creating a correctness test for each aspect of a function. Unit tests rapidly reveal broken code, accelerating development speed. There’s far more to testing than we can cover in this book, so this atom is only a basic introduction. The “Unit” in “Unit testing” describes a small piece of code (usually a function) that is tested separately and independently (not to be confused with the unrelated Kotlin Unit type). Unit tests are typically written by the programmer, and run each time you build the project. Because unit tests run so frequently, they must run quickly. You’ve been learning about unit testing while reading this book, via the AtomicTest library we use to validate the book’s code. AtomicTest uses the concise eq for the most common pattern in unit testing: comparing an expected result with a generated result. Of the numerous unit test frameworks, JUnit is the most popular for Java. There are also frameworks created specifically for Kotlin. The Kotlin standard library includes kotlin.test , which provides a facade for different test libraries. This way you’re not limited to using a particular library (JUnit, for example). kotlin.test also contains wrappers for basic assertion functions. To use kotlin.test , you must modify the dependencies section of your project’s build.gradle file to include: testImplementation org.jetbrains.kotlin:kotlin-test-common Inside a unit test, the programmer calls various assertion functions that demonstrate the expected behavior of the function under test. Assertion functions include assertEquals() , which compares the actual value against an expected value, and assertTrue() , which tests its first argument, a Boolean expression. In this example, the unit tests are the functions with names beginning with the word test : ","Unit Testing 456 // UnitTesting/NoFramework.kt package unittesting import kotlin.test.assertEquals import kotlin.test.assertTrue import atomictest.* fun fortyTwo () = 42 fun testFortyTwo (n: Int = 42 ){ assertEquals( expected = n, actual = fortyTwo(), message = Incorrect, ) } fun allGood (b: Boolean = true )=b fun testAllGood (b: Boolean = true ){ assertTrue(allGood(b), Not good ) } fun main () { testFortyTwo() testAllGood() capture { testFortyTwo( 43 ) } eq AssertionError:  + Incorrect, expected:<43> but was:<42> capture { testAllGood( false ) } eq AssertionError: Not good } In main() , you can see that a failing assertion function produces an Assertion-Error —this means the unit test has failed, signaling to the programmer that there’s a problem in the code being tested. kotlin.test contains an assortment of functions that have names starting with assert : • assertEquals() , assertNotEquals() • assertTrue() , assertFalse() Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Unit Testing 457 • assertNull() , assertNotNull() • assertFails() , assertFailsWith() Similar functions are typically included in every unit test framework, but the names and parameter order can be different. For example, the message parameter in assertEquals() might be first or last. Also, it’s easy to mix up expected and actual —using named arguments avoids this problem. The expect() function in kotlin.test runs a block of code and compares that result with the expected value: fun < T > expect( expected: T, message: String?, block: () -> T ){ assertEquals(expected, block(), message) } Here’s testFortyTwo() rewritten using expect() : // UnitTesting/UsingExpect.kt package unittesting import atomictest.* import kotlin.test.* fun testFortyTwo2 (n: Int = 42 ){ expect(n, Incorrect, ) { fortyTwo() } } fun main () { testFortyTwo2() capture { testFortyTwo2( 43 ) } eq AssertionError:  + Incorrect, expected:<43> but was:<42> assertFails { testFortyTwo2( 43 )} capture { assertFails { testFortyTwo2() } } eq AssertionError: Expected an  + exception to be thrown, but was  + completed successfully. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Unit Testing 458 assertFailsWith<AssertionError> { testFortyTwo2( 43 ) } capture { assertFailsWith<AssertionError> { testFortyTwo2() } } eq AssertionError: Expected an  + exception of class  + java.lang.AssertionError to be  + thrown, but was completed successfully. } It’s important to add tests for corner cases. If a function produces an error under certain conditions, this should be verified with a unit test (as AtomicTest ’s cap-ture() does). assertFails() and assertFailsWith() ensure that the exception is thrown. assertFailsWith() also checks the type of the exception. Test Frameworks A typical test framework contains a collection of assertion functions and a mecha-nism to run tests and display results. Most test runners show results with green for success and red for failure. This atom uses JUnit5 as the underlying library for kotlin.test . To include it in a project, the dependencies section of your build.gradle should look like this: testImplementation org.jetbrains.kotlin:kotlin-test testImplementation org.jetbrains.kotlin:kotlin-test-junit testImplementation org.jetbrains.kotlin:kotlin-test-junit5 testImplementation org.junit.jupiter:junit-jupiter:$junit_version If you’re using a different library, you can find setup details in that framework’s instructions. kotlin.test provides facades for the most commonly used functions. Asser-tions are delegated to the appropriate functions in the underlying test frame-work. For example, assertEquals() calls Assertions.assertEquals() in the org.junit.jupiter.api.Assertions class. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Unit Testing 459 Kotlin supports annotations for definitions and expressions. An annotation is the @ sign followed by the annotation name, and indicates special treatment for the annotated element. The @Test annotation converts a regular function into a test function. We can test fortyTwo() and allGood() using the @Test annotation: // Tests/unittesting/SampleTest.kt package unittesting import kotlin.test.* class SampleTest { @Test fun testFortyTwo () { expect( 42 , Incorrect, ) { fortyTwo() } } @Test fun testAllGood () { assertTrue(allGood(), Not good ) } } kotlin.test uses typealias to create a facade for the @Test annotation: typealias Test = org.junit.jupiter.api.Test This typealias tells the compiler to substitute the @org.junit.jupiter.api.Test annotation for @Test . A test class usually contains multiple unit tests. Ideally, each unit test only verifies a single behavior. This quickly guides you to the problem if a test fails when introducing new functionality. @Test functions can be run: • Independently • As a part of a class • Together with all tests defined for the application IntelliJ IDEA allows you to rerun only the failed tests. Consider a simple state machine with three states: On , Off and Paused . The functions start() , pause() , resume() and finish() control the state machine. resume() is necessary because resuming a paused machine is significantly cheaper and/or faster than starting a machine. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Unit Testing 460 // UnitTesting/StateMachine.kt package unittesting import unittesting.State.* enum class State { On, Off, Paused } class StateMachine { var state: State = Off private set private fun transition ( new: State, current: State = On ){ if (new == Off && state != Off) state = Off else if (state == current) state = new } fun start () = transition(On, Off) fun pause () = transition(Paused, On) fun resume () = transition(On, Paused) fun finish () = transition(Off) } These operations are ignored: • resume() or finish() on a machine that is Off . • pause() or start() on a Paused machine. To test StateMachine , we create a property sm inside the test class. The test runner creates a new StateMachineTest object before running each test, so you start with a fresh StateMachine object for each different test: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Unit Testing 461 // Tests/unittesting/StateMachineTest.kt package unittesting import kotlin.test.* class StateMachineTest { val sm = StateMachine() @Test fun start () { sm.start() assertEquals(State.On, sm.state) } @Test fun ` pause and resume ` () { sm.start() sm.pause() assertEquals(State.Paused, sm.state) sm.resume() assertEquals(State.On, sm.state) sm.pause() assertEquals(State.Paused, sm.state) } // ... } Normally, Kotlin only allows letters and digits for function names. However, if you put a function name inside backticks, you can use any characters (including whites-paces). This means you can create function names that are sentences describing their tests, such as pause and resume . This produces more useful error information. An essential goal of unit testing is to simplify the gradual development of complicated software. After introducing each new piece of functionality, a developer not only adds new tests to check its correctness but also runs all the existing tests to make sure that the prior functionality still works. You feel safer when introducing new changes, and the system is more predictable and stable. In the process of fixing a new bug, you create additional unit tests for this and similar cases, so you don’t make the same mistakes in the future. If you use a continuous integration (CI) server such as Teamcity¹¹³ , all available tests run automatically and you’re notified if something breaks. ¹¹³ https://www.jetbrains.com/teamcity/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Unit Testing 462 Consider a class with several properties: // UnitTesting/Learner.kt package unittesting enum class Language { Kotlin, Java, Go, Python, Rust, Scala } data class Learner ( val id: Int, val name: String, val surname: String, val language: Language ) It’s often helpful to add utility functions for manufacturing test data, especially when you must create many objects with the same default values during testing. Here, makeLearner() creates objects with those default values: // Tests/unittesting/LearnerTest.kt package unittesting import unittesting.Language.* import kotlin.test.* fun makeLearner ( id: Int, language: Language = Kotlin, // [1] name: String = Test Name $id , surname: String = Test Surname $id ) = Learner(id, name, surname, language) class LearnerTest { @Test fun ` single Learner ` () { val learner = makeLearner( 10 , Java) assertEquals( Test Name 10 , learner.name) } @Test fun ` multiple Learners ` () { val learners = ( 1. . 9 ).map( :: makeLearner) assertTrue( Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Unit Testing 463 learners.all { it.language == Kotlin }) } } Adding default arguments to Learner that are only for testing introduces unneces-sary complexity and potential confusion. makeLearner() is easier and cleaner when producing test instances, and it eliminates redundant code. The order of makeLearner() ’s parameters simplifies its usage. In this case, we expect to specify a non-default lang more often than changing default test values for name and surname , so the lang parameter is second ( [1] ). Mocking and Integration Tests A system that depends on other components complicates the creation of isolated tests. Rather than introducing dependencies on real components, programmers often use a practice called mocking . A mock replaces a real entity with a fake one during testing. Databases are commonly mocked to preserve the integrity of the stored data. The mock can implement the same interface as the real one, or it can be created using mocking libraries such as MockK¹¹⁴ . It’s vital to test separate pieces of functionality independently—that’s what unit tests do. It’s also essential to ensure that different parts of the system work when combined with each other—that’s what integration tests do. Unit tests are “inward-directed” while integration tests are “outward-directed”. Testing Inside IntelliJ IDEA IntelliJ IDEA provides support for both creating and running unit tests. To create a test, right-click (control-click on a Mac) the class or function you want to test and select “Generate…” from the pop-up menu. From the “Generate” menu, choose “Test…”. Select JUnit5 as the “Testing library”. If a message appears saying ¹¹⁴ https://github.com/mockk/mockk Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Unit Testing 464 “JUnit5 library not found in the module,” push the “Fix” button next to the message. The “Destination package” should be unittesting ; the result will end up in the Tests/unittesting directory—if you want the tests to run automatically, they must live under the Tests directory off the root directory of your project. Then just check the boxes next to the functions you want tested. Once the test framework code is generated, you can modify it to suit your purposes. For the examples and exercises in this atom, you can replace: import org.junit.Test import org.junit.Assert.* with: import kotlin.test. * When running the tests within IntelliJ IDEA, you may get an error message like “test events were not received.” This is because IDEA’s default configuration assumes you will be running your tests externally, using Gradle. To fix it so you can run your tests inside IDEA, start at the file menu: “File” -> “Settings” -> “Build, Execution, Deployment” -> “Build Tools” -> “Gradle” On that page you’ll see a drop-down titled “Run tests using:” which is set to “Gradle (Default)”. Change this to “IntelliJ IDEA” and your tests will run correctly. Exercises and solutions for this atom can be found at AtomicKotlin.com ¹¹⁵ . ¹¹⁵ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Section VII: Power Tools Any fool can write code that a computer can understand. Good program-mers write code that humans can understand. — Martin Fowler ","Scope Functions Scope functions create a temporary scope wherein you can access an object without using its name. Scope functions exist only to make your code more concise and readable. They do not provide any additional abilities. There are five scope functions: let() , run() , with() , apply() , and also() . They are designed to work with a lambda and do not require an import . They differ in the way you access the context object , using either it or this , and in what they return. with() uses a different calling syntax than the others. Here you can see the differences: // ScopeFunctions/Differences.kt package scopefunctions import atomictest.eq data class Tag ( var n: Int = 0 ){ var s: String =  fun increment () = ++n } fun main () { // let(): Access object with 'it' // Returns last expression in lambda val let1: Int = Tag( 1 ).let { it.s = let: ${it.n} it.increment() } let1 eq 2 // let() with named lambda argument: val let2: Int = Tag( 2 ).let { tag -> tag.s = let: ${tag.n} tag.increment() ","Scope Functions 467 } let2 eq 3 // run(): Access object with 'this' // Returns last expression in lambda val run1: Int = Tag( 3 ).run { s= run: $n increment() } run1 eq 4 // with(): Access object with 'this' // Returns last expression in lambda val with1: Int = with(Tag( 4 )) { s= with: $n increment() } with1 eq 5 // apply(): Access object with 'this' // Returns modified object val apply1: Tag = Tag( 5 ).apply { s= apply: $n increment() } apply1 eq Tag(n=6) // also(): Access object with 'it' // Returns modified object val also1: Tag = Tag( 6 ).also { it.s = also: ${it.n} it.increment() } also1 eq Tag(n=7) // also() with named lambda argument: val also2: Tag = Tag( 7 ).also { tag -> tag.s = also: ${tag.n} tag.increment() } also2 eq Tag(n=8) } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Scope Functions 468 There are multiple scope functions because they satisfy different combinations of needs: • Scope functions that access the context object using this ( run() , with() and apply() ) produce the cleanest syntax within their scope block. • Scope functions that access the context object using it ( let() and also() ) allow you to provide a named lambda argument. • Scope functions that produce the last expression in their lambda ( let() , run() and with() ) are for creating results. • Scope functions that return the modified context object ( apply() and also() ) are for chaining expressions together. When using a scope function with a nullable context object, the safe access operator ?. applies to the scope, so null testing is not necessary within that scope: // ScopeFunctions/Gnome.kt package scopefunctions class Gnome ( val name: String) { fun who () = Gnome: $name } fun whatGnome (gnome: Gnome?) { gnome ?. let { it.who() } // [1] gnome.let { it ?. who() } gnome ?. run { who() } // [2] gnome.run { this ?. who() } gnome ?. apply { who() } // [3] gnome.apply { this ?. who() } gnome ?. also { it.who() } // [4] gnome.also { it ?. who() } // No help for nullability: with(gnome) { this ?. who() } } Applying the safe access operator to the context object as in [1] -[4] null -checks the entire scope. Otherwise, each call within the scope must be individually null -checked. When you use the safe access operator on let() , run() , apply() or also() , the entire scope is ignored for a null context object: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Scope Functions 469 // ScopeFunctions/NullGnome.kt package scopefunctions import atomictest.* fun whichGnome (gnome: Gnome?) { trace(gnome ?. name) gnome ?. let { trace(it.who()) } gnome ?. run { trace(who()) } gnome ?. apply { trace(who()) } gnome ?. also { trace(it.who()) } } fun main () { whichGnome( null ) whichGnome(Gnome( Bob )) trace eq  null Bob Gnome: Bob Gnome: Bob Gnome: Bob Gnome: Bob  } The trace shows that when whichGnome() receives a null argument, none of the scope functions execute. Retrieving an object from a Map produces a nullable result because there’s no guarantee it will find an entry for that key. Here we show the different scope functions applied to the result of a Map lookup: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Scope Functions 470 // ScopeFunctions/MapLookup.kt package scopefunctions import atomictest.* data class Plumbus ( var id: Int) fun display (map: Map<String, Plumbus>) { trace( displaying $map ) val pb1: Plumbus = map[ main ] ?. let { it.id += 10 it } ?: return // [1] trace(pb1) val pb2: Plumbus? = map[ main ] ?. run { id += 9 this } trace(pb2) val pb3: Plumbus? = map[ main ] ?. apply { id += 8 } trace(pb3) val pb4: Plumbus? = map[ main ] ?. also { it.id += 7 } trace(pb4) } fun main () { display(mapOf( main to Plumbus( 1 ))) display(mapOf( none to Plumbus( 2 ))) trace eq  displaying {main=Plumbus(id= 1 )} Plumbus(id= 11 ) Plumbus(id= 20 ) Plumbus(id= 28 ) Plumbus(id= 35 ) displaying {none=Plumbus(id= 2 )}  Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Scope Functions 471 } Although with() can actually be forced into this example, the results are too ugly to consider. In the trace you see that each Plumbus object is created during the first call to display() , but none are created during the second call. Look at the definition of pb1 and recall the Elvis operator . If the expression to the left of ?: is non-null , it becomes the result and is assigned to pb1 . But if that expression is null , the right side of ?: becomes the result, which is return so display() returns before completing the initialization of pb1 . Scope functions work with nullable types in chained calls: // ScopeFunctions/NameTag.kt package scopefunctions import atomictest.trace val functions = listOf( fun (name: String?) { name ?. takeUnless { it.isBlank() } ?. let { trace( Hi! I am $it )} }, fun (name: String?) { name ?. takeUnless { it.isBlank() } ?. run { trace( Hi! I am $this )} }, fun (name: String?) { name ?. takeUnless { it.isBlank() } ?. apply { trace( Hi! I am $this )} }, fun (name: String?) { name ?. takeUnless { it.isBlank() } ?. also { trace( Hi! I am $it )} } ) fun main () { Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Scope Functions 472 functions.forEach { it( null )} functions.forEach { it(   )} functions.forEach { it( Yumyulack )} trace eq  Hi! I am Yumyulack Hi! I am Yumyulack Hi! I am Yumyulack Hi! I am Yumyulack  } functions creates a List of function references that are applied in forEach using it with function-call syntax. Each function in functions uses a different scope function. All the calls to it(null) and it( ) are effectively ignored, so we only display non-null , non-blank user input. None of the scope functions provide cleanup like use() does (see Resource Cleanup ): // ScopeFunctions/Blob.kt package scopefunctions import atomictest.* data class Blob ( val id: Int) : AutoCloseable { fun show () { trace( Show $id )} override fun close () = trace( Close $id ) } fun main () { Blob( 1 ).let { it.show() } Blob( 2 ).run { show() } with(Blob( 3 )) { show() } Blob( 4 ).apply { show() } Blob( 5 ).also { it.show() } Blob( 6 ).use { it.show() } Blob( 7 ).use { it.run { show() } } Blob( 8 ).apply { show() }.also { it.close() } Blob( 9 ).also { it.show() }.apply { close() } Blob( 10 ).apply { show() }.use { } trace eq  Show 1 Show 2 Show 3 Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Scope Functions 473 Show 4 Show 5 Show 6 Close 6 Show 7 Close 7 Show 8 Close 8 Show 9 Close 9 Show 10 Close 10  } Although use() looks similar to let() and also() , use() does not allow anything to be returned from its lambda so it prevents expression chaining or producing results. Without use() , close() is not called for any of the scope functions. To use a scope function and guarantee cleanup, place the scope function inside the use() lambda as in Blob(7) . Blob(8) and Blob(9) show how to explicitly call close() , and how to use apply() and also() interchangeably. Blob(10) uses apply() and the result is passed into use() , which calls close() at the end of its lambda. Exercises and solutions for this atom can be found at AtomicKotlin.com ¹¹⁶ . ¹¹⁶ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Extension Lambdas An extension lambda is like an extension function, except it defines a lambda instead of a function. Here, va and vb yield the same result: // ExtensionLambdas/Vanbo.kt package extensionlambdas import atomictest.eq val va: (String, Int) -> String = { str, n -> str.repeat(n) + str.repeat(n) } val vb: String.(Int) -> String = { this .repeat(it) + repeat(it) } fun main () { va( Vanbo , 2 ) eq VanboVanboVanboVanbo Vanbo .vb( 2 ) eq VanboVanboVanboVanbo vb( Vanbo , 2 ) eq VanboVanboVanboVanbo // Vanbo.va(2) // Doesn't compile } va is an ordinary lambda like the ones you’ve seen throughout this book. It takes two parameters, a String and an Int , and returns a String . The lambda body must start with two parameters and an arrow: str, n -> . vb moves the String parameter outside the parentheses and uses extension function syntax: String.(Int) . Just like an extension function, the object of the type being extended ( String , in this case), becomes the receiver , and can be accessed using this . The first call in vb uses the explicit form this.repeat(it) . The second call omits the this to produce repeat(it) . ","Extension Lambdas 475 Like any lambda, if you have only one parameter ( Int , in this case), it refers to that parameter. In main() , the call to va() is just what you’d expect from the lambda type dec-laration (String, Int) -> String —two arguments in a traditional function call. Since vb() is an extension, it can be called using the extension form Vanbo.vb(2) . vb() can also be called using the traditional form vb(Vanbo, 2) . va() cannot be called using the extension form. When you first see an extension lambda, it can seem like the String.(Int) part is what you should focus on. But String is not being extended by the parameter list (Int) —it is being extended by the entire lambda: String. (Int) -> String The Kotlin documentation usually refers to extension lambdas as function literals with receiver . The term function literal encompasses both lambdas and anonymous functions. The term lambda with receiver is often used synonymously with extension lambda. An extension lambda has the same type as an extension function. Like an extension function, it can have multiple parameters: // ExtensionLambdas/Parameters.kt package extensionlambdas import atomictest.eq val zero: Int.() -> Boolean = { this == 0 } val one: Int.(Int) -> Boolean = { this % it == 0 } val two: Int.(Int, Int) -> Boolean = { arg1, arg2 -> this % (arg1 + arg2) == 0 } val three: Int.(Int, Int, Int) -> Boolean = { arg1, arg2, arg3 -> this % (arg1 + arg2 + arg3) == 0 } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Extension Lambdas 476 fun main () { 0. zero() eq true 10. one( 10 ) eq true 20. two( 10 , 10 ) eq true 30. three( 10 , 10 , 10 ) eq true } In one() , it is used instead of naming the parameter. If this produces unclear syntax, it’s better to use explicit parameter names. We’ve been demonstrating extension lambdas by defining val s, but they more commonly appear as function parameters, as in f2() : // ExtensionLambdas/FunctionParameters.kt package extensionlambdas class A { fun af () = 1 } class B { fun bf () = 2 } fun f1 (lambda: (A, B) -> Int) = lambda(A(), B()) fun f2 (lambda: A.(B) -> Int) = A().lambda(B()) fun lambdas () { f1 { aa, bb -> aa.af() + bb.bf() } f2 { af() + it.bf() } } In main() , notice the more succinct syntax in the lambda provided to f2() . Returning Unit from an extension lambda accommodates all return types: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Extension Lambdas 477 // ExtensionLambdas/LambdaUnitReturn.kt package extensionlambdas fun unitReturn (lambda: A.() -> Unit) = A().lambda() fun nonUnitReturn (lambda: A.() -> String) = A().lambda() fun lambdaUnitReturn () { unitReturn { Unit ignores the return value + So it can be anything ... } unitReturn { 1 } // ... of any type ... unitReturn { } // ... or nothing nonUnitReturn { Must return the proper type } // nonUnitReturn { } // Not an option } Unless you require a specific return type from your lambda, choose Unit for the extra flexibility. An extension lambda can be passed to a function that expects an ordinary lambda, as long as the parameter lists conform to each other: // ExtensionLambdas/Transform.kt package extensionlambdas import atomictest.eq val duplicate: String.(Int) -> String = { repeat(it) } val alternate: String.(Int) -> String = { toCharArray() .filterIndexed { i, _ -> i % it == 0 } .joinToString(  ) } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Extension Lambdas 478 fun String .transform1( n: Int, lambda: (String, Int) -> String ) = lambda( this , n) fun String .transform2( n: Int, lambda: String.(Int) -> String ) = lambda( this , n) fun main () { hello .transform1( 5 , duplicate) .transform2( 3 , alternate) eq hleolhleo hello .transform2( 5 , duplicate) .transform1( 3 , alternate) eq hleolhleo } transform1() expects an ordinary lambda while transform2() expects an ex-tension lambda. In main() , the extension lambdas duplicate and alternate are passed to both transform1() and transform2() . Using :: we can pass a function reference when an extension lambda is expected: // ExtensionLambdas/FuncReferences.kt package extensionlambdas import atomictest.eq fun Int .d1(f: (Int) -> Int) = f( this )* 10 fun Int .d2(f: Int.() -> Int) = f() * 10 fun f1 (n: Int) = n + 3 fun Int .f2() = this + 3 fun main () { 74. d1( :: f1) eq 770 74. d2( :: f1) eq 770 74. d1(Int :: f2) eq 770 74. d2(Int :: f2) eq 770 } In the call 74.d1(Int::f2) we again pass an extension function to something that does not declare an extension lambda parameter. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Extension Lambdas 479 Polymorphism works with both ordinary extension functions ( Base.g() ) and ex-tension lambdas (the Base.h() parameter): // ExtensionLambdas/ExtensionPolymorphism.kt package extensionlambdas import atomictest.eq open class Base { open fun f () = 1 } class Derived : Base() { override fun f () = 99 } fun Base .g() = f() fun Base .h(xl: Base.() -> Int) = xl() fun main () { val b: Base = Derived() // Upcast b.g() eq 99 b.h { f() } eq 99 } You wouldn’t expect it not to work, but it’s always worth testing an assumption by creating an example. You can use anonymous function syntax (described in Local Functions ) instead of extension lambdas. Here we define an anonymous extension function: // ExtensionLambdas/AnonymousFunction.kt package extensionlambdas import atomictest.eq val divideBy = fun Int .(d: Int): Boolean { return this % d == 0 } fun exec ( arg1: Int, arg2: Int, f: Int.(Int) -> Boolean Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Extension Lambdas 480 ) = arg1.f(arg2) fun main () { 10. divideBy( 2 ) eq true 10. divideBy( 3 ) eq false exec( 10 , 2 , divideBy) eq true exec( 10 , 3 , divideBy) eq false } exec() shows that the anonymous extension function is accepted as an extension lambda. The Kotlin standard library contains a number of extension lambdas. For example, a StringBuilder is a modifiable object that produces an immutable String when you call toString() . The more modern buildString() accepts an extension lambda. It creates its own StringBuilder object, applies the extension lambda to that object, then calls toString() to produce the result: // ExtensionLambdas/StringCreation.kt package extensionlambdas import atomictest.eq private fun messy (): String { val built = StringBuilder() // [1] built.append( ABCs:  ) ( 'a' .. 'z' ).forEach { built.append(it) } return built.toString() // [2] } private fun clean () = buildString { append( ABCs:  ) ( 'a' .. 'z' ).forEach { append(it) } } fun main () { messy() eq clean() } In messy() we must repeat the name built multiple times. We must also create a StringBuilder ( [1] ) and produce the result ( [2] ). In clean() , buildString() eliminates this duplication along with the necessity to name the receiver for the Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Extension Lambdas 481 append() calls. With buildString() , you only include code that differs from one usage to the next. The standard library contains functions similar to buildString() that use extension lambdas to produce initialized, immutable List s and Map s: // ExtensionLambdas/ListsAndMaps.kt @file:OptIn(ExperimentalStdlibApi :: class ) package extensionlambdas import atomictest.eq val characters: List<String> = buildList { add( Chars: ) ( 'a' .. 'd' ).forEach { add( $it )} } val charmap: Map<Char, Int> = buildMap { ( 'A' .. 'F' ).forEachIndexed { n, ch -> put(ch, n) } } fun main () { characters eq [Chars:, a, b, c, d] charmap eq {A=0, B=1, C=2, D=3, E=4, F=5} } Within the extension lambdas the List and Map are mutable, but the results are an immutable List and Map . The Builder Pattern Hypothetically, you can create constructors to produce all necessary object config-urations. Sometimes the number of possibilities makes this messy and impractical. The Builder pattern has several benefits: 1. It creates objects in a multi-step process. This is helpful when object construc-tion is complex. 2. It produces different object variations using the same basic construction code. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Extension Lambdas 482 3. It separates common construction code from specialized code, making it easier to write and read the code for individual object variations. Implementing builders using extension lambdas provides an additional benefit, which is the creation of a Domain-Specific Language (DSL). The goal of a DSL is syntax that is comfortable and sensible to a user who is a domain expert rather than a programming expert. This allows that user to produce working solutions knowing only a small subset of the “surrounding” language—while at the same time benefiting from the structure and safety of that surrounding language. For example, consider a system that captures actions and ingredients for preparing food. In particular, we want to create different kinds of sandwiches. We can use classes to model the pieces of a Recipe : // ExtensionLambdas/Sandwich.kt package sandwich import atomictest.eq open class Recipe : ArrayList<RecipeUnit>() open class RecipeUnit { override fun toString () = ${this::class.simpleName} } open class Operation : RecipeUnit() class Toast : Operation() class Grill : Operation() class Cut : Operation() open class Ingredient : RecipeUnit() class Bread : Ingredient() class PeanutButter : Ingredient() class GrapeJelly : Ingredient() class Ham : Ingredient() class Swiss : Ingredient() class Mustard : Ingredient() open class Sandwich : Recipe() { fun action (op: Operation): Sandwich { add(op) Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Extension Lambdas 483 return this } fun grill () = action(Grill()) fun toast () = action(Toast()) fun cut () = action(Cut()) } fun sandwich ( fillings: Sandwich.() -> Unit ): Sandwich { val sandwich = Sandwich() sandwich.add(Bread()) sandwich.toast() sandwich.fillings() sandwich.cut() return sandwich } fun main () { val pbj = sandwich { add(PeanutButter()) add(GrapeJelly()) } val hamAndSwiss = sandwich { add(Ham()) add(Swiss()) add(Mustard()) grill() } pbj eq [Bread, Toast, PeanutButter,  + GrapeJelly, Cut] hamAndSwiss eq [Bread, Toast, Ham,  + Swiss, Mustard, Grill, Cut] } sandwich() captures the basic ingredients and operations to produce any Sandwich (here, we assume all sandwiches are toasted, but in the exercises you’ll see how to make that optional). The fillings extension lambda allows the caller to configure the Sandwich in many possible different ways, but without requiring a constructor for each configuration. The syntax seen in main() shows how this system might be used as a DSL—the user Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Extension Lambdas 484 only needs to understand the syntax of creating a Sandwich by calling sandwich() and providing the ingredients and operations inside the curly braces. Exercises and solutions for this atom can be found at AtomicKotlin.com ¹¹⁷ . ¹¹⁷ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Generics Generic code works with types that are “specified later.” Ordinary classes and functions work with specific types. If you want code to work across more types, this rigidity can be overconstraining. Polymorphism is an object-oriented generalization tool. You write a function that takes a base-class object as a parameter, then call that function with an object of any class derived from that base class—including classes that haven’t been created yet. Now your function is more general, and useful in more places. A single hierarchy can be too limiting because you must inherit from that hierarchy to produce an object that fits your function parameter. If a function parameter is an interface instead of a class, the limitations are loosened to include anything that implements the interface. This gives the client programmer the option of implementing an interface in combination with an existing class—that is, to adapt an existing class to fit the function. Used this way, interfaces can cut across class hierarchies. Sometimes even an interface is too restrictive because your code must work with that particular interface. You can write even more general code if you make it work with “some unspecified type,” rather than a specific interface or class. That “unspecified type” is a generic type parameter . Creating generic types and functions is a fairly complex topic, much of which is outside the scope of this book. This atom attempts to give you enough background to be conversant, so you aren’t surprised when you come across generic concepts and keywords. If you want to get serious about writing generic types and functions you’ll need to study more advanced resources. Any Any is the root of the Kotlin class hierarchy. Every Kotlin class has Any as a superclass. One way to work with unspecified types is by passing Any arguments, and this can ","Creating Generics 486 sometimes confuse the issue of when to use generics. If Any works, it’s the simpler solution, and simpler is generally better. There are two ways to use Any . The first, and most straightforward approach, is when you only need to operate on an Any , and nothing more. This, however, is extremely limited—there are only three member functions: equals() , hashCode() and toString() . There are also extension functions, but these cannot perform any direct operations on the type. For example, apply() only applies its function argument to the Any . If you know the type of the Any , you can cast it and perform type-specific operations. Because this involves run-time type information (as shown in Downcasting ), you risk a runtime error if you pass the wrong type to your function (there’s also a slight performance impact). Sometimes this is justified to gain the benefit of eliminating code duplication. For example, suppose we have three types with the ability to communicate. They come from different libraries so you don’t have the option of putting them in the same hierarchy, and they have different function names for communicating: // CreatingGenerics/Speakers.kt package creatinggenerics import atomictest.eq class Person { fun speak () = Hi! } class Dog { fun bark () = Ruff! } class Robot { fun communicate () = Beep! } fun talk (speaker: Any) = when (speaker) { is Person -> speaker.speak() is Dog -> speaker.bark() is Robot -> speaker.communicate() else -> Not a talker // Or exception Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Generics 487 } fun main () { talk(Person()) eq Hi! talk(Dog()) eq Ruff! talk(Robot()) eq Beep! talk( 11 ) eq Not a talker } The when expression discovers the type of the speaker parameter and calls the appropriate function. If you don’t think talk() will ever need to work with additional types, this is a tolerable solution. Otherwise, it requires you to modify talk() for each new type you add, and to rely on runtime information to discover when you miss something. Defining Generics Some code is very fundamental and can be commonly applied to almost anything. Because that code is common, it makes sense to extract it and make it generic. This prevents duplication of that common code. To define a generic function or type, add angle brackets ( <> ) containing one or more generic placeholders. Here, the generic placeholder T represents the unknown type: // CreatingGenerics/DefiningGenerics.kt package creatinggenerics fun < T > gFunction(arg: T): T = arg class GClass <T>( val x: T) { fun f (): T = x } class GMemberFunction { fun < T > f(arg: T): T = arg } interface GInterface <T> { val x: T Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Generics 488 fun f (): T } class GImplementation <T>( override val x: T ) : GInterface<T> { override fun f (): T = x } fun basicGenerics () { gFunction( Yellow ) gFunction( 1 ) gFunction(Dog()).bark() // [1] gFunction<Dog>(Dog()).bark() GClass( Cyan ).f() GClass( 11 ).f() GClass(Dog()).f().bark() // [2] GClass<Dog>(Dog()).f().bark() GMemberFunction().f( Amber ) GMemberFunction().f( 111 ) GMemberFunction().f(Dog()).bark() // [3] GMemberFunction().f<Dog>(Dog()).bark() GImplementation( Cyan ).f() GImplementation( 11 ).f() GImplementation(Dog()).f().bark() } basicGenerics() shows that each generic can handle multiple types. • gFunction() takes a parameter of type T and returns a T result. • GClass stores a T , and its member function f() returns that T . • GMemberFunction parameterizes a member function within the class, rather than the entire class. • You can also have interface s with generic parameters as shown in GInter-face and GImplementation . Notice in [1] , [2] and [3] that we are able to call bark() on the result, because that result emerges as type Dog . Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Generics 489 Now look at [1] , [2] and [3] , and the lines immediately following them. The type T is determined by type inference for [1] , [2] and [3] . Sometimes this is not possible if a generic or its invocation is too complex to be parsed by the compiler. In this case you must specify the type(s) using the syntax shown in the lines immediately following [1] , [2] and [3] . Preserving Type Information As you will see later in this atom, code within generic classes and functions doesn’t know the type of T —this is called erasure . Generics can be thought of as a way to preserve type information for the return value, freeing you from writing code that explicitly checks and casts that return value to your desired type. A common use of generic code is for containers that hold other objects. Consider a CarCrate class that acts as a trivial collection by holding and producing a single element of type Car : // CreatingGenerics/CarCrate.kt package creatinggenerics import atomictest.eq class Car { override fun toString () = Car } class CarCrate ( private var c: Car) { fun put (car: Car) { c = car } fun get (): Car = c } fun main () { val cc = CarCrate(Car()) val car: Car = cc. get () car eq Car } When we call cc.get() , the result comes back as type Car . We’d like to make this tool available to more objects than just Car s, so we generify this class as Crate<T> : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Generics 490 // CreatingGenerics/Crate.kt package creatinggenerics import atomictest.eq open class Crate <T>( private var contents: T) { fun put (item: T) { contents = item } fun get (): T = contents } fun main () { val cc = Crate(Car()) val car: Car = cc. get () car eq Car } Crate<T> ensures that you can only put() a T into the Crate , and when you call get() on that Crate , the result comes back as type T . We can create a version of map() for Crate by defining a generic extension function: // CreatingGenerics/MapCrate.kt package creatinggenerics import atomictest.eq fun < T , R> Crate<T>.map(f:(T) -> R): List<R> = listOf(f( get ())) fun main () { Crate(Car()).map { it.toString() + x } eq [Carx] } By definition, map() returns a List of results produced by applying f() to each element in the input sequence. Crate only contains a single element so the result is always a list of one element. There are two generic arguments: T for the input value and R for the result, allowing f() to produce a result type that is different from the input type. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Generics 491 Type Parameter Constraints A type parameter constraint says that the generic argument type must be inherited from the constraint. <T : Base> means that T must be of type Base or something derived from Base . This section explains why using constraints is different than non-generic code that simply uses Base . Consider a type hierarchy that models different kinds of disposable items and what to do with them: // CreatingGenerics/Disposable.kt package creatinggenerics import atomictest.eq interface Disposable { val name: String fun action (): String } class Compost ( override val name: String) : Disposable { override fun action () = Add to composter } interface Transport : Disposable class Donation ( override val name: String) : Transport { override fun action () = Call for pickup } class Recyclable ( override val name: String) : Transport { override fun action () = Put in bin } class Landfill ( override val name: String) : Transport { override fun action () = Put in dumpster } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Generics 492 val items = listOf( Compost( Orange Peel ), Compost( Apple Core ), Donation( Couch ), Donation( Clothing ), Recyclable( Plastic ), Recyclable( Metal ), Recyclable( Cardboard ), Landfill( Trash ), ) val recyclables = items.filterIsInstance<Recyclable>() Using a constraint, we can access properties and functions of the constrained type within a generic function: // CreatingGenerics/Constrained.kt package creatinggenerics import atomictest.eq fun < T : Disposable> nameOf(disposable: T) = disposable.name // As an extension: fun < T : Disposable> T.name() = name fun main () { recyclables.map { nameOf(it) } eq [Plastic, Metal, Cardboard] recyclables.map { it.name() } eq [Plastic, Metal, Cardboard] } Without the constraint, we could not access name . In this case, however, we can achieve the same result without generics: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Generics 493 // CreatingGenerics/NonGenericConstraint.kt package creatinggenerics import atomictest.eq fun nameOf2 (disposable: Disposable) = disposable.name fun Disposable .name2() = name fun main () { recyclables.map { nameOf2(it) } eq [Plastic, Metal, Cardboard] recyclables.map { it.name2() } eq [Plastic, Metal, Cardboard] } Why use a constraint instead of ordinary polymorphism? The answer is in the return type. With generics, the return type can be exact, rather than being upcast to the base type: // CreatingGenerics/SameReturnType.kt package creatinggenerics import kotlin.random.Random private val rnd = Random( 47 ) fun List <Disposable>.aRandom(): Disposable = this [rnd.nextInt(size)] fun < T : Disposable> List<T>.bRandom(): T = this [rnd.nextInt(size)] fun < T > List<T>.cRandom(): T = this [rnd.nextInt(size)] fun sameReturnType () { val a: Disposable = recyclables.aRandom() val b: Recyclable = recyclables.bRandom() val c: Recyclable = recyclables.cRandom() } Without generics, aRandom() can only produce a base-class Disposable , while both bRandom() and cRandom() produce a Recyclable . bRandom() never accesses any Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Generics 494 elements of T , therefore its constraint is pointless and it ends up being the same as cRandom() , which doesn’t use a constraint. The only time you need constraints is if you require both of the following: 1. Access a function or property. 2. Preserve the type when returning it. // CreatingGenerics/Constraints.kt package creatinggenerics import kotlin.random.Random private val rnd = Random( 47 ) // Accesses action() but can't return // the exact type: fun List <Disposable>.inexact(): Disposable { val d: Disposable = this [rnd.nextInt(size)] d.action() return d } // Can't access action() without a constraint: fun < T > List<T>.noAccess(): T { val d: T = this [rnd.nextInt(size)] // d.action() return d } // Access action() and return the exact type: fun < T : Disposable> List<T>.both(): T { val d: T = this [rnd.nextInt(size)] d.action() return d } fun constraints () { val i: Disposable = recyclables.inexact() val n: Recyclable = recyclables.noAccess() val b: Recyclable = recyclables.both() } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Generics 495 inexact() is an extension to List<Disposable> , which allows it to access ac-tion() , but it is not generic so it can only return the base type Disposable . As a generic, noAccess() is able to return the exact type of T , but without bounds it cannot access action() . Only when you add the constraint on T in both() are you able to access action() and return the exact type T . Erasure and Reification A primary goal in the design of Kotlin is Java compatibility. In Java, generics were not part of the original language—they were added years later, after large bodies of code had been written. To force generics into Java without breaking this existing code, a crucial compromise was made: The generic type is only available for function arguments and return values. Inside the function body, Java “erases” the type. For compatibility, Kotlin also uses erasure, but adds the reified keyword when you want to retain type information. Consider a function a() that requires class information to perform its task: // CreatingGenerics/ReificationA.kt package creatinggenerics fun < T > a(class_: Class<T>) { // Uses Class<T> } When we call a() from a generic function, we would like to be able to take the class information from the generic argument, like this: // CreatingGenerics/ReificationB.kt package creatinggenerics // Doesn't compile because of erasure: // fun <T> b() = a(T::class.java) Alas, the type information for T is erased within the body of b() , so b() doesn’t compile. The Java solution is to pass type information into the function by hand: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Generics 496 // CreatingGenerics/ReificationC.kt package creatinggenerics fun < T > c(class_: Class<T>) = a(class_) class K val kc = c(K :: class .java) Passing explicit type information should be redundant because we already have T . This messiness is solved with the reified keyword. To use reified , the function must also be inline : // CreatingGenerics/ReificationD.kt package creatinggenerics inline fun < reified T> d() = a(T :: class .java) val kd = d<K>() d() produces the same effect as c() , but d() doesn’t require the class reference as an argument. Reification allows the use of is with a generic parameter type: // CreatingGenerics/CheckType.kt package creatinggenerics import atomictest.eq inline fun < reified T> check(t: Any) = t is T fun main () { check<String>( 1 ) eq true check<Int>( 1 ) eq false } In this next example, select() produces the name of each Disposable item of a particular subtype by using reified together with a constraint: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Generics 497 // CreatingGenerics/Select.kt package creatinggenerics import atomictest.eq inline fun < reified T : Disposable> select() = items.filterIsInstance<T>().map { it.name } fun main () { select<Compost>() eq [Orange Peel, Apple Core] select<Donation>() eq [Couch, Clothing] select<Recyclable>() eq [Plastic, Metal, Cardboard] select<Landfill>() eq [Trash] } Reification has other interesting issues that are beyond the scope of this book. Variance Combining generics and inheritance complicates things because there are now two dimensions of change. If you have a Container<T> and you want to assign it to a Container<U> where T and U have an inheritance relationship, you must place constraints upon Container using the in or out variance annotations , depending on how you want to use Container . Crate uses a regular <T> . Here are two more versions that use <in T> and <out T> (Note that in and out are only allowed for type parameters of classes and interfaces): Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Generics 498 // CreatingGenerics/InAndOutCrates.kt package creatinggenerics class InCrate < in T>( private var contents: T) { fun put (item: T) { contents = item } // fun get(): T = contents } class OutCrate < out T>( private var contents: T) { // fun put(item: T) { contents = item } fun get (): T = contents } in T means that member functions of the class can only accept arguments of type T , but cannot return values of type T . That is, T objects can be placed into an InCrate , but cannot come out. out T means that member functions can return T objects, but cannot accept arguments of type T —you cannot place T objects into an OutCrate . Why do we need these constraints? Consider this hierarchy: // CreatingGenerics/GrapeSoda.kt package creatinggenerics open class Can open class Beverage : Can() class Grape : Beverage() class Cherry : Beverage() It seems like we should be able to assign, for example, a Crate of Grape to a Crate of Beverage or to a Crate of Can : // CreatingGenerics/CrateAssignment.kt package creatinggenerics val cg = Crate<Grape>(Grape()) // val cb: Crate<Beverage> = cg // val cc: Crate<Can> = cg The compiler doesn’t allow this. If it did, the signature of put() for Crate<Beverage> would be put(item: Beverage) and the signature of put() for Crate<Can> would Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Generics 499 be put(item: Can) . Cherry is also a Beverage and a Can , so either one would allow us to put a Cherry into a Crate<Grape> , violating the “Grape-ness” of that Crate . If we prevent the use of put() , the assignments are safe because we won’t be able to put a Cherry into an OutCrate<Grape> . The compiler allows us to assign an OutCrate<Grape> to an OutCrate<Beverage> or to an OutCrate<Can> because out prevents them from having put() functions: // CreatingGenerics/OutCrateAssignment.kt package creatinggenerics val ocg: OutCrate<Grape> = OutCrate(Grape()) val ocb: OutCrate<Beverage> = ocg val occ: OutCrate<Can> = ocg fun getting () { val grape: Grape = ocg. get () val beverage: Beverage = ocb. get () val can: Can = occ. get () } With no put() , we cannot place a Cherry into an OutCrate<Grape> so its “Grape-ness” is preserved. Without a get() , an InCrate<Can> can be assigned to an InCrate<Beverage> , an InCrate<Grape> or an InCrate<Cherry> : // CreatingGenerics/InCrateAssignment.kt package creatinggenerics val icc: InCrate<Can> = InCrate(Can()) val icb: InCrate<Beverage> = icc val icg: InCrate<Grape> = icc val ich: InCrate<Cherry> = icc fun main () { icc.put(Can()) icc.put(Beverage()) icc.put(Grape()) icc.put(Cherry()) icb.put(Beverage()) Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Creating Generics 500 icb.put(Grape()) icb.put(Cherry()) icg.put(Grape()) ich.put(Cherry()) } It is safe to put() a Can , Beverage , Grape or Cherry into an InCrate<Can> , while you can only put() a Beverage , Grape or Cherry into an InCrate<Beverage> , and if the InCrate holds Grape or Cherry , that’s all you can call put() with. These are the behaviors we would expect for crates with those type parameters, and the compiler enforces that. Notice that we are just assigning the crates—we are not casting the crates up or down an inheritance hierarchy. InCrate and OutCrate are not inherited types, but we expect them to honor the inheritance hierarchy of the types they contain. Variance has some deeper complexities we cannot cover here. Repeated code is a candidate for generic types or functions. This atom gave you a basic grasp of the ideas; if you need more comprehensive understanding you must find that in a more advanced treatment. Exercises and solutions for this atom can be found at AtomicKotlin.com ¹¹⁸ . ¹¹⁸ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Operator Overloading In the context of computer programming, overloading means “adding extra meaning to something that already exists.” Operator overloading allows you to take an operator like + and give it meaning for your new type, or an extra meaning for an existing type. Operator overloading has a tumultuous past. It was popularized in C++, but because C++ had no garbage collection, writing overloaded operators was difficult. As a result, the early Java designers deemed operator overloading “bad” and didn’t allow it in Java, even though Java’s garbage collection would have made it relatively easy. The simplicity of operator overloading when supported by garbage-collection was demonstrated in the Python language, which constrained you to a limited (familiar) set of operators, as did C++. Scala then experimented with allowing you to invent your own operators, causing some programmers to abuse this feature and create truly incomprehensible code. Kotlin learned from all these languages, and has simplified the process of operator overloading but restricts your choices to a reasonable and familiar set of operators. In addition, the rules of operator precedence cannot be changed. We’ll create a small class Num and add an overloaded + as an extension function. To overload an operator you use the operator keyword before fun , followed by the special predefined function name for that operator. For example, the special function name for the + operator is plus() : ","Operator Overloading 502 // OperatorOverloading/Num.kt package operatoroverloading import atomictest.eq data class Num ( val n: Int) operator fun Num .plus(rval: Num) = Num(n + rval.n) fun main () { Num( 4 ) + Num( 5 ) eq Num( 9 ) Num( 4 ).plus(Num( 5 )) eq Num( 9 ) } If you were defining a normal (non-operator) function for use between two operands, you’d use the infix keyword, but operators are already infix . Because plus() is an ordinary function, you can also call it in the conventional way. When you define an operator as a member function, you can access private elements in a class that an extension function cannot: // OperatorOverloading/MemberOperator.kt package operatoroverloading import atomictest.eq data class Num2 ( private val n: Int) { operator fun plus (rval: Num2) = Num2(n + rval.n) } // Cannot access 'n': it is private in 'Num2': // operator fun Num2.minus(rval: Num2) = // Num2(n - rval.n) fun main () { Num2( 4 ) + Num2( 5 ) eq Num2( 9 ) } In some contexts it’s helpful to create special meaning for an operator. Here, we model something called a Molecule that can be attached to another Molecule using + : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Operator Overloading 503 // OperatorOverloading/Molecule.kt package operatoroverloading import atomictest.eq data class Molecule ( val id: Int = idCount++, var attached: Molecule? = null ){ companion object { private var idCount = 0 } operator fun plus (other: Molecule) { attached = other } } fun main () { val m1 = Molecule() val m2 = Molecule() m1 + m2 // [1] m1 eq Molecule(id=0, attached= + Molecule(id=1, attached=null)) } The attached property links one Molecule to another. [1] reads like a familiar math expression, but to the person using the model it might be an especially meaningful syntax. Note that this example is incomplete; if you add the line m2 + m1 , then try to display m2 , you’ll get a stack overflow (can you fix the problem?). Here are all the operators available for overloading, defined as minimally as possible so you can see their basic syntax and use. The function bodies are nonsensical—they are only adequate enough to successfully compile: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Operator Overloading 504 // OperatorOverloading/AllOperators.kt package operatoroverloading class C { // equals() cannot be an extension // function and must be defined specially: override operator fun equals (other: Any?) = true } // Unary operators: operator fun C .unaryPlus() = this operator fun C .unaryMinus() = this operator fun C .not() = this // Increment/decrement: operator fun C .inc() = this operator fun C .dec() = this // Binary operators: operator fun C .plus(rv: C) = rv operator fun C .minus(rv: C) = rv operator fun C .times(rv: C) = rv operator fun C .div(rv: C) = rv operator fun C .rem(rv: C) = rv operator fun C .rangeTo(rv: C) = rv // 'In' operator: operator fun C .contains(rv: C) = true // Indexed access: operator fun C . get (i: Int) = this operator fun C . set (i: Int, c: C) = this // Augmented assignment: operator fun C .plusAssign(rv: C) = Unit operator fun C .minusAssign(rv: C) = Unit operator fun C .timesAssign(rv: C) = Unit operator fun C .divAssign(rv: C) = Unit operator fun C .remAssign(rv: C) = Unit // Comparison, must return Int: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Operator Overloading 505 operator fun C .compareTo(rv: C) = 1 fun main () { val c = C() +c // unaryPlus() -c // unaryMinus() !c // not() var cc = C() cc++ // inc() (needs var) cc--// dec() (needs var) c+c // plus() c-c // minus() c*c // times() c/c // div() c%c // rem() c..c // rangeTo() c in c // contains() c! in c // contains() c[ 2 ] // get() c[ 2 ]=c // set() c += c // plusAssign() c -= c // minusAssign() c *= c // timesAssign() c /= c // divAssign() c %= c // remAssign() // equals(): c == c c != c // compareTo(): c<c c>c c <= c c >= c } Although we’ve defined all the operators as extension functions, equals() cannot be. Kotlin requires that it not only be a member function, but that it take an Any? as its parameter. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Operator Overloading 506 Invoke Placing parentheses after an object generates a call to invoke() , so the invoke() operator makes an object look like it’s a function. You can define invoke() with any number of parameters: // OperatorOverloading/Invoke.kt package operatoroverloading import atomictest.eq class Func { operator fun invoke () = invoke() operator fun invoke (i: Int) = invoke($i) operator fun invoke (i: Int, j: String) = invoke($i, $j) operator fun invoke ( i: Int, j: String, k: Double )= invoke($i, $j, $k) } fun main () { val f = Func() f() eq invoke() f( 22 ) eq invoke(22) f( 22 , Hi ) eq invoke(22, Hi) f( 22 , Three , 3.1416 ) eq invoke(22, Three, 3.1416) } You can also define invoke() with vararg to work with any number of arguments of the same type (see Variable Argument Lists ). invoke() can be defined as an extension function. Here, it’s an extension for String , taking a function as a parameter and calling that function on the String : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Operator Overloading 507 // OperatorOverloading/StringInvoke.kt package operatoroverloading import atomictest.eq operator fun String .invoke( f: (s: String) -> String ) = f( this ) fun main () { mumbling { it.toUpperCase() } eq MUMBLING } Because the lambda is the final invoke() argument, it can be called without parentheses. Function Names in Backticks Kotlin allows spaces, certain nonstandard characters, and reserved words in a function name by placing that function name inside backticks: // OperatorOverloading/Backticks.kt package operatoroverloading fun ` A long name with spaces ` () = Unit fun `* how * is this working? ` () = Unit fun `' when ' is a keyword ` () = Unit // fun `Illegal characters :<>`() = Unit fun main () { ` A long name with spaces ` () ` *how* is this working? ` () `' when ' is a keyword ` () } This can be particularly helpful for testing by creating readable test names that include details about those tests. It also simplifies interactions with Java code. You can easily create incomprehensible code: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Operator Overloading 508 // OperatorOverloading/Swearing.kt package operatoroverloading import atomictest.eq infix fun String . `# !% ` (s: String) = $this Rowzafrazaca $s fun main () { howdy `# !% ` Ma'am! eq howdy Rowzafrazaca Ma'am! } Kotlin accepts this code, but what does it mean to the reader? Because code is read much more than it is written, you should make your programs as understandable as possible. Languages work just fine without operator overloading. It isn’t an essential feature, but is an excellent example of how a language is more than just a way to manipulate the underlying computer. That’s the easy part. The hard part is crafting the language to provide better ways to express your abstractions, so humans have an easier time understanding the code without getting bogged down in needless detail. It’s possible to define operators in ways that obscure meaning, so tread carefully. “Everything is syntactic sugar. Toilet paper is syntactic sugar, and I still want it.” — Barry Hawkins Exercises and solutions for this atom can be found at AtomicKotlin.com ¹¹⁹ . ¹¹⁹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Using Operators In practice you rarely overload operators—usually only when you create your own library. However, you regularly use overloaded operators, often even without noticing. For example, the Kotlin standard library defines numerous operators that improve your experience with collections. Let’s look at some familiar code from a new angle: // UsingOperators/NewAngle.kt import atomictest.eq fun main () { val list = MutableList( 10 ){ 'a' + it } list[ 7 ] eq 'h' // operator get() list. get ( 8 ) eq 'i' // Explicit call list[ 9 ]= 'x' // operator set() list. set ( 9 , 'x' ) // Explicit call list[ 9 ] eq 'x' ( 'd' in list) eq true // operator contains() list.contains( 'e' ) eq true // Explicit call } Accessing list elements using square brackets actually calls the overloaded get() and set() operators, while in calls contains() . Calling += on a mutable collection modifies it, while calling + returns a new collection containing the old elements together with the new element: ","Using Operators 510 // UsingOperators/OperatorPlus.kt import atomictest.eq fun main () { val mutableList = mutableListOf( 1 , 2 , 3 ) mutableList += 4 // operator plusAssign() mutableList.plusAssign( 5 ) // Explicit mutableList eq [1, 2, 3, 4, 5] mutableList + 99 eq [1, 2, 3, 4, 5, 99] mutableList eq [1, 2, 3, 4, 5] val list = listOf( 1 ) // Read-only val newList = list + 2 // operator plus() list eq [1] newList eq [1, 2] val another = list.plus( 3 ) // Explicit another eq [1, 3] } Calling += on a read-only collection probably doesn’t produce what you expect: // UsingOperators/Unexpected.kt import atomictest.eq fun main () { var list = listOf( 1 , 2 ) list += 3 // Probably unexpected list eq [1, 2, 3] } In a mutable collection, a += b calls plusAssign() to modify a . However, plusAs-sign() is not available for a read-only collection, so Kotlin rewrites a += b into a =a+b . This calls plus() , which doesn’t change the collection, but rather creates a new one and assigns the result to the var list reference. The net effect is that a += b still produces the result we expect for a —at least for simple types like Int . Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Using Operators 511 // UsingOperators/ReadOnlyAndPlus.kt import atomictest.eq fun main () { var list = listOf( 1 , 2 ) val initial = list list += 3 list eq [1, 2, 3] list = list.plus( 4 ) list eq [1, 2, 3, 4] initial eq [1, 2] } The last line shows that the initial collection remains unchanged. Creating a new collection for every added element probably isn’t your intent. Note that the problem won’t arise if you use val for list instead of var , in which case calling += won’t compile. This example shows one more reason to use val by default—only use var when necessary. Operators can improve the experience of working with special libraries, so they are primarily overloaded by library writers. The exception, and the operator that might most often be found in custom classes, is compareTo() . If you implement the Comparable interface and override its compareTo() , you automatically provide all basic comparison operations: // UsingOperators/CompareTo.kt package usingoperators import atomictest.eq data class Contact ( val name: String, val mobile: String ): Comparable<Contact> { override fun compareTo (other: Contact): Int = name.compareTo(other.name) } fun main () { val alice = Contact( Alice , 0123456789 ) val bob = Contact( Bob , 9876543210 ) Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Using Operators 512 val carl = Contact( Carl , 5678901234 ) (alice < bob) eq true (alice <= bob) eq true (alice > bob) eq false (alice >= bob) eq false val contacts = listOf(bob, carl, alice) contacts.sorted() eq listOf(alice, bob, carl) contacts.sortedDescending() eq listOf(carl, bob, alice) } Any two Comparable s can be compared using < , <= , > and >= . Implementing Comparable also enables features like sortability. Kotlin doesn’t require the operator modifier when overriding compareTo() be-cause it has already been defined as an operator in the Comparable interface. Destructuring Operators Another group of operators you don’t typically define is the componentN() func-tions ( component1() , component2() etc.), used for Destructuring Declarations . In main() , Kotlin quietly generates calls to component1() and component2() for the destructuring assignment: // UsingOperators/DestructuringDuo.kt package usingoperators import atomictest.* class Duo ( val x: Int, val y: Int) { operator fun component1 (): Int { trace( component1() ) return x } operator fun component2 (): Int { trace( component2() ) return y } } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Using Operators 513 fun main () { val ( a, b) = Duo( 1 , 2 ) a eq 1 b eq 2 trace eq  component1() component2()  } The same approach works with Map s, which use an Entry type containing compo-nent1() and component2() member functions: // UsingOperators/DestructuringMap.kt import atomictest.eq fun main () { val map = mapOf( a to 1 ) for ((key, value) in map) { key eq a value eq 1 } // The Destructuring assignment becomes: for (entry in map) { val key = entry.component1() val value = entry.component2() key eq a value eq 1 } } You can use destructuring declarations with any data class because componentN() functions are automatically generated: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Using Operators 514 // UsingOperators/DestructuringData.kt package usingoperators import atomictest.eq data class Person ( val name: String, val age: Int ){ // Compiler generates: // fun component1() = name // fun component2() = age } fun main () { val person = Person( Alice , 29 ) val ( name, age) = person // The Destructuring assignment becomes: val name_ = person.component1() val age_ = person.component2() name eq Alice age eq 29 name_ eq Alice age_ eq 29 } Kotlin generates a componentN() function for each property. Exercises and solutions for this atom can be found at AtomicKotlin.com ¹²⁰ . ¹²⁰ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Delegation A property can delegate its accessor logic. You connect a property to a delegate with the by keyword: val/var property by delegate The delegate’s class must contain a getValue() function if the property is a val (read only) or getValue() and setValue() functions if the property is a var (read/write). First consider the read-only case: // PropertyDelegation/BasicRead.kt package propertydelegation import atomictest.eq import kotlin.reflect.KProperty class Readable ( val i: Int) { val value: String by BasicRead() } class BasicRead { operator fun getValue ( r: Readable, property: KProperty<*> )= getValue: ${r.i} } fun main () { val x = Readable( 11 ) val y = Readable( 17 ) x.value eq getValue: 11 y.value eq getValue: 17 } value in Readable is delegated to a BasicRead object. getValue() takes a Readable parameter that allows it to access the Readable —when you say by it binds ","Property Delegation 516 the BasicRead to the whole Readable object. Notice that getValue() accesses i in Readable . Because getValue() returns a String , the type of value must also be String . The second getValue() parameter property is of the special type KProperty , and this provides reflective information about the delegated property. If the delegated property is a var , it must handle both reading and writing, so the delegate class requires both a getValue() and a setValue() : // PropertyDelegation/BasicReadWrite.kt package propertydelegation import atomictest.eq import kotlin.reflect.KProperty class ReadWriteable ( var i: Int) { var msg =  var value: String by BasicReadWrite() } class BasicReadWrite { operator fun getValue ( rw: ReadWriteable, property: KProperty<*> )= getValue: ${rw.i} operator fun setValue ( rw: ReadWriteable, property: KProperty<*>, s: String ){ rw.i = s.toIntOrNull() ?: 0 rw.msg = setValue to ${rw.i} } } fun main () { val x = ReadWriteable( 11 ) x.value eq getValue: 11 x.value = 99 x.msg eq setValue to 99 x.value eq getValue: 99 } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Delegation 517 The first two setValue() parameters are the same as getValue() , and the third is what we want to set: The value on the right side of the = . Both getValue() and setValue() must agree on the type that is read and written, which in this case is String (the type of value in ReadWriteable ). Notice that setValue() accesses i in ReadWriteable , and also msg . BasicRead.kt and BasicReadWrite.kt do not implement an interface . A class can be used as a delegate if it simply conforms to the convention of having the necessary function(s) with the necessary signature(s). However, you can also implement the ReadOnlyProperty interface in BasicRead.kt : // PropertyDelegation/BasicRead2.kt package propertydelegation import atomictest.eq import kotlin.properties.ReadOnlyProperty import kotlin.reflect.KProperty class Readable2 ( val i: Int) { val value: String by BasicRead2() // SAM conversion: val value2: String by ReadOnlyProperty { _, _ -> getValue: $i } } class BasicRead2 : ReadOnlyProperty<Readable2, String> { override operator fun getValue ( thisRef: Readable2, property: KProperty<*> )= getValue: ${thisRef.i} } fun main () { val x = Readable2( 11 ) val y = Readable2( 17 ) x.value eq getValue: 11 x.value2 eq getValue: 11 y.value eq getValue: 17 y.value2 eq getValue: 17 } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Delegation 518 This communicates to the reader that BasicRead2 can be used as a delegate and ensures a proper getValue() definition. Because ReadOnlyProperty has only a single member function (and it has been defined as a fun interface in the standard library), value2 can be defined much more succinctly using a SAM conversion . BasicReadWrite.kt can be modified to implement ReadWriteProperty , ensuring proper getValue() and setValue() definitions: // PropertyDelegation/BasicReadWrite2.kt package propertydelegation import atomictest.eq import kotlin.properties.ReadWriteProperty import kotlin.reflect.KProperty class ReadWriteable2 ( var i: Int) { var msg =  var value: String by BasicReadWrite2() } class BasicReadWrite2 : ReadWriteProperty<ReadWriteable2, String> { override operator fun getValue ( rw: ReadWriteable2, property: KProperty<*> )= getValue: ${rw.i} override operator fun setValue ( rw: ReadWriteable2, property: KProperty<*>, s: String ){ rw.i = s.toIntOrNull() ?: 0 rw.msg = setValue to ${rw.i} } } fun main () { val x = ReadWriteable2( 11 ) x.value eq getValue: 11 x.value = 99 x.msg eq setValue to 99 Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Delegation 519 x.value eq getValue: 99 } To review, a delegate class must contain either or both of the following functions, which are called when the delegated property is accessed: 1. For reading: `operator fun getValue(thisRef: T, property: KProperty<*>): V` 2. For writing: `setValue(thisRef: T, property: KProperty<*>, value: V)` If the delegated property is a val , only the first function is required and ReadOn-lyProperty can be implemented using a SAM conversion . The parameters are: • thisRef: T points to the delegate object, where T is the type of that delegate. If you don’t want to use thisRef in the function, you can effectively disable it by using Any? for T . • property: KProperty<*> provides information about the property itself. The most commonly-used is name , which produces the field name of the delegated property. • value is the value stored by setValue() into the delegated property. V is the type of that property. getValue() and setValue() can either be defined by convention, or written as implementations of ReadOnlyProperty or ReadWriteProperty . To enable access to private elements, nest the delegate class: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Delegation 520 // PropertyDelegation/Accessibility.kt package propertydelegation import atomictest.eq import kotlin.properties.ReadOnlyProperty import kotlin.reflect.KProperty class Person ( private val first: String, private val last: String ){ val name by // SAM conversion: ReadOnlyProperty<Person, String> { _, _ -> $first $last } } fun main () { val alien = Person( Floopy , Noopers ) alien.name eq Floopy Noopers } Assuming adequate access to the elements in the delegating class, getValue() and setValue() can be written as extension functions: // PropertyDelegation/Add.kt package propertydelegation2 import atomictest.eq import kotlin.reflect.KProperty class Add ( val a: Int, val b: Int) { val sum by Sum() } class Sum operator fun Sum .getValue( thisRef: Add, property: KProperty<*> ) = thisRef.a + thisRef.b fun main () { val addition = Add( 144 , 12 ) Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Delegation 521 addition.sum eq 156 } This way you can use an existing class that you are unable to modify or inherit and still delegate a property with it. Here, when you set the value of the property, the number stored is the Fibonacci number for that value, using the fibonacci() function from the Recursion atom: // PropertyDelegation/FibonacciProperty.kt package propertydelegation import kotlin.properties.ReadWriteProperty import kotlin.reflect.KProperty import recursion.fibonacci import atomictest.eq class Fibonacci : ReadWriteProperty<Any?, Long> { private var current: Long = 0 override operator fun getValue ( thisRef: Any?, property: KProperty<*> ) = current override operator fun setValue ( thisRef: Any?, property: KProperty<*>, value: Long ){ current = fibonacci(value.toInt()) } } fun main () { var fib by Fibonacci() fib eq 0L fib = 22L fib eq 17711L fib = 90L fib eq 2880067194370816120L } fib in main() is a local delegated property —it’s defined inside a function rather than a class. A delegated property can also be defined at file scope. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Delegation 522 ReadWriteProperty ’s first generic argument can be type Any? because we never use it to access anything inside Fibonacci , which would require specific type information. Instead we manipulate the current property as we can in any member function. In most of the examples we’ve seen so far, the first parameter of getValue() and setValue() are of a specific type. Those delegates were tied to that specific type. Sometimes it is possible to create a general-purpose delegate by ignoring the first type as Any? . For example, suppose we’d like to store each delegated String property in a text file named for that property: // PropertyDelegation/FileDelegate.kt package propertydelegation import kotlin.properties.ReadWriteProperty import kotlin.reflect.KProperty import checkinstructions.DataFile class FileDelegate : ReadWriteProperty<Any?, String> { override fun getValue ( thisRef: Any?, property: KProperty<*> ): String { val file = DataFile(property.name + .txt ) return if (file.exists()) file.readText() else  } override fun setValue ( thisRef: Any?, property: KProperty<*>, value: String ){ DataFile(property.name + .txt ) .writeText(value) } } This delegate only needs to interact with the file, and doesn’t need anything through thisRef . We ignore thisRef by typing it as Any? , because Any? has no interesting Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Delegation 523 operations. We are interested in property.name , which is the name of the field. Now we can automatically create a file associated with each property and store that property’s data in that file: // PropertyDelegation/Configuration.kt package propertydelegation import checkinstructions.DataFile import atomictest.eq class Configuration { var user by FileDelegate() var id by FileDelegate() var project by FileDelegate() } fun main () { val config = Configuration() config.user = Luciano config.id = Ramalho47 config.project = MyLittlePython DataFile( user.txt ).readText() eq Luciano DataFile( id.txt ).readText() eq Ramalho47 DataFile( project.txt ).readText() eq MyLittlePython } Because it can ignore the surrounding type, FileDelegate is reusable. Map is one of the few types in the Kotlin library that is preconfigured to be used as a delegated property. A single Map can be used to store all the properties in a class. Each property’s identifier becomes a String key for the map, and the property’s type is preserved in the associated value: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Delegation 524 // PropertyDelegation/CarService.kt package propertydelegation import atomictest.eq class Driver ( val map: MutableMap<String, Any?> ){ var name: String by map var age: Int by map var id: String by map var available: Boolean by map var coord: Pair<Double, Double> by map } fun main () { val info = mutableMapOf<String, Any?>( name to Bruno Fiat , age to 22 , id to X97C111 , available to false , coord to Pair( 111.93 , 1231.12 ) ) val driver = Driver(info); driver.available eq false driver.available = true info eq {name=Bruno Fiat, age=22,  + id=X97C111, available=true,  + coord=(111.93, 1231.12)} } Notice that the original info Map is modified when setting driver.available = true . Exercises and solutions for this atom can be found at AtomicKotlin.com ¹²¹ . ¹²¹ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Delegation Tools The functions in properties.Delegates perform special property dele-gation operations. Delegates.observable() allows you to observe modifications of a mutable prop-erty. Here, we trace old and new values: // DelegationTools/Team.kt package delegationtools import kotlin.properties.Delegates.observable import atomictest.eq class Team { var msg =  var captain: String by observable( <0> ){ prop, old, new -> msg += ${prop.name} $old to $new  } } fun main () { val team = Team() team.captain = Adam team.captain = Amanda team.msg eq captain <0> to Adam  + captain Adam to Amanda  } observable() takes two arguments: 1. The initial value for the property; <0> in this case. 2. A function which is the action to perform when the property is modified. Here, we use a lambda. The function arguments are the property being changed, the current value of that property, and the value it’s being changed to. Delegates.vetoable() allows you to prevent a change to a property if the new property value doesn’t satisfy the given predicate. Here, aName() insists that the team captain’s name begin with the letter “A”: ","Property Delegation Tools 526 // DelegationTools/TeamWithTraditions.kt package delegationtools import atomictest.* import kotlin.properties.Delegates import kotlin.reflect.KProperty fun aName ( property: KProperty<*>, old: String, new: String )= if (new.startsWith( A )) { trace( $old -> $new ) true } else { trace( Name must start with 'A' ) false } interface Captain { var captain: String } class TeamWithTraditions : Captain { override var captain: String by Delegates.vetoable( Adam , :: aName) } class TeamWithTraditions2 : Captain { override var captain: String by Delegates.vetoable( Adam ){ _, old, new -> if (new.startsWith( A )) { trace( $old -> $new ) true } else { trace( Name must start with 'A' ) false } } } fun main () { Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Delegation Tools 527 listOf( TeamWithTraditions(), TeamWithTraditions2() ).forEach { it.captain = Amanda it.captain = Bill it.captain eq Amanda } trace eq  Adam -> Amanda Name must start with 'A' Adam -> Amanda Name must start with 'A'  } Delegates.vetoable() takes two arguments: the initial value for the property, and an onChange() function, which is ::aName in this example. onChange() takes three arguments: property: KProperty<*> , the old value currently held by the property, and the new value being placed in the property. The function returns a Boolean indicating whether the change is successful or prevented. TeamWithTraditions2 defines Delegates.vetoable() using a lambda instead of the function aName() . The remaining tool in properties.Delegates is notNull() , which produces a property that must be initialized before it can be read: // DelegationTools/NeverNull.kt package delegationtools import atomictest.* import kotlin.properties.Delegates class NeverNull { var nn: Int by Delegates.notNull() } fun main () { val non = NeverNull() capture { non.nn } eq IllegalStateException: Property  + Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Delegation Tools 528 nn should be initialized before get. non.nn = 11 non.nn eq 11 } Trying to read non.nn before nn has been assigned a value produces an exception. After nn has been assigned, you can successfully read it. Notice that all three elements of properties.Delegates are functions, not the classes we saw in Property Delegation . Such functions are possible using a class containing a function named provideDelegate() . Here, that class is named Dele-gateProvider : // DelegationTools/DelegateProvider.kt package delegationtools import kotlin.reflect.KProperty import atomictest.* class Delegate <T>( private var value: T) { operator fun getValue ( thisRef: Any?, property: KProperty<*> ): T { trace( getValue: $value ) return value } operator fun setValue ( thisRef: Any?, property: KProperty<*>, newValue: T ){ trace( setValue: $newValue ) value = newValue } } class DelegateProvider <T>( val value: T) { operator fun provideDelegate ( thisRef: Any?, property: KProperty<*> ): Delegate<T> { trace( providing Delegate($value) ) Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Delegation Tools 529 return Delegate(value) } } fun < T > delegate(value: T): DelegateProvider<T> { trace( creating DelegateProvider($value) ) return DelegateProvider(value) } fun main () { var x by delegate( 3.14 ) trace( x created ) var y by delegate( Hello ) trace( y created ) var z by DelegateProvider( true ) trace( z created ) x eq 3.14 x= 1.62 x eq 1.62 y eq Hello y= Goodbye y eq Goodbye z eq true z= false z eq false trace eq  creating DelegateProvider( 3.14 ) providing Delegate( 3.14 ) x created creating DelegateProvider(Hello) providing Delegate(Hello) y created providing Delegate( true ) z created getValue: 3.14 setValue: 1.62 getValue: 1.62 getValue: Hello setValue: Goodbye getValue: Goodbye getValue: true Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Property Delegation Tools 530 setValue: false getValue: false  } Both x and y are created using the delegate() function, which provides the op-portunity to perform some extra operations before yielding the DelegateProvider object. However, z is delegated directly to a DelegateProvider , without calling delegate() . In all three cases, provideDelegate() is automatically called as part of delegate initialization, and it produces the actual delegate that is bound to x , y and z . Exercises and solutions for this atom can be found at AtomicKotlin.com ¹²² . ¹²² https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Lazy Initialization So far, you’ve learned two ways to initialize properties. 1. Store the initial value at the point of definition, or in the constructor. 2. Define a custom getter that computes the property for each access. This atom explores a third use case: costly initialization that you might not need right away, or ever. For example: • Complex and time-consuming calculations • Network requests • Database access This can produce two problems: 1. Long application start-up time. 2. Performing unnecessary work for a property that is never used, or that can have delayed access. This happens frequently enough that Kotlin includes a built-in solution. A lazy property is initialized when it’s first used, rather than when it’s created. If we never use a lazy property, it never performs that expensive initialization. The concept of lazy properties isn’t unique to Kotlin. Laziness can be implemented within other languages, whether or not they provide direct support. Kotlin provides a consistent, recognizable idiom for such properties using Property Delegation . With a lazy property, by is followed by a call to lazy() : val lazyProperty by lazy { initializer } lazy() takes a lambda containing the initialization logic. As usual, the last expres-sion in the lambda becomes the result, which is assigned to the property: ","Lazy Initialization 532 // LazyInitialization/LazySyntax.kt package lazyinitialization import atomictest.* val idle: String by lazy { trace( Initializing 'idle' ) I'm never used } val helpful: String by lazy { trace( Initializing 'helpful' ) I'm being used! } fun main () { trace(helpful) trace eq  Initializing ' helpful ' I ' m being used!  } The idle property isn’t initialized because it’s never accessed. Notice that both helpful and idle are val s. Without lazy initialization, you’d be forced to make them var s, producing less-reliable code. We can see all the work that lazy delegation does for you by implementing the behavior for an Int property without using delegation: // LazyInitialization/LazyInt.kt package lazyinitialization import atomictest.* class LazyInt ( val init: () -> Int) { private var helper: Int? = null val value: Int get () { if (helper == null ) helper = init() return helper !! } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Lazy Initialization 533 } fun main () { val later = LazyInt { trace( Initializing 'later' ) 5 } trace( First 'value' access: ) trace(later.value) trace( Second 'value' access: ) trace(later.value) trace eq  First ' value ' access: Initializing ' later ' 5 Second ' value ' access: 5  } The value property doesn’t store a value, but instead has a getter that retrieves the value from the helper property. This is similar to the code that Kotlin generates when you use the lazy keyword. Now we can compare the three ways to initialize a property—at the point of definition, using a getter, and using lazy initialization: // LazyInitialization/PropertyOptions.kt package lazyinitialization import atomictest.trace fun compute (i: Int): Int { trace( Compute $i ) return i } object Properties { val atDefinition = compute( 1 ) val getter get () = compute( 2 ) val lazyInit by lazy { compute( 3 )} val never by lazy { compute( 4 )} Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Lazy Initialization 534 } fun main () { listOf( Properties :: atDefinition, Properties :: getter, Properties :: lazyInit ).forEach { trace( ${it.name}: ) trace( ${it.get()} ) trace( ${it.get()} ) } trace eq  Compute 1 atDefinition: 1 1 getter: Compute 2 2 Compute 2 2 lazyInit: Compute 3 3 3  } • atDefinition is initialized when you create an instance of Properties . • “Compute 1” appears before “atDefinition:” which shows that initialization happens before any accesses. • getter is computed every time you access it. “Compute 2” appears twice, once for each access to the property. • The initialization value for lazyInit is only calculated the first time it is accessed. Initialization never happens if you don’t access that property—notice that “Compute 4” never appears in the trace. Exercises and solutions for this atom can be found at AtomicKotlin.com ¹²³ . ¹²³ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Late Initialization Sometimes you want to initialize properties of your class after it is created, but in a separate member function instead of using lazy . For example, a framework or library might require initialization in a special function. You might be extending a library class to provide your own implementation of that special function. Consider a Bag interface with a setUp() that initializes instances: // LateInitialization/Bag.kt package lateinitialization interface Bag { fun setUp () } Suppose we want to reuse a library that creates and manipulates Bag s and guarantees that setUp() is called. This library requires subclass initialization in setUp() instead of a constructor: // LateInitialization/Suitcase.kt package lateinitialization import atomictest.eq class Suitcase : Bag { private var items: String? = null override fun setUp () { items = socks, jacket, laptop } fun checkSocks (): Boolean = items ?. contains( socks ) ?: false } fun main () { ","Late Initialization 536 val suitcase = Suitcase() suitcase.setUp() suitcase.checkSocks() eq true } Suitcase initializes items by overriding setUp() . However, we can’t just define items as a String —if we do that, we must provide a non-null initializer in the constructor. Using a stub value such as an empty String is a bad practice because you never know whether it’s actually been initialized. null indicates that it’s not initialized. Defining items as a nullable String? means we must check for null in all member functions, as in checkSocks() . However, we know that the library we’re reusing initializes items by calling setUp() , so the null checks should not be necessary. The lateinit property modifier fixes this problem—here, we initialize items after creating an instance of BetterSuitcase : // LateInitialization/BetterSuitcase.kt package lateinitialization import atomictest.eq class BetterSuitcase : Bag { lateinit var items: String override fun setUp () { items = socks, jacket, laptop } fun checkSocks () = socks in items } fun main () { val suitcase = BetterSuitcase() suitcase.setUp() suitcase.checkSocks() eq true } Compare this version of checkSocks() with the one in Suitcase.kt . lateinit means items is safely defined as a non-nullable property. lateinit can be used on a property inside the body of a class, a top-level property, or local var . Limitations: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Late Initialization 537 • lateinit can only be used on a var property, not a val . • The property must be a non-null type. • The property cannot be a primitive type. • lateinit is not allowed for abstract properties in an abstract class or interface . • lateinit is not allowed for properties with a custom get() or set() . What happens if you forget to initialize such a property? You won’t get compile-time errors or warnings, because the initialization logic might be complex and depend on other properties that Kotlin can’t monitor: // LateInitialization/FaultySuitcase.kt package lateinitialization import atomictest.* class FaultySuitcase : Bag { lateinit var items: String override fun setUp () {} fun checkSocks () = socks in items } fun main () { val suitcase = FaultySuitcase() suitcase.setUp() capture { suitcase.checkSocks() } eq UninitializedPropertyAccessException + : lateinit property items  + has not been initialized } This runtime exception has enough detail for you to easily discover and fix the problem. Tracking down an error reported by a null pointer exception is usually much more difficult. .isInitialized will tell you whether a lateinit property been initialized. The property must be in your current scope, and is accessed using the :: operator: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Late Initialization 538 // LateInitialization/IsInitialized.kt package lateinitialization import atomictest.* class WithLate { lateinit var x: String fun status () = ${::x.isInitialized} } lateinit var y: String fun main () { trace( ${::y.isInitialized} ) y= Ready trace( ${::y.isInitialized} ) val withlate = WithLate() trace(withlate.status()) withlate.x = Set trace(withlate.status()) trace eq  false true false true  } Although you can create a local lateinit var , you cannot call .isInitialized on it because references to local var s or val s are not supported. Exercises and solutions for this atom can be found at AtomicKotlin.com ¹²⁴ . ¹²⁴ https://www.atomickotlin.com/exercises/ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendices ","Appendix A: AtomicTest A minimal test framework used to validate the example output in this book. Introduces and promotes unit testing early in the learning process. // AtomicTest/AtomicTest.kt package atomictest import kotlin.math.abs const val ERROR_TAG = [Error]:  private fun < L , R> runTest( actual: L, expected: R, checkEquals: Boolean = true , test: () -> Boolean ){ println(actual) if (!test()) { print(ERROR_TAG) println( $actual  + ( if (checkEquals) != else == )+  $expected ) } } /** * Compares the string representation * of the object with the string 'value'. */ infix fun < T : Any> T.eq(value: String) { runTest( this , value) { this .toString() == value.trimIndent() } } ","Appendix A: AtomicTest 541 /** * Verifies that this object is * equal to 'value'. */ infix fun < T > T.eq(value: T) { runTest( this , value) { this == value } } /** * Verifies that this object is not * equal to 'value'. */ infix fun < T > T.neq(value: T) { runTest( this , value, checkEquals = false ){ this != value } } /** * Verifies that a 'Double' number is equal * to 'value' within a positive delta. */ infix fun Double .eq(value: Double) { runTest( this , value) { abs( this - value) < 0.0000001 } } /** * Captures an exception and produces its name. * Usage: * capture { * // Code that fails * } eq FailureException */ fun capture (f: () -> Unit): String = try { f() $ERROR_TAG Expected an exception } catch (e: Throwable) { Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix A: AtomicTest 542 e :: class .simpleName + (e.message ?. let { : $it } ?:  ) } object trace { private val trc = mutableListOf<String>() operator fun invoke (obj: Any?) { trc += obj.toString() } /** * Compares Trace contents to a multiline * String by ignoring line separators. */ infix fun eq (multiline: String) { val trace = trc.joinToString( n ) val expected = multiline.trimIndent() .trim().replace( n ,  ) runTest(trace, multiline) { trace.replace( n ,  ) == expected } trc.clear() } } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability This appendix describes issues and techniques for interfacing between Kotlin and Java. An essential Kotlin design goal is to create a seamless experience for Java program-mers. If you want to slowly migrate to Kotlin, you can easily start by sprinkling bits of Kotlin into your existing Java project. This way you can write new Kotlin code atop your Java base, benefiting from Kotlin language features without being forced to rewrite Java code when it doesn’t make sense. Not only is it easy to call Java code from Kotlin, it’s also straightforward to call Kotlin code within a Java program. Calling Java from Kotlin To use a Java class from Kotlin, import it, create an instance, and call a function, just as you would in Java. Here, we use java.util.Random() : // Interoperability/Random.kt import atomictest.eq import java.util.Random fun main () { val rand = Random( 47 ) rand.nextInt( 100 ) eq 58 } As with creating any instance in Kotlin, you don’t need Java’s new . A class from a Java library works just like a native Kotlin class. JavaBean-style getters and setters in a Java class become properties in Kotlin: ","Appendix B: Java Interoperability 544 // Interoperability/Chameleon.java package Interoperability ; import java.io.Serializable ; public class Chameleon implements Serializable { private int size ; private String color ; public int getSize () { return size ; } public void setSize ( int newSize ){ size = newSize ; } public String getColor () { return color ; } public void setColor ( String newColor ){ color = newColor ; } } When working with Java, the package name must be identical (including case) to the directory name. Conventionally, Java package names contain only lowercase letters, but we violate this convention to fit this book. The imported Chameleon class works like a Kotlin class with properties: // Interoperability/UseBeanClass.kt import Interoperability.Chameleon import atomictest.eq fun main () { val chameleon = Chameleon() chameleon.size = 1 chameleon.size eq 1 chameleon.color = green chameleon.color eq green chameleon.color = turquoise chameleon.color eq turquoise } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 545 Kotlin leverages Java classes using extension functions. For example, we can add an adjustToTemperature() operation to Chameleon : // Interoperability/ExtensionsToJavaClass.kt package interop import Interoperability.Chameleon import atomictest.eq fun Chameleon .adjustToTemperature( isHot: Boolean ){ color = if (isHot) grey else black } fun main () { val chameleon = Chameleon() chameleon.size = 2 chameleon.size eq 2 chameleon.adjustToTemperature(isHot = true ) chameleon.color eq grey } Extension functions are especially helpful when you use an existing Java library that lacks needed member functions. The Kotlin standard library contains many extensions for classes from the Java standard library such as Iterable and List . Calling Kotlin from Java Kotlin easily produces libraries that are usable from Java. For the Java programmer, a Kotlin library looks like just another Java library. Because everything in Java is a class, let’s start with a Kotlin class containing a property and a function: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 546 // Interoperability/KotlinClass.kt package interop class Basic { var property1 = 1 fun value () = property1 * 10 } If you import this class into Java, it looks like an ordinary Java class: // Interoperability/UsingKotlinClass.java package Interoperability ; import interop.Basic ; import static atomictest.AtomicTestKt.eq ; public class UsingKotlinClass { public static void main ( String [] args ){ Basic b = new Basic (); eq ( b . getProperty1 (), 1); b . setProperty1 (12); eq ( b . value (), 120); } } property1 becomes a private field containing JavaBean-style getters and setters. The value() member function becomes a Java method with the same name. We have also imported AtomicTest , which requires additional ceremony in Java: we must import it using the static keyword and give the package name. eq() can only be called as an ordinary function because Java doesn’t support infix notation. If you put a Kotlin class into the same package as Java code, you don’t need to import it: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 547 // Interoperability/KotlinDataClass.kt package Interoperability data class Data ( var name: String, var age: Int ) data classes generate extra member functions like equals() , hashCode() and toString() , all of which work seamlessly within Java. Here we test the implemen-tations of equals() and hashCode() by placing a Data object into a HashMap , then retrieving it: // Interoperability/UsingDataClass.java package Interoperability ; import java.util.HashMap ; import static atomictest.AtomicTestKt.eq ; public class UsingDataClass { public static void main ( String [] args ){ Data d = new Data ( Alice , 22); String name = d . getName (); d . setName ( Bob ); int age = d . getAge (); d . setAge ( age + 1); // toString(): eq ( d , Data(name=Bob, age=23) ); HashMap < Data , Integer > hm = new HashMap <>(); hm . put ( d , 47); // Data objects work as hash keys: eq (( double ) hm . get ( d ), ( double )47); // Call copy() from the Data class: Data d2 = d . copy ( Sam , 24); eq ( d2 , Data(name=Sam, age=24) ); } } If you use the command line to run Java code that incorporates Kotlin code, you must include kotlin-runtime.jar as a dependency, otherwise you’ll get runtime exceptions complaining that some of the library utility classes are not found. IntelliJ IDEA automatically includes kotlin-runtime.jar . Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 548 What about top-level functions in Kotlin? These map to static methods in a Java class that takes its name from the Kotlin file: // Interoperability/TopLevelFunction.kt package interop fun hi () = Hello! While importing, specify the class name generated by Kotlin when calling the static method: // Interoperability/CallTopLevelFunction.java package Interoperability ; import interop.TopLevelFunctionKt ; import static atomictest.AtomicTestKt.eq ; public class CallTopLevelFunction { public static void main ( String [] args ){ eq ( TopLevelFunctionKt . hi (), Hello! ); } } If you don’t want to qualify hi() with the package name, use import static as we do with AtomicTest : // Interoperability/CallTopLevelFunction2.java package Interoperability ; import static interop.TopLevelFunctionKt.hi ; import static atomictest.AtomicTestKt.eq ; public class CallTopLevelFunction2 { public static void main ( String [] args ){ eq ( hi (), Hello! ); } } If you don’t like the class name generated by Kotlin, you can change it using the @JvmName annotation: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 549 // Interoperability/ChangeName.kt @file:JvmName( Utils ) package interop fun salad () = Lettuce! Now instead of ChangeNameKt , we use Utils : // Interoperability/MakeSalad.java package Interoperability ; import interop.Utils ; import static atomictest.AtomicTestKt.eq ; public class MakeSalad { public static void main ( String [] args ){ eq ( Utils . salad (), Lettuce! ); } } You can find further details in the Kotlin Documentation¹²⁵ . Adapting Java to Kotlin One of Kotlin’s design goals is to take an existing Java type and adapt it to your needs. This ability is not restricted to library designers. This section shows how easy and powerful this adaptation can be. In Recursion , we created Fibonacci.kt to efficiently produce Fibonacci numbers. However, that implementation is limited by the size of the Long it returns. If you’d like to return larger values, the Java standard library includes the BigInteger class, which is useful but awkward and un-Kotlinish. With a few lines of code, we can morph it into something that feels like a native Kotlin class: ¹²⁵ https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 550 // Interoperability/BigInt.kt package bigint import java.math.BigInteger typealias BigInt = BigInteger val Int.big: BigInt get () = BigInt.valueOf(toLong()) val String.big: BigInt get () = BigInt( this ) val zero = BigInt.ZERO val one = BigInt.ONE To distinguish our class from the Java version, we use a typealias to create the name BigInt . The big property extension converts any Int to a BigInt . The getter function for this property calls the underlying Java library valueOf() after applying toLong() to the Int . We could also have created an extension function, but making it a property allows the user to call it without using parentheses, so the result is cleaner. There’s also a big extension property to String . This takes the String and uses the underlying Java BigInteger constructor that takes a String argument, resulting in a BigInt . The constant values zero and one are produced directly from their BigInteger counterparts. Now it’s easy to convert Recursion/Fibonacci.kt to a BigInt version which can produce much larger results: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 551 // Interoperability/BigFibonacci.kt package interop import atomictest.eq import bigint.* fun fibonacci (n: Int): BigInt { tailrec fun fibonacci ( n: Int, current: BigInt, next: BigInt ): BigInt { if (n == 0 ) return current return fibonacci( n-1 , next, current + next) } return fibonacci(n, zero, one) } fun main () { ( 0. . 7 ).map { fibonacci(it) } eq [0, 1, 1, 2, 3, 5, 8, 13] fibonacci( 22 ) eq 17711. big fibonacci( 150 ) eq 9969216677189303386214405760200 .big } The conversion of fibonacci() entails replacing everything that was Long with its BigInt equivalent. In main() you see both Int and String converted to BigInt using the respective big extension properties. fibonacci(150) overflows the Recursion/Fibonacci.kt version. Java Checked Exceptions & Kotlin The only reason to catch an exception is if you can somehow recover from the problem. If it’s not something you can fix, there’s no point in writing a catch clause for that exception—just let it become an error report. The original Java designers tried a fresh new experiment, untested in any other language, for the very first version of Java (so certain were they that it was the best Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 552 of ideas). Java was predominantly patterned after the C++ language, which allowed you to specify what exceptions a function might throw. The Java designers decided to go one step further and force anyone calling that function to catch every specified exception. This seemed like a good idea at the time, and thus was born checked exceptions (An experiment that, to our knowledge, has never been repeated in any subsequent programming languages). Here’s how Java forces you to catch checked exceptions in the process of opening, reading and closing a file. We only provide the basics to show the checked exceptions; you must actually write more complex code to correctly solve this problem in Java: // Interoperability/JavaChecked.java package Interoperability ; import java.io.* ; import java.nio.file.* ; import static atomictest.AtomicTestKt.eq ; public class JavaChecked { // Build path to current source file, based // on directory where Gradle is invoked: static Path thisFile = Paths . get ( Examples , Interoperability , JavaChecked.java ); public static void main ( String [] args ){ BufferedReader source = null ; try { source = new BufferedReader ( new FileReader ( thisFile . toFile ())); } catch ( FileNotFoundException e ){ // Recover from file-open error } try { String first = source . readLine (); eq ( first , // Interoperability/ + JavaChecked.java ); } catch ( IOException e ){ // Recover from read() error } try { source . close (); } catch ( IOException e ){ Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 553 // Recover from close() error } } } Each of the above operations involve checked exceptions and must be inside a try block or Java will report compile-time errors for uncaught exceptions. In each case, recovery from the error seems dubious, but you’re forced to write the try -catch anyway. What happens if we rewrite this example in Kotlin? // Interoperability/KotlinChecked.kt import atomictest.eq import java.io.File fun main () { File( Examples/Interoperability/ + KotlinChecked.kt ) .readLines()[ 0 ] eq // Interoperability/KotlinChecked.kt } Kotlin allows us to reduce the operation to a single line of code because it adds extension functions to the Java File class. At the same time, Kotlin eliminates the checked exceptions. If we wanted, we could surround intermediate operations with try -catch blocks, but Kotlin does not enforce checked exceptions. This provides error reporting without forcing you to write all that extra noisy code. Java libraries often use checked exceptions in situations that are outside the pro-grammer’s control and are typically unrecoverable. In these cases, it’s best to catch the exception at the top level and restart the process, if possible. Requiring all intermediate levels to pass the exception only adds cognitive overhead when trying to understand the code. If you’re writing Kotlin code that is called from Java and you must specify a checked exception, Kotlin provides the @Throws annotation to give this information to the Java caller: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 554 // Interoperability/AnnotateThrows.kt package interop import java.io.IOException @Throws(IOException :: class ) fun hasCheckedException () { throw IOException() } Here’s how you call hasCheckedException() from Java: // Interoperability/CatchChecked.java package Interoperability ; import interop.AnnotateThrowsKt ; import java.io.IOException ; import static atomictest.AtomicTestKt.eq ; public class CatchChecked { public static void main ( String [] args ){ try { AnnotateThrowsKt . hasCheckedException (); } catch ( IOException e ){ eq ( e , java.io.IOException ); } } } If you don’t handle the exception, the Java compiler issues an error message. Although Kotlin includes language support for exception handling, it tends to emphasize error reporting and reserves exception handling for those rare situations where you can actually recover from a problem (almost exclusively I/O operations). Nullable Types & Java Kotlin ensures that pure Kotlin code has no null errors, but when you call into Java, you have no such guarantees. In the following Java code, get() sometimes returns null : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 555 // Interoperability/JTool.java package Interoperability ; public class JTool { public static JTool get ( String s ){ if ( s == null ) return null ; return new JTool (); } public String method () { return Success ; } } To use JTool within Kotlin, you must know how get() behaves. You have three choices, shown here in the definitions of a , b and c : // Interoperability/PlatformTypes.kt package interop import Interoperability.JTool import atomictest.eq object KotlinCode { val a: JTool? = JTool. get (  ) // [1] val b: JTool = JTool. get (  ) // [2] val c = JTool. get (  ) // [3] } fun main () { with(KotlinCode) { a ?. method() eq Success // [4] b.method() eq Success c.method() eq Success // [5] :: a.returnType eq Interoperability.JTool? :: b.returnType eq Interoperability.JTool :: c.returnType eq Interoperability.JTool! // [6] } } • [1] Specify the type as nullable. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 556 • [2] Specify the type as non-null . • [3] Use type inference. By placing a , b and c within an object , we can discover their return types. In main() , the with() allows us to refer to each one without KotlinCode qualification. Because the identifiers are inside an object , we can use member reference syntax and the returnType property to determine the return types. To initialize a , b and c , we pass a non-null String to get() , so a , b and c all end up with non-null references and each one can successfully call method() . • [4] Because a is nullable, it must use ?. during member function calls. • [5] c behaves like a non-null reference and can be dereferenced without any additional checks. • [6] Notice that c returns neither a nullable type nor a non-null type, but something entirely different: JTool! . Type! is Kotlin’s platform type , and has no notation—you can’t write it into your code. It is used whenever Kotlin must infer a type outside its domain. If a type comes from Java, accessing it can produce a null pointer exception (NPE). Here’s what happens when JTool.get() returns a null reference: // Interoperability/NPEOnPlatformType.kt import Interoperability.JTool import atomictest.* fun main () { val xn = JTool. get ( null ) // [1] xn ?. method() eq null // [2] capture { xn.method() // [3] } eq NullPointerException val yn: JTool? = JTool. get ( null ) // [4] yn ?. method() eq null capture { val zn: JTool = JTool. get ( null ) // [5] } eq NullPointerException:  + JTool.get(null) must not be null } Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 557 When you call a Java method like JTool.get() inside Kotlin, its return value (unless annotated as explained in the next section) is a platform type, which in this case is JTool! . • [1] At the point of definition, xn successfully receives the null without complaint. • [2] You can dereference xn by using a safe-access call ?. , which in this case returns null . • [3] However, using ?. is not required. You can simply dereference xn . In this case you get a NullPointerException without any helpful message, as with Java and other languages that lack support for nullable types. • [4] Because yn is of type JTool? , it can successfully receive a null . Assigning to a nullable type is safe, because Kotlin forces you to test for null using ?. when calling method() . • [5] Assigning to a non-null type can produce an NPE. Kotlin checks for nullity at the point of assignment. The initialization of zn fails because the declared type JTool promises that zn is not nullable, but it receives a null and produces a NullPointerException , but with a helpful message this time. The exception message contains detailed information about the expression that produced the null : NullPointerException: JTool.get(null) must not be null . Even though it’s a runtime exception, the comprehensive error message makes the problem much easier than fixing a regular NPE. A platform type contains the least amount of information available for that type. In this case, it only tells you that the type is JTool . It might or might not be nullable— when using an inferred platform type you simply don’t know. You can’t explicitly declare a platform type (e.g. JTool! ). You can only observe a platform type in error messages, or when you display the inferred type as in the example above, or by checking the type within the IDE. Platform types provide seamless Java interoperability, and maintain the consistency of type inference. However, don’t rely on them. The proper strategy when calling un-annotated Java code is to avoid type inference, and instead understand whether or not the code you are calling can produce null s. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 558 Nullability Annotations When working on a mixed Kotlin and Java project, you may or may not have control over the Java code base. When using components from the Java Standard Library, for example, you can’t modify the Java code, so you must work with platform types. If you control the Java code base, you can add nullability annotations to the Java code and avoid subtle NPE errors. @Nullable tells Kotlin to treat a Java type as nullable, while @NotNull tells Kotlin to treat a Java type as non-nullable. Here we add Kotlin nullability annotations to JTool.java : // Interoperability/AnnotatedJTool.java package Interoperability ; import org.jetbrains.annotations.NotNull ; import org.jetbrains.annotations.Nullable ; public class AnnotatedJTool { @Nullable public static JTool getUnsafe ( @Nullable String s ){ if ( s == null ) return null ; return getSafe ( s ); } @NotNull public static JTool getSafe ( @NotNull String s ){ return new JTool (); } public String method () { return Success ; } } Applying an annotation in front of a Java method modifies the return type. Applying an annotation to a parameter affects only that parameter. When you call getUnsafe() and getSafe() in Kotlin, Kotlin treats the Annotat-edJTool member functions as native Kotlin nullable or non-nullable: Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 559 // Interoperability/AnnotatedJava.kt package interop import Interoperability.AnnotatedJTool import atomictest.eq object KotlinCode2 { val a = AnnotatedJTool.getSafe(  ) // Doesn't compile: // val b = AnnotatedJTool.getSafe(null) val c = AnnotatedJTool.getUnsafe(  ) val d = AnnotatedJTool.getUnsafe( null ) } fun main () { with(KotlinCode2) { :: a.returnType eq Interoperability.JTool :: c.returnType eq Interoperability.JTool? :: d.returnType eq Interoperability.JTool? } } @NotNull JTool is transformed to Kotlin’s non-null type JTool , and the annotated @Nullable JTool is transformed to Kotlin’s JTool? . You can see this in the types shown in main() for a , c , and d . You can’t pass a nullable argument when a non-null argument is expected, even if it’s a Java type annotated with @NotNull , so Kotlin won’t compile AnnotatedJ-Tool.getSafe(null) . Different kinds of nullability annotations are supported, using different names: • @Nullable and @CheckForNull are specified by the JSR-305 standard. • @Nullable and @NonNull are used in Android. • @Nullable and @NotNull are supported by JetBrains tools. • There are others. You can find the full list in the Kotlin documentation. Kotlin detects default nullability annotations for a Java package or class, as specified in the JSR-305 standard. If it’s @NotNull by default, you should explicitly specify only Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 560 @Nullable annotations. If it’s @Nullable by default, you should explicitly specify only @NotNull annotations. The documentation contains the technical details of choosing the default annotation. If you develop mixed Kotlin and Java projects, your applications will be safer if you use nullability annotations in your Java code. Collections & Java This book doesn’t require Java knowledge. However, when you write code in Kotlin for the Java Virtual Machine (JVM), it’s helpful to be familiar with the Java standard collections library, because that’s what Kotlin uses under the hood. The Java collections library is a set of classes and interfaces that implement collection data structures, such as lists, sets and maps. These data structures usually have clear and simple interfaces, but for speed may have complicated implementations. New languages typically create their own collections library from scratch. For example, the Scala language has its own collections library which in many ways surpasses the Java collections library, but also makes it more challenging to mix Scala and Java. Kotlin’s collections library is intentionally not rewritten from scratch; instead, it consists of improvements atop the Java collections library. For example, when you create a mutable List , you’re actually using Java’s ArrayList : // Interoperability/HiddenArrayList.kt import atomictest.eq fun main () { val list = mutableListOf( 1 , 2 , 3 ) list.javaClass.name eq java.util.ArrayList } For seamless interoperability with Java code, Kotlin uses the interfaces from the Java standard library, and often the same implementations. This produces three benefits: 1. Kotlin code can be easily mixed with Java code. No additional conversion is required when passing Kotlin collections to Java code. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 561 2. Years of performance tuning in the Java standard library is automatically available to Kotlin programmers. 3. The standard library included with a Kotlin application is small, because it uses Java collections rather than defining its own. The Kotlin standard library consists primarily of extension functions that improve the Java collections. Kotlin also fixes a design problem. In Java all collection interfaces are mutable. For example, java.util.List has methods add() and remove() that modify the List . As we’ve shown throughout this book, mutability is the source of a significant number of programming problems. Thus, in Kotlin, the default Collection type is read-only: // Interoperability/ReadOnlyByDefault.kt package interop data class Animal ( val name: String) interface Zoo { fun viewAnimals (): Collection<Animal> } fun visitZoo (zoo: Zoo) { val animals = zoo.viewAnimals() // Compile-time error: // animals.add(Animal(Grumpy Cat)) } Making a collection read-only makes the collection safer and more bug-free by preventing accidental modification. Java provides a partial solution for collection immutability: when returning a collection you can place it inside a special wrapper that throws an exception for any attempt to modify the underlying collection. This doesn’t produce static type checking, but can still prevent subtle bugs. However, you must remember to wrap the collection, whereas in Kotlin you must be explicit when you want a mutable collection. Kotlin has separate interfaces for mutable and read-only collections: • Collection / MutableCollection Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 562 • List / MutableList • Set / MutableSet • Map / MutableMap These duplicate the interfaces from the Java standard library: • java.util.Collection • java.util.List • java.util.Set • java.util.Map In Kotlin, as in Java, Collection is a supertype for both List and Set . MutableCol-lection extends Collection and is a supertype of MutableList and MutableSet . Here’s the basic structure: // Interoperability/CollectionStructure.kt package collectionstructure interface Collection <E> interface List <E>: Collection<E> interface Set <E>: Collection<E> interface Map <K, V> interface MutableCollection <E> interface MutableList <E>: List<E>, MutableCollection<E> interface MutableSet <E>: Set<E>, MutableCollection<E> interface MutableMap <K, V>: Map<K, V> For simplicity, we show only the names and not the full declarations from the Kotlin standard library. Kotlin mutable collections match their Java counterparts. If you compare Muta-bleCollection from kotlin.collections with java.util.List , you’ll see that they declare the same member functions ( methods , in Java terminology). Kotlin’s Collection , List , Set and Map also duplicate Java’s interfaces, but without any mutation methods. Both kotlin.collections.List and kotlin.collections.MutableList are visible from Java as java.util.List . These interfaces are special: they exist only in Kotlin, but at the bytecode level they are both replaced with Java’s List . A Kotlin List can be cast to a Java List : Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC ","Appendix B: Java Interoperability 563 // Interoperability/JavaList.kt import atomictest.eq fun main () { val list = listOf( 1 , 2 , 3 ) (list is java.util.List<*>) eq true } This code produces a warning: • This class shouldn’t be used in Kotlin. • Use kotlin.collections.List or kotlin.collections.MutableList instead. This is a reminder to use Kotlin’s interfaces, not Java’s, when programming in Kotlin. Keep in mind that read-only is not the same as immutable. A collection cannot be changed using a read-only reference, but it can still change: // Interoperability/ReadOnlyCollections.kt import atomictest.eq fun main () { val mutable = mutableListOf( 1 , 2 , 3 ) // Read-only reference to a mutable list: val list: List<Int> = mutable mutable += 4 // list has changed: list eq [1, 2, 3, 4] } Here, the read-only list references a MutableList , which can then be changed by manipulating mutable . Because all Java collections are mutable, Java code can modify a read-only Kotlin collection, even if you pass it via a read-only reference. Kotlin collections don’t produce full safety, but provide a good compromise between having a better library and maintaining compatibility with Java. Atomic Kotlin (www.AtomicKotlin.com) by Bruce Eckel & Svetlana Isakova, ©2020 MindView LLC "]